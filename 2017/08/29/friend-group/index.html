<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>求朋友关系中的朋友圈数量</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>求朋友关系中的朋友圈数量</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2017-08-29">2017-08-29</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#algorithms" title="algorithms">algorithms</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#union-find" title="union-find">union-find</a>&nbsp;
  
</span>

</section>
<section class="post">
<h2 id="题目描述">题目描述</h2>

<p>给出10W条人和人之间的朋友关系，求出这些朋友关系中有多少个朋友圈（如A-B、B-C、D-E、E-F，这4对关系中存在两个朋友圈），并给出算法的时间复杂度。</p>

<h2 id="解答">解答</h2>

<p>这道题实际上考察的是”并查集”这一数据结构. 对于这类问题, 看似并不复杂, 但数据量极大, 如果用正常的数据结构来描述的话, 往往空间上过大, 计算机无法承受, 即使在空间上勉强通过, 运行的时间复杂度也极高. 只能用并查集来描述</p>

<h2 id="并查集的主要操作">并查集的主要操作</h2>

<ul>
  <li>初始化</li>
</ul>

<p>把每个点所在的集合初始化为自身. 通常来说, 这个步骤在每次使用该数据结构时只需要执行一次, 无论何种方式实现, 时间复杂度均为O(n)</p>

<ul>
  <li>查找</li>
</ul>

<p>查找元素所在的集合, 即根节点</p>

<ul>
  <li>合并</li>
</ul>

<p>将两个元素所在的集合合并为一个集合. 通常来说, 在合并之前, 应先判断两个元素是否属于同一集合, 这可用上面的”查找”操作来实现.</p>

<p>因此, 对于题目中的朋友圈关系, A-B, B-C, D-E, E-F.我们的算法过程如下:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">start</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">A</span><span class="p">)(</span><span class="n">B</span><span class="p">)(</span><span class="n">C</span><span class="p">)(</span><span class="n">D</span><span class="p">)(</span><span class="n">E</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span>
<span class="n">A</span><span class="o">-</span><span class="n">B</span>   <span class="o">=&gt;</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)(</span><span class="n">C</span><span class="p">)(</span><span class="n">D</span><span class="p">)(</span><span class="n">E</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span>
<span class="n">B</span><span class="o">-</span><span class="n">C</span>   <span class="o">=&gt;</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">)(</span><span class="n">D</span><span class="p">)(</span><span class="n">E</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span>
<span class="n">D</span><span class="o">-</span><span class="n">E</span>   <span class="o">=&gt;</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">)(</span><span class="n">D</span><span class="p">,</span><span class="n">E</span><span class="p">)(</span><span class="n">F</span><span class="p">)</span>
<span class="n">E</span><span class="o">-</span><span class="n">F</span>   <span class="o">=&gt;</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">)(</span><span class="n">D</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="算法">算法</h2>

<p>对于每个集合, 都使用集合中的某个元素来代表这个集合, 也就是<code class="highlighter-rouge">代表元</code>. 意思就是在集合(朋友圈)里建一个树, 当要确定一个元素属于哪个集合时, 只需要根据它的父节点网上遍历找到根节点(代表元). 根据它们的代表元来确定它属于哪个集合里.</p>

<p>并查集主要是三个操作</p>

<ul>
  <li>初始化</li>
</ul>

<p>对所有的单个数据建立一个单独的集合.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//用结构体表示
</span><span class="cp">#define MAX 100000
</span><span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">rank</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span><span class="n">node</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>

<span class="c1">//用数组表示
</span><span class="kt">int</span> <span class="n">set</span><span class="p">[</span><span class="n">max</span><span class="p">];</span><span class="c1">//类别，或者用parent,father表示
</span><span class="kt">int</span> <span class="n">rank</span><span class="p">[</span><span class="n">max</span><span class="p">];</span><span class="c1">//层次，初始化为0
</span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">max</span><span class="p">];</span><span class="c1">//数据
</span></code></pre></div></div>

<p>初始化操作:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Make_Set</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
  <span class="n">set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
  <span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>查找</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">get_parent</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span><span class="c1">//结构体
</span>  <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">parent</span><span class="o">==</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">get_parent</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Find_Set</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span> <span class="c1">//数组
</span>  <span class="c1">//如果集合i的父亲是自己，说明自己就是源头，返回自己的标号
</span>  <span class="k">if</span><span class="p">(</span><span class="n">set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">set</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="c1">//否则查找集合i的父亲的源头
</span>  <span class="k">return</span>  <span class="n">Find_Set</span><span class="p">(</span><span class="n">set</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>        
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>合并</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="c1">//结构体
</span>  <span class="n">a</span><span class="o">=</span><span class="n">get_parent</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">b</span><span class="o">=</span><span class="n">get_parent</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">rank</span><span class="o">&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">rank</span><span class="p">)</span>
    <span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">parent</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">parent</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">rank</span><span class="o">==</span><span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">rank</span><span class="p">)</span>
      <span class="n">node</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">rank</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="kt">int</span> <span class="n">j</span><span class="p">){</span><span class="c1">//数组
</span>  <span class="n">i</span><span class="o">=</span><span class="n">Find_Set</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="n">j</span><span class="o">=</span><span class="n">Find_Set</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">set</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
  <span class="k">else</span><span class="p">{</span>
	  <span class="k">if</span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>   
	  <span class="n">set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="代码">代码</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_PEOPLE 10001
#define MAX_RELATIONSHIP 100001 
</span>
<span class="kt">int</span> <span class="n">father</span><span class="p">[</span><span class="n">MAX_PEOPLE</span><span class="p">];</span><span class="c1">//存储每个元素的father
</span><span class="kt">int</span> <span class="n">relat</span><span class="p">[</span><span class="n">MAX_RELATIONSHIP</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span><span class="c1">//存储朋友关系
</span>
<span class="c1">//初始化集合
</span><span class="kt">void</span> <span class="n">Make_Set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="n">father</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//查找x所在集合并压缩路径
</span><span class="kt">int</span> <span class="n">Find_Set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>

	<span class="kt">int</span> <span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span><span class="c1">//寻找x所在集合的代表元
</span>		<span class="n">root</span> <span class="o">=</span> <span class="n">father</span><span class="p">[</span><span class="n">root</span><span class="p">];</span>
	
	<span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">root</span><span class="p">){</span><span class="c1">//将r集合中的所有结点直接指向r, 路径压缩
</span>		<span class="n">next</span> <span class="o">=</span> <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>

<span class="p">}</span>


<span class="kt">void</span> <span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">x_set</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">y_set</span><span class="p">;</span>

	<span class="n">x_set</span> <span class="o">=</span> <span class="n">Find_Set</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">y_set</span> <span class="o">=</span> <span class="n">Find_Set</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">x_set</span> <span class="o">==</span> <span class="n">y_set</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="k">else</span> 
		<span class="n">father</span><span class="p">[</span><span class="n">y_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_set</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span><span class="c1">//n个朋友圈用户
</span>	<span class="kt">int</span>	<span class="n">m</span><span class="p">;</span><span class="c1">//m对朋友关系
</span>	
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//初始化
</span>		<span class="n">Make_Set</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//合并关系
</span>		<span class="n">Union</span><span class="p">(</span><span class="n">relat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">relat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//代表元即一个朋友圈
</span>		<span class="k">if</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>




</code></pre></div></div>

</section>
<section align="right">
<br/>
<span>
	<a  href="/2017/08/27/YouCompleteMe/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2017/08/29/red-envelope/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://localhost:4000/2017/08/27/YouCompleteMe/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://localhost:4000/2017/08/29/red-envelope/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>