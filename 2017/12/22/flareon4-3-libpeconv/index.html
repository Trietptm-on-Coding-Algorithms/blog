<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>使用libPeConv来解决Flareon4题目3</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>使用libPeConv来解决Flareon4题目3</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2017-12-22">2017-12-22</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#crack" title="crack">crack</a>&nbsp;
  
  <a href="/categories/#translations" title="translations">translations</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#RE" title="RE">RE</a>&nbsp;
  
  <a href="/tags/#flareon" title="flareon">flareon</a>&nbsp;
  
</span>

</section>
<section class="post">
<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223494.htm">https://bbs.pediy.com/thread-223494.htm</a></p>
</blockquote>

<p>文章作者: hasherezade(@hasherezade)</p>

<p>原文链接: <a href="https://hshrzd.wordpress.com/2017/11/24/import-all-the-things-solving-flareon-challenge-3-with-libpeconv/">Import all the things! Solving FlareOn4 Challenge 3 with libPeConv</a></p>

<p>翻译前言: 虽然依旧是Flareon4第3题的分析,但是一道题的解决方法多种多样,这次给大家分享如何使用libPeConv来解决问题,又可以get到新姿势啦</p>

<p>libPeConv: 是作者hasherezade开发的用于加载和转换PE文件的库,github仓库地址是:<a href="https://github.com/hasherezade/libpeconv">libpeconv</a></p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<h2 id="总览">总览</h2>
<p>题目greek_to_me.exe是一个32位PE文件, 程序已经剔除了重定位信息. 我们以下就简称该程序为crackme
<img src="https://hshrzd.files.wordpress.com/2017/11/exe_info.png?w=640" alt="fig1" /></p>

<p>我们运行crackme, 只有一个空白的控制台程序, 并且没有从标准输入中读取任何数据, 所以我们可以推断程序是使用了一些其他方式来读取用户的password</p>

<p>我们使用IDA静态分析, crackme结构非常简洁并没有混淆过. 我们可以在代码开头看见程序创建了一个socket并等待着输入
socket监听着本地2222端口</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/make_socket.png" alt="fig2" /></p>

<p>在建立连接后, crackme从用户输入中取前4字节读入到缓冲区中:</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/recv_4.png" alt="fig3" /></p>

<p>读入4字节后, crackme开始处理输入并用来解码已加密的缓冲区数据</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/read_buf.png" alt="fig4" /></p>

<p>如果校验值是合法的, 也就是说加密数据被正确解密了, 那么crackme就会进一步执行下去.</p>

<p>我们可以看到, 输入中的数据只有1字节用于解码缓冲区数据, 所以我们可以轻易地穷举获得结果. 解码部分的代码也相当简单:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">size_t</span> <span class="n">encrypted_len</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">encrypted_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BYTE</span> <span class="n">val</span> <span class="o">=</span> <span class="n">encrypted_code</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">encrypted_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">unknown_byte</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>程序唯一的难点在于校验值 - 这个函数并没有那么好复现. 然而如果我们想要暴力穷举, 我们却又需要在穷举后计算校验值.</p>

<p>在我之前的解答中, 我复现了校验函数并表现良好, 但这并没有那么好玩. 我看过了一些其他的解决方式如<a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/Flare-On%202017/Challenge%20%233%20solution.pdf">使用Unicorn引擎模拟执行校验函数</a>
, 或<a href="https://blog.xorhex.com/flare-on-2017-challenge-3/">使用angr框架</a>, 或<a href="http://blog.attify.com/2017/10/10/flare-4-writeup-p1/">通过socket使用暴力穷举程序来获得原始程序</a>等等. 但是我们可以解决得更快速吗?我们来接着看…</p>
<h2 id="使用libpeconv">使用LibPeConv</h2>
<p>使用PeConv我们可以将原始格式的任何PE文件转换成虚拟内存格式并返回. 它也提供有一个可定制的PE加载器 - 用于加载任意PE文件到当前进程(就算它不是dll文件也没有重定位表, 这我会在之后的部分进行解释). 载入的PE文件随后可以在当前进程内运行. 我们也可以选择文件中的任意函数来使用 - 而我们只需要知道函数的RVA和API.</p>

<p>在这次, 我将会使用libpeconv来加载crackme并导入校验值的计算函数. 不用复制加密缓冲区数据到我们的代码中, 我们可以直接从载入的PE文件中读取它.</p>

<h2 id="收集需要的信息">收集需要的信息</h2>
<p>让我们再一次在IDA中查看crackme. 我们需要找到恰当的偏移量并明白我们需要导入的API函数.</p>

<p>首先我们计算校验值的函数起始于RVA 0x11E6处:</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/checksum_func.png" alt="fig5" /></p>

<p>函数读取2个参数: 指向缓冲区的指针和缓冲区大小
函数返回一个WORD类型数据.</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/return_word.png" alt="fig6" /></p>

<p>总结一下, 我们可以定义一个如下的函数原型:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WORD</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">decoded_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
</code></pre></div></div>
<p>还有一点需要注意, 就是这个函数是可独用的并且没有调用任何的导入库函数 - 这让我们导入这个校验值函数更加轻松(我们不必加载任何导入库模块或进行重定位).</p>

<p>另一个我们需要的信息就是加密的缓冲区. 缓冲区起始于RVA 0x107C并且长度为0x79(121)字节</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/enc_code.png" alt="fig7" /></p>

<p>信息搜集完毕!我们开始写代码.</p>
<h2 id="使用libpeconv解决crackme">使用libPeConv解决crackme</h2>
<p>当前版本的<code class="highlighter-rouge">libpeconv</code>允许两种方式来载入PE文件. 使用到的函数有<code class="highlighter-rouge">load_pe_module</code>和<code class="highlighter-rouge">load_pe_executable</code>. 第2个函数<code class="highlighter-rouge">load_pe_executable</code>是一个完整的加载器, 它加载指定PE文件到当前进程的可读可写可执行(RWX)内存中, 并自动应用重定位信息和载入其他依赖. 第1个函数<code class="highlighter-rouge">load_pe_module</code>则不能载入依赖并且我们需要提供更多的控制: 我们可能会加载PE文件到一个不可执行的内存中而是否进行重定位也是可选的. 更多详细信息(或者该API的重要更新)请看: <a href="https://github.com/hasherezade/libpeconv/blob/master/libpeconv/include/peconv/pe_loader.h">https://github.com/hasherezade/libpeconv/blob/master/libpeconv/include/peconv/pe_loader.h</a></p>

<p>正如我们所见, 我们想要导入的函数是独用的, 因此如果我们载入crackme的PE文件时没有加载导入表和重定位信息也不会造成什么危害(我们将在文章的下一部分看如何载入一个完整的PE文件). 我将使用到<code class="highlighter-rouge">load_pe_module</code>函数</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span><span class="n">load_pe_module</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span>
    <span class="n">v_size</span><span class="p">,</span> <span class="c1">// OUT: size of the loaded module
</span>    <span class="nb">true</span><span class="p">,</span>   <span class="c1">// executable
</span>    <span class="nb">false</span>   <span class="c1">// without relocations
</span><span class="p">);</span>
</code></pre></div></div>
<p>现在, 我们来导入函数, 首先我们来定义一个指针</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_checksum</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>
<p>计算在载入模块中该函数的绝对偏移</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DWORD</span><span class="p">(</span><span class="mh">0x11e6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
</code></pre></div></div>
<p>然后填充指针</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">calc_checksum</span> <span class="o">=</span> <span class="p">(</span> <span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">)</span> <span class="p">)</span> <span class="n">offset</span><span class="p">;</span>
</code></pre></div></div>
<p>现在我们就可以在我们的应用程序里该函数
但在那之前, 我们可以开始暴力穷举, 我们也同样也需要填充缓冲区指针.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g_Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mh">0x107C</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">);</span>
</code></pre></div></div>
<p>以下链接是我准备的完整穷举程序: <a href="https://gist.github.com/hasherezade/44b440675ccc065f111dd6a90ed34399#file-brutforcer_1-cpp">https://gist.github.com/hasherezade/44b440675ccc065f111dd6a90ed34399#file-brutforcer_1-cpp</a>
并且结果表现良好. 我们得到的结果跟crackme需要的一样.</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/brutforce_1.png" alt="fig8" /></p>

<p>但目前为止, 我们找到的值也只是解答过程的一部分, 并不是我们需要找到的flag. 我们从先前静态分析时可以知道, 如果给出正确值, 那么代码块就能解密并执行. 如果我们能看到解密后代码块到底是怎样的, 那岂不是很酷?</p>

<p>而且这也非常容易实现. 我们的PE文件载入进了当前进程可读可写可执行内存中 - 因此我们可以轻易地将解密后的数据替换回加密块代码, 我们只需要一个简单的<code class="highlighter-rouge">memcpy</code>就能完成这个工作</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">g_Buffer</span><span class="p">,</span> <span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>
</code></pre></div></div>
<p>随后, <code class="highlighter-rouge">libPeConv</code>可以帮助我们将PE文件转换回原始格式以便用IDA打开. 我们可以用<code class="highlighter-rouge">libPeConv</code>的<code class="highlighter-rouge">pe_virtual_to_raw</code>来完成.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">out_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">BYTE</span><span class="o">*</span> <span class="n">unmapped_module</span> <span class="o">=</span> <span class="n">pe_virtual_to_raw</span><span class="p">(</span>
    <span class="n">loaded_pe</span><span class="p">,</span> <span class="c1">//pointer to the module
</span>    <span class="n">v_size</span><span class="p">,</span> <span class="c1">//virtual size
</span>    <span class="n">module_base</span><span class="p">,</span> <span class="c1">//in this case we need here
</span>                 <span class="c1">//the original module base, because
</span>                 <span class="c1">//the loaded PE was not relocated
</span>    <span class="n">out_size</span> <span class="c1">//OUT: raw size of the unmapped PE
</span><span class="p">);</span>
</code></pre></div></div>
<p>并且以下是完整的解答: <a href="https://gist.github.com/hasherezade/36a4a531840cfe1fd5997bc7c5f6be4d#file-brutforcer_2-cpp">brutforcer_2.cpp</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="cp">#include "peconv.h"
</span>
<span class="n">BYTE</span> <span class="o">*</span><span class="n">g_Buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">g_BufferLen</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span>

<span class="n">BYTE</span> <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">g_BufferLen</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_checksum</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">decoded_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">test_val</span><span class="p">(</span><span class="n">BYTE</span> <span class="n">xor_val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_BufferLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BYTE</span> <span class="n">val</span> <span class="o">=</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xor_val</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WORD</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mh">0xfb5e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BYTE</span> <span class="nf">brutforce</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BYTE</span> <span class="n">xor_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">xor_val</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_val</span><span class="p">(</span><span class="n">xor_val</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">xor_val</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//---
</span>
<span class="n">bool</span> <span class="nf">dump_to_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">out_path</span><span class="p">,</span> <span class="n">BYTE</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">f1</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="cp">#ifdef _WIN64
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Compile the loader as 32bit!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="kt">char</span> <span class="n">default_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"greek_to_me.exe"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">default_path</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">v_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">load_pe_module</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> 
                                     <span class="n">v_size</span><span class="p">,</span> 
                                     <span class="nb">true</span><span class="p">,</span> <span class="c1">// load as executable?
</span>                                     <span class="nb">false</span> <span class="c1">// apply relocations ?
</span>                                    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loaded_pe</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Loading module failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mh">0x107C</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">);</span>

    <span class="n">ULONGLONG</span> <span class="n">func_offset</span> <span class="o">=</span> <span class="mh">0x11e6</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
    <span class="n">calc_checksum</span> <span class="o">=</span>  <span class="p">(</span> <span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">)</span> <span class="p">)</span> <span class="n">func_offset</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="n">found</span> <span class="o">=</span> <span class="n">brutforce</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Found: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">g_Buffer</span><span class="p">,</span> <span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>

    <span class="kt">size_t</span> <span class="n">out_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="cm">/*in this case we need to use the original module base, because 
    * the loaded PE was not relocated */</span>
    <span class="n">ULONGLONG</span> <span class="n">module_base</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">get_image_base</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">);</span> 
    
    <span class="n">BYTE</span><span class="o">*</span> <span class="n">unmapped_module</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">pe_virtual_to_raw</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">,</span> 
                                              <span class="n">v_size</span><span class="p">,</span> 
                                              <span class="n">module_base</span><span class="p">,</span> <span class="c1">//the original module base
</span>                                              <span class="n">out_size</span> <span class="c1">// OUT: size of the unmapped (raw) PE
</span>                                             <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unmapped_module</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">out_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"modified_pe.exe"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dump_to_file</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="n">unmapped_module</span><span class="p">,</span> <span class="n">out_size</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Module dumped to: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">out_path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">peconv</span><span class="o">::</span><span class="n">free_pe_buffer</span><span class="p">(</span><span class="n">unmapped_module</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">peconv</span><span class="o">::</span><span class="n">free_pe_buffer</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
    
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>与初始的文件相比, 我们可以看到dump出来的可执行文件的缓冲区已经覆写过了.</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/filled_buf.png?w=640" alt="fig9" /></p>

<p>所以我们在IDA里看下修改的可执行文件</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/flag_revealed.png" alt="fig10" /></p>

<p>搞定!在<code class="highlighter-rouge">0x000F107C</code>处显示出我们的flag: <code class="highlighter-rouge">et_tu_brute_force@flare-on.com</code></p>

<h2 id="福利---载入和运行剔除了重定位信息的pe文件">福利 - 载入和运行剔除了重定位信息的PE文件</h2>
<p>OK, 你可能会说, 这很简单呀, 导入的函数是独立的, 所以我们可以从原来文件中抽出来, 并不需要使用任何加载器. 但是如果函数调用了一些其他的模块内的其他函数或是导入函数呢? 我们之前的方法还能生效吗? 不止如此, 剔除掉重定位信息的PE文件又能行吗?</p>

<p>为了回答这些问题, 我准备了其他的测试用例. 与之前载一个函数相反, 我将会在穷举程序中载入并执行完整的crackme文件.</p>

<p>首先我们将会修改一些东西. 这次不使用<code class="highlighter-rouge">load_pe_module</code>, 我使用<code class="highlighter-rouge">load_pe_executable</code>来加载完整的可执行文件和依赖.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span><span class="n">load_pe_executable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
</code></pre></div></div>

<p>这个函数将自动地识别出这个PE文件没有重定位信息, 并且载入到初始模块基址. 注意, 分配的指定基址处的内存可能不总会生效, 因此有时需要运行多次使得程序正确地执行. 你也必须确定加载器的模块基址跟payload需要的模块基址不相冲突(如果加载器的基址是随机的话就很好).</p>

<p>一旦PE文件加载完毕, 我们就需要获取它的入口地址, 并且随后我们就可以像其他函数一样调用它:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Deploy the payload:
// read the Entry Point from the headers:
</span><span class="n">ULONGLONG</span> <span class="n">ep_va</span> <span class="o">=</span> <span class="n">get_entry_point_rva</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">)</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
 
<span class="c1">//make pointer to the entry function:
</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">loaded_pe_entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="n">ep_va</span><span class="p">;</span>
 
<span class="c1">//call the loaded PE's ep:
</span><span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">loaded_pe_entry</span><span class="p">();</span>
</code></pre></div></div>

<p>但还要注意这与payload的具体实现细节有关, 一旦你转向执行入口点代码, 它可能在完成工作后直接退出而不会返回到你的代码中.</p>

<p>我打算修改穷举程序的代码, 使得在找到正确值之后crackme会继续运行. 以下是代码的完整版本: <a href="https://gist.github.com/hasherezade/9d5186b27c730d01849ac1787b3d699b#file-brutforcer_3-cpp">brutforcer_3.cpp</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="cp">#include "peconv.h"
</span>
<span class="n">BYTE</span> <span class="o">*</span><span class="n">g_Buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">g_BufferLen</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span>

<span class="n">BYTE</span> <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">g_BufferLen</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_checksum</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">decoded_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">test_val</span><span class="p">(</span><span class="n">BYTE</span> <span class="n">xor_val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_BufferLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BYTE</span> <span class="n">val</span> <span class="o">=</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xor_val</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WORD</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mh">0xfb5e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BYTE</span> <span class="nf">brutforce</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BYTE</span> <span class="n">xor_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">xor_val</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_val</span><span class="p">(</span><span class="n">xor_val</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">xor_val</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//---
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="cp">#ifdef _WIN64
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Compile the loader as 32bit!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="kt">char</span> <span class="n">default_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"greek_to_me.exe"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">default_path</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">v_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">load_pe_executable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loaded_pe</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Loading module failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mh">0x107C</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">);</span>

    <span class="n">ULONGLONG</span> <span class="n">func_offset</span> <span class="o">=</span> <span class="mh">0x11e6</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
    <span class="n">calc_checksum</span> <span class="o">=</span>  <span class="p">(</span> <span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">)</span> <span class="p">)</span> <span class="n">func_offset</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="n">found</span> <span class="o">=</span> <span class="n">brutforce</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Found: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>

    <span class="c1">// Deploy the payload!
</span>    <span class="c1">// read the Entry Point from the headers:
</span>    <span class="n">ULONGLONG</span> <span class="n">ep_va</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">get_entry_point_rva</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>

    <span class="c1">//make pointer to the entry function:
</span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">loaded_pe_entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="n">ep_va</span><span class="p">;</span>

    <span class="c1">//call the loaded PE's ep:
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Calling the Entry Point of the loaded module:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">loaded_pe_entry</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Finished: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>为了确保一切运行正常(尽管运行payload确实建立了socket并给出跟之前载入独立函数时相同的回应), 我写了一个简短的python脚本来交流和显示回应结果: <a href="https://gist.github.com/hasherezade/328210a57464360e23e125929b62b301#file-test-py">test.py</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"Send to the Crackme"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--key'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">"key"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">"0xa2"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"The value to be sent"</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">my_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">%</span> <span class="mi">255</span>
    <span class="k">print</span> <span class="s">'[+] Checking the key: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">my_key</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span>  <span class="nb">chr</span><span class="p">(</span><span class="n">my_key</span><span class="p">)</span> <span class="o">+</span> <span class="s">'012'</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">'127.0.0.1'</span><span class="p">,</span> <span class="mi">2222</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"[+] Response: "</span> <span class="o">+</span> <span class="n">result</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"Could not connect to the socket. Is the crackme running?"</span>
    
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div></div>

<p>现在, 你可以在YouTube观看整个过程的操作: <a href="https://www.youtube.com/watch?v=x3T3qFEDkF0">https://www.youtube.com/watch?v=x3T3qFEDkF0</a></p>

<p>以上就是我今天所准备的内容, 我希望大家都能有所收获! 该库现在正处于快速开发阶段, 所以许多东西会进行重构并优化, 敬请期待.</p>

<h2 id="附录">附录</h2>
<p>其他解决该问题的方法如下:</p>
<ul>
  <li><a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/Flare-On%202017/Challenge%20%233%20solution.pdf">emulating the checksum function by the Unicorn engine</a></li>
  <li><a href="https://blog.xorhex.com/flare-on-2017-challenge-3/">using angr framework</a></li>
  <li><a href="https://parsiya.net/blog/2017-11-15-winappdbg---part-4---bruteforcing-flareon-2017---challenge-3/">using WinAppDbg</a></li>
  <li><a href="http://blog.attify.com/2017/10/10/flare-4-writeup-p1/">a brutforcer that talks to the original program via socket</a></li>
</ul>


</section>
<section align="right">
<br/>
<span>
	<a  href="/2017/12/21/flareon4-3/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2017/12/23/flareon4-3-angr/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.vancir.com/2017/12/21/flareon4-3/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.vancir.com/2017/12/23/flareon4-3-angr/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>