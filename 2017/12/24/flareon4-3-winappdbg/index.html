<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>使用WinAppDbg解决Flareon第3题</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>使用WinAppDbg解决Flareon第3题</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2017-12-24">2017-12-24</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#crack" title="crack">crack</a>&nbsp;
  
  <a href="/categories/#translations" title="translations">translations</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#RE" title="RE">RE</a>&nbsp;
  
  <a href="/tags/#flareon" title="flareon">flareon</a>&nbsp;
  
</span>

</section>
<section class="post">
<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223525.htm">https://bbs.pediy.com/thread-223525.htm</a></p>
</blockquote>

<p>文章作者: Parsia’s Den</p>

<p>博客地址: <a href="https://parsiya.net/">https://parsiya.net/</a></p>

<p>原文链接: <a href="https://parsiya.net/blog/2017-11-15-winappdbg---part-4---bruteforcing-flareon-2017---challenge-3/#bruteforcing-in-action">WinAppDbg - Part 4 - Bruteforcing FlareOn 2017 - Challenge 3</a></p>

<p>翻译前言: 这是解决Flareon4第3题的第4种方法, 也是这个系列翻译的完结篇. 作者用的WinAppDbg跟ODScript有类似的感觉, 虽然不及之前2篇让人耳目一新, 但这是作者对于WinAppDbg写的简易教程的第4篇, 如果感兴趣可以点击原文链接从其它3篇WinAppDbg的教程开始阅读.</p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<p>如果朋友想看我之前翻译的用其他3种全新的方法解决该题的文章, 可以点击以下链接:</p>

<ol>
  <li><a href="http://vancir.com/2017/12/21/flareon4-3/">Flareon challenge 4 第3题</a></li>
  <li><a href="http://vancir.com/2017/12/22/flareon4-3-libpeconv/">使用libPeConv来解决Flareon4题目3</a></li>
  <li><a href="http://vancir.com/2017/12/23/flareon4-3-angr/">使用Angr解决Flareon4题目3</a></li>
</ol>

<h2 id="侦查">侦查</h2>

<p>首先我们要运行<code class="highlighter-rouge">strings</code>程序分析文件. 在Windows我喜欢从以下两种方式获取<code class="highlighter-rouge">strings</code></p>

<ul>
  <li>从Cygwin的binutils包获取strings</li>
  <li>从微软Sysinternals套件获取strings
运行<code class="highlighter-rouge">strings</code>我们获得下图:</li>
  <li><code class="highlighter-rouge">-nobanner</code>: 不要显示启动时的标语和版权信息</li>
  <li><code class="highlighter-rouge">-o</code>: 打印字符串偏移(如果想要找寻字符串地址这会很有帮助)</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; .\SysinternalsSuite\strings.exe -o -nobanner .\3-GreektoMe\greek_to_me.exe
0077:!This program cannot be run in DOS mode.
0176:Rich
0432:.text
0472:.rdata
...
1584:Nope, that's not it.
1608:Congratulations! But wait, where's my flag?
1652:127.0.0.1
1752:WS2_32.dll
</code></pre></div></div>

<p><code class="highlighter-rouge">ws2_32.dll</code>是Windows套接字库, 故程序中有着网络活动.</p>

<p>说个有趣的题外话, 当我在搜索这个DLL时我发现以下这个链接:</p>

<ul>
  <li><a href="https://nakedsecurity.sophos.com/2009/10/12/windows-ws232dll-file-safe/">Is Your Windows “ws2_32.dll” File Safe?</a></li>
</ul>

<p>回归正题, <code class="highlighter-rouge">127.0.0.1</code>表明程序有网络活动, 表明它尝试连接或监听本地端口.</p>

<p>为了进一步探明, 我们运行<code class="highlighter-rouge">procmon</code>或<code class="highlighter-rouge">wireshark</code></p>

<ul>
  <li>Procmon过滤条件:
    <ul>
      <li>进程名是<code class="highlighter-rouge">greek_to_me.exe</code></li>
      <li>操作是<code class="highlighter-rouge">TCP/UDP</code>连接</li>
    </ul>
  </li>
  <li>Wireshark:
    <ul>
      <li>使用npcap抓取Windows回环流量</li>
      <li><a href="https://wiki.wireshark.org/CaptureSetup/Loopback">https://wiki.wireshark.org/CaptureSetup/Loopback</a></li>
    </ul>
  </li>
</ul>

<p>什么都没有显示. 故程序是在进行本地监听.</p>

<p>运行程序并以管理员身份运行命令行, 输入<code class="highlighter-rouge">netstat -anb</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> TCP    127.0.0.1:2222         0.0.0.0:0              LISTENING       5816
[greek_to_me.exe]
</code></pre></div></div>

<p>程序正在监听本地端口2222</p>

<h2 id="简短分析">简短分析</h2>

<p>程序监听端口2222, 当接收到数据, 它使用了我们输入的第1个字节(也就只用了第1个字节). 如下所示:</p>

<pre><code class="language-asm">.text:00401029 loc_401029:      ; CODE XREF: sub_401008+1A
.text:00401029          mov     ecx, offset loc_40107C
.text:0040102E          add     ecx, 79h
.text:00401031          mov     eax, offset loc_40107C
.text:00401036          mov     dl, [ebp+buf]   ; first byte of input moved to dl
</code></pre>

<p>现在dl指向着我们发送给socket的第1个字节</p>

<pre><code class="language-asm">.text:00401039 loc_401039:      ; CODE XREF: sub_401008+3D
.text:00401039          mov     bl, [eax]   ; bl = grab a byte from blob
.text:0040103B          xor     bl, dl      ; bl = blob_byte xor our_first_byte
.text:0040103D          add     bl, 22h     ; bl += 0x22
.text:00401040          mov     [eax], bl   ; *eax = bl
.text:00401042          inc     eax         ; eax++ (next char)
.text:00401043          cmp     eax, ecx    ; ecx is the address of the second section
.text:00401045          jl      short loc_401039 ; check if we have reached the next section
</code></pre>

<p>它抓取了一些数据(准确说是<code class="highlighter-rouge">0x79</code>或121字节), 使用我们的第1个字节跟其异或随后加上<code class="highlighter-rouge">0x22</code>. 取出的数据则是位于<code class="highlighter-rouge">loc40107C</code>偏移处的十六进制块.</p>

<pre><code class="language-asm">33 E1 C4 99 11 06 81 16 F0 32 9F C4 91 17 06 81
14 F0 06 81 15 F1 C4 91 1A 06 81 1B E2 06 81 18
F2 06 81 19 F1 06 81 1E F0 C4 99 1F C4 91 1C 06
81 1D E6 06 81 62 EF 06 81 63 F2 06 81 60 E3 C4
99 61 06 81 66 BC 06 81 67 E6 06 81 64 E8 06 81
65 9D 06 81 6A F2 C4 99 6B 06 81 68 A9 06 81 69
EF 06 81 6E EE 06 81 6F AE 06 81 6C E3 06 81 6D
EF 06 81 72 E9 06 81 73 7C
</code></pre>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/01-crypto.png" alt="xor_add.png" /></p>

<p>随后修改的数据块(在异或和加法操作后)传递给<code class="highlighter-rouge">sub_4011E6</code>并继续处理:</p>

<pre><code class="language-asm">.text:00401047          mov     eax, offset loc_40107C  ; eax = *modified_blob
.text:0040104C          mov     [ebp+var_C], eax        ; varC = eax
.text:0040104F          push    79h                     ; length of modified_blob
.text:00401051          push    [ebp+var_C]
.text:00401054          call    sub_4011E6              ; sub_4011E6(*modified_blob, 0x79)
.text:00401059          pop     ecx
.text:0040105A          pop     ecx
.text:0040105B          movzx   eax, ax
.text:0040105E          cmp     eax, 0FB5Eh ; compare return value with 0xFB5E

.text:00401063          jz      short loc_40107C
.text:00401065          push    0               ; flags
.text:00401067          push    14h             ; len
.text:00401069          push    offset buf      ; "Nope, that's not it."
.text:0040106E          push    [ebp+s]         ; s
.text:00401071          call    ds:send
.text:00401077          jmp     loc_401107
</code></pre>

<p><code class="highlighter-rouge">sub_4011E6</code>的返回值跟<code class="highlighter-rouge">0xFB5E</code>进行比较, 如果不匹配, <code class="highlighter-rouge">jz</code>跳转将不会实现并继续执行, 程序也会传回来<code class="highlighter-rouge">Nope, that's not it.</code>.</p>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/02-result-comparison.png" alt="nope.png" /></p>

<p>现在就变得越发有趣了. 如果结果匹配, 它就会跳转到我们刚刚修改过的数据块并试图将其作为代码执行. 如果程序没有崩溃且运行到结尾, 那么它就会发送回来<code class="highlighter-rouge">Congratulations!</code>.</p>

<p>换句话说, 我们输入的第1个字节就是用来将那数据块转换成正确的汇编操作码.</p>

<p>现在我们应该用另外一种方式来解决该题. 我想所有人都会用打开套接字, 发送256个可能字节并查看结果的方法来解决它. 这确实可以解决这个问题.</p>

<h2 id="使用winappdbg暴力穷举">使用WinAppDbg暴力穷举</h2>

<p>我使用另外一种方法解决. 复现这个方法我们需要了解一点点WinAppDbg的知识.</p>

<h2 id="winappdbg设置断点">WinAppDbg设置断点</h2>

<p>WinAppDng允许我们在任意地址设置断点:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">debug</span><span class="o">.</span><span class="n">break_at</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">action_callback</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">action_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="c"># do something</span>
</code></pre></div></div>

<p>当断点触发, <code class="highlighter-rouge">action_callback</code>函数就会被调用</p>

<p>更多信息请看:</p>

<ul>
  <li><a href="https://winappdbg.readthedocs.io/en/latest/Debugging.html?highlight=break_at#example-11-setting-a-breakpoint">Documentation - Example #11: setting a breakpoint</a></li>
  <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/breakpoint.py#L3905">breakpoint.py source code</a></li>
</ul>

<h2 id="获取和设置内存">获取和设置内存</h2>

<p>WinAppDbg运行我们存储/恢复内存和上下文</p>

<ul>
  <li>获取内存: <code class="highlighter-rouge">memory = process.take_memory_snapshot()</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3261">take_memory_snapshot 源码</a></li>
    </ul>
  </li>
  <li>设置内存: <code class="highlighter-rouge">process.restore_memory_snapshot(memory, bSkipMappedFiles=True)</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3301">restore_memory_snapshot 源码</a></li>
      <li>通常来说, 请总是保持<code class="highlighter-rouge">bSkipMappedFiles</code>为<code class="highlighter-rouge">True</code>, 否则你会得到一个内存地址错误
        <ul>
          <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3317">Explanation of bSkipMappedFiles in source</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="获取和设置上下文">获取和设置上下文</h2>

<p>上下文包含寄存器和各种标志值, 是逐线程(而非逐进程的)</p>

<ul>
  <li>获取上下文: <code class="highlighter-rouge">context = thread.get_context()</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/thread.py#L469">get_context 源码</a></li>
      <li>处理上下文中的寄存器:
        <ul>
          <li><code class="highlighter-rouge">context["Edx"] = 0x1234</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>设置上下文: <code class="highlighter-rouge">thread.set_context(context)</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/thread.py#L570">set_context 源码</a></li>
    </ul>
  </li>
</ul>

<p>注意: 在设置完上下文后, 我们需要手动修改指令指针指向一个开始执行的具体位置. 比如说如果我们获取了上下文, 改变<code class="highlighter-rouge">Eip</code>指向一个地址, 实际的指令指针并不会变化. 我们在设置完上下文后, 需要使用<code class="highlighter-rouge">thread.set_pc(address)</code>手动将指令指针改成你需要的地址.</p>

<p>在进行内存和上下文的操作时, 请确保事先暂停了程序/线程, 在操作完成后再恢复.</p>

<h2 id="作战计划">作战计划</h2>

<p>现在我们有了建筑模块, 我们需要制定一个作战计划. 非常简单明了.</p>

<ol>
  <li>运行程序</li>
  <li>在<code class="highlighter-rouge">0x401036</code>和<code class="highlighter-rouge">0x40105B</code>设置断点</li>
  <li>打开socket并发送任何可能的字节</li>
  <li>在<code class="highlighter-rouge">0x401036</code>的断点
    <ul>
      <li>如果是第1次触发断点:
        <ul>
          <li>保存内存,上下文和<code class="highlighter-rouge">0x40107C</code>的数据块</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">context["Edx"] = key</code> - 交换key值</li>
      <li>key++</li>
      <li>绕过key的赋值指令并使用<code class="highlighter-rouge">thread.set_pc(0x401039)</code>手动跳转到<code class="highlighter-rouge">0x401039</code></li>
    </ul>
  </li>
  <li>在<code class="highlighter-rouge">0x40105B</code>的断点:
    <ul>
      <li>如果函数返回值是<code class="highlighter-rouge">0xFB5E</code>, 则打印key值</li>
      <li>否则:
        <ul>
          <li>复原内存, 上下文和<code class="highlighter-rouge">0x40107C</code>处的数据块(数据块已经被修改过了, 因此这里需要复原成原来的字节)</li>
          <li>使用<code class="highlighter-rouge">thread.set_pc(0x401036)</code>返回到<code class="highlighter-rouge">0x401036</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/03-bruteforcer-1.png" alt="plan.png" /></p>

<p>改变<code class="highlighter-rouge">buf</code>中第1个字节会比<code class="highlighter-rouge">edx</code>中更简单些, 而且能够避免途中标签2对应的跳转.</p>

<h2 id="开始暴力穷举">开始暴力穷举</h2>

<p>我们使用的脚本是<a href="https://github.com/parsiya/Parsia-Clone/blob/master/code/winappdbg/19-GreekToMe.py"><code class="highlighter-rouge">19-GreekToMe.py</code></a>, 你需要将<code class="highlighter-rouge">greek_to_me.exe</code>放在脚本的同一目录下, 该程序可以在附件里下载.</p>

<p>脚本运行非常快,因为我们的穷举空间仅仅只有1字节(0x00到0xFF)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python 19-GreekToMe.py
[21:23:48.0743] Starting simple_debugger
[21:23:48.0753] Started simple_debugger. Sleeping for 2 seconds.
[21:23:50.0756] Starting send_me.
[21:23:50.0875] Socket connected
[21:23:50.0875] Sent 0
[21:23:53.0490]
-------------------------------------------------------------------------------
Key: 0xa2
Eax: 0000FB5E
[21:23:54.0901] Reached 0x100
</code></pre></div></div>

<h2 id="flag">Flag</h2>

<p>重新在调试器中运行程序, 在”Congratulations!”处设下断点然后重新发送<code class="highlighter-rouge">0xA2</code>, 数据块正确解密, 我们也获得了flag</p>

<p><em>flag: et_tu_brute_force@flare-on.com</em></p>

</section>
<section align="right">
<br/>
<span>
	<a  href="/2017/12/23/flareon4-3-angr/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2018/01/21/pyc-structure/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.vancir.com/2017/12/23/flareon4-3-angr/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.vancir.com/2018/01/21/pyc-structure/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>