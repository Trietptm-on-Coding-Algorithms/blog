<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Vancir</title>
    <link href="http://www.vancir.com/feed/" rel="self" />
    <link href="http://www.vancir.com" />
    <lastBuildDate>2018-06-28T13:59:10+08:00</lastBuildDate>
    <webMaster>vancirprince@gmail.com</webMaster>
    
    <item>
      <title>UNVEIL 一种大规模检测勒索软件的自动化方法</title>
      <link href="http://www.vancir.com/2018/06/27/unveil-detect-ransomware/"/>
      <pubDate>2018-06-27T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/06/27/unveil-detect-ransomware</guid>
      <content:encoded><![CDATA[<h1 id="摘要">摘要</h1>

<p>尽管勒索软件早已不是什么新奇的概念(这种攻击甚至可以追溯到20世纪80年代), 但这种类型的恶意软件最近开始复苏变得流行起来. 事实上, 近几年以来已经报道了数起备受瞩目的勒索软件攻击, 例如对索尼的大规模攻击导致了索尼不得不推迟发布电影«刺杀金正恩».</p>

<p>勒索软件通常会锁定受害者桌面, 使用户无法访问系统, 或是加密, 覆写, 删除用户文件, 以此来勒索钱财. 然而, 虽然现今已经提出了许多通用的恶意软件检测系统, 但没有一个检测系统有尝试专门解决勒索软件的检测问题.</p>

<p>在本论文中, 我们提出了一种名为UNVEIL的新型动态分析系统, 专门用于检测勒索软件. 而分析的关键依据就是, 勒索软件要想成功实行攻击, 就必定会去篡改用户的文件或桌面. UNVEIL会生成一个伪造的用户环境, 并检测勒索软件与用户数据的交互时间, 同时还会跟踪系统桌面上发生的可能是由勒索软件行为造成的变化. 我们的评估结果显示, UNVEIL 显著地提高了现有技术水平, 并能够检测出以往反病毒公司未能检测出的在野勒索软件.</p>

<h1 id="1-绪论">1 绪论</h1>

<p>恶意软件目前仍是互联网上最重要的安全威胁之一. 近期, 一种称为勒索软件的特定恶意软件在网络犯罪中变得非常流行. 尽管勒索软件这个概念并不新奇 - 这种攻击早在20世纪80年代末就已经发生过 - 但勒索软件的成功也使得勒索软件近几年衍生出了越来越多的家系[7,20,21,44,46]. 例如, CryptoWall 3.0作为一个高利润的勒索软件家族在世界各地成为头条新闻, 估计造成了3.25亿美元的损失[45], 又如索尼遭受勒索软件攻击事件[27]引发了媒体的大量关注, 美国官方甚至宣称是朝鲜发起了这次攻击.</p>

<p>勒索软件有多种方式运作, 简单的可以锁定受感染计算机的桌面, 复杂一些可以对受害者所有文件进行加密. 与传统恶意软件相比, 勒索软件表现出了一定的行为差异. 例如, 传统恶意软件强调隐蔽性, 以便于在不受怀疑的情况下收集银行证书信息或用户按键记录. 而与之相反, 勒索软件完全不在意隐蔽性, 它攻击的先手就是公开地告知用户你已经被感染了.</p>

<p>现今, 基于行为的恶意软件检测一个重要推动因素就是动态分析技术. 这些系统在一个受控环境中运行捕获的恶意软件样本并记录其行为(例如系统调用, API调用和网络流量). 不幸的是, 专注于行为的恶意软件检测系统(例如, 用于键盘记录的可疑操作系统功能)可能无法检测勒索软件, 因为这类恶意代码和那些使用加密或压缩的良性应用程序活动有相似之处. 此外, 这些检测系统目前还不适合检测勒索软件的具体行为, 从反病毒扫描器对勒索软件家族的错误分类就可以证明这一点[10,39].</p>

<p>在本论文中, 我们提出了一种新的动态分析系统, 旨在分析和检测勒索软件攻击并对其行为进行建模. 在我们的方法中, 系统会创建一个伪造的执行环境, 并监控勒索软件与环境的交互. 密切地监控勒索软件与文件系统的进程交互可以使检测系统精确地表征加密勒索软件的行为.</p>

<p>与此同时, 系统会跟踪程序对计算机桌面的可疑修改, 以表明这是勒索软件样的行为. 我们关键依据就在于勒索软件要想成功, 就必须访问和篡改受害者的文件或桌面. 我们的自动化方法简称为UNVEIL, 该方法允许系统大规模检测许多恶意软件样本, 并可靠地检测并标记那些有着类似勒索软件行为的恶意软件样本. 此外, 该检测系统还能提供对勒索软件运行方式的见解, 并自动区分不同类别的勒索软件.</p>

<p>我们在Windows流行的开源恶意软件分析框架–Cuckoo沙盒[13]上实现了UNVEIL的原型. 系统使用定制的Windows内核驱动来实现, 该驱动可以为文件系统提供监视功能. 此外, 我们还添加了在沙盒外运行的组件, 以监视目标计算机系统的用户界面.</p>

<p>我们在长期的研究中分析了近期在野的148,233个恶意软件样本. 我们的大规模实验结果表明, UNVEIL能够在真实世界的实时数据反馈中正确检测多个家族中的13,637个勒索软件样本. 我们的评估结果还表明, 目前的恶意软件分析系统可能还没有一个准确的行为模型来检测不同类别的勒索软件攻击。</p>

<p>例如, 系统能够正确检测出7,572个还未被传统AV检测出的勒索软件样本, 这些样本都属于现代文件锁定类型的勒索软件家族.  UNVEIL还能够发现一种尚未被任何安全公司报告过的新型勒索软件. 这个勒索软件在一些著名的反恶意软件公司提供的现代沙盒中也没有显示出任何恶意行为，而在UNVEIL分析时则显示出了大量的文件加密活动。</p>

<p>从我们方法的高检测率可以表明, UNVEIL可以填充当前恶意软件分析系统快速识别新型在野勒索软件的空白. 只需在分析环境中附加到文件系统驱动程序, UNVEIL就可以轻松地部署在任何恶意软件分析系统上.</p>

<p>总而言之, 本论文做出了如下贡献:</p>

<ul>
  <li>
    <p>我们提供了一种新型技术用于检测针对受害者计算机上存储文件进行锁定的勒索软件(也称为文件锁定器). 该检测技术基于监控系统范围的文件系统访问信息, 并结合部署的仿真用户环境来判定勒索软件。</p>
  </li>
  <li>我们进行了大规模检测, 评估结果表明我们的方法确实可以有效地检测勒索软件</li>
  <li>我们自动检测了近期的148,223个恶意软件样本数据集并验证其中确有13,637个勒索软件. 另外, 我们还发现了一个尚未被报告的勒索软件样本. 评估结果表明, 我们的技术在实践过程中表现良好(达到了96.3%的真正率[TP]和0的假正率[FPs]), 并可用于自动识别提交给分析检测系统的勒索软件样本.</li>
</ul>

<p>论文的其他部分结构如下. 在第2节中, 我们会简要介绍背景信息并解释不同类别的勒索软件攻击. 在第3节中, 我们描述了UNVEIL的架构并解释我们用于检测多类勒索软件攻击的方法. 在第4节中, 我们提供了有关动态分析环境的更多细节. 第5节会展示我们的评估结果. 第6节将会讨论该方法的局限性. 第7节这介绍相关工作, 最后在第8节总结本篇论文.</p>

<h1 id="2-背景介绍">2 背景介绍</h1>

<p>如图其他类型的恶意软件一般, 勒索软件使用了许多策略以躲避检测, 传播并攻击用户. 例如, 它可以执行多重感染或进程注入, 将用户信息泄露给第三方, 对文件加密以及与C&amp;C服务器建立安全通信. 我们的检测方法中有假定勒索软件样本可以并会使用其他恶意软件样本可能使用的所有技术.</p>

<p>另外, 我们的系统也假定一次成功的勒索软件攻击会进行一项或多项以下活动.</p>

<h2 id="显示持久桌面消息">显示持久桌面消息</h2>

<p>勒索软件成功感染后, 恶意程序通常会给受害者显示一条信息. 这条勒索消息会通知用户他的电脑已经被锁定, 并提供如何付款以恢复访问权限的说明. 勒索消息可以有很多种方法生成, 比较流行的就是调用专门的API函数(例如, CreateDesktop())来创建一个新桌面, 并将其配置为受害者在受损系统之外的默认界面. 恶意软件作者也可以使用HTML或创建其他持久化窗口来显示勒索消息.  而显示持久桌面消息则是许多勒索软件攻击中的常见操作。</p>

<h2 id="肆意加密或删除用户私人文件">肆意加密或删除用户私人文件</h2>

<p>加密式勒索软件攻击会列出并肆意加密其发现的任何私人文件, 通过扣留解密秘钥来限制访问. 加密秘钥可以由受害者主机上的恶意软件本地生成, 也可以在C&amp;C服务器上远端生成后交付给受感染主机. 攻击者可以自己编写破坏函数或Windows API函数来删除用户的原始文件, 也可以使用加密后的文件覆写, 或通过Windows安全删除API进行文件删除.</p>

<h2 id="基于某些属性选择性地加密或删除用户私人文件">基于某些属性选择性地加密或删除用户私人文件</h2>

<p>为了躲避检测, 大部分的勒索软件样本都会选择性地加密用户私人文件. 最简单的方式就是, 勒索软件样本根据文件访问日期列出相关文件. 更复杂的情形就是, 恶意可以打开应用程序(例如, word.exe), 列出应用程序最近访问的文件. 勒索软件样本可以向任意Windows应用程序注入恶意代码来获得这类信息(例如, 直接读取进程内存).</p>

<p>在本次工作中, 测试的样本已经危害系统, 并能够在用户的文件或桌面上进行任意与勒索相关的操作, 我们在这种情景下展开的研究.</p>

<h1 id="3-unveil-的功能设计">3 UNVEIL 的功能设计</h1>

<p>本节将会讲述我们用于检测多类勒索软件攻击的技术. 读者可以参阅第4节了解原型的实现细节.</p>

<h2 id="31-检测文件加锁器file-lockers">3.1 检测文件加锁器File Lockers</h2>

<p>我们首先阐述为什么我们的系统需要在每个恶意软件运行时创建一个独特的人造用户环境. 随后我们会展示文件系统活动监视器的设计并解释UNVEIL如何使用文件系统监视器的输出来检测勒索软件.</p>

<h2 id="311-生成人造用户环境">3.1.1 生成人造用户环境</h2>

<p>在真实环境中, 保护恶意软件分析环境免受指纹分析技术影响这并不重要. 复杂恶意软件的作者会利用分析系统内的静态特征, 并启动基于侦查的攻击[31]以对公共或私有恶意软件分析系统进行指纹识别. 分析系统的静态环境可视为恶意软件分析系统的阿喀琉斯之踵. 其中一个可以对恶意软件分析系统的有效性产生显著影响的静态特征就是, 那些可以有效用于指纹识别分析环境的用户数据. 也就是说, 即使是在一个比如虚拟化检测等传统技巧都不可行的裸机环境中, 一次不切实的用户环境查看都可能成为代码正在恶意软件分析系统中运行的迹象.</p>

<p>直观来看, 一个解决这样侦查攻击的可能方法就是, 在每次恶意软件运行时建立一个用户数据合法, 真实且不确定的用户环境. 这些自动生成的用户环境是一个”诱人目标”, 可以诱使勒索软件攻击用户数据, 同时也能避免被攻击者识别. 在实践中, 生成用户环境是一个不容忽视的问题, 尤其是在自动化过程中. 这是因为内容生成器不应允许恶意软件作者对分析环境内自动生成的用户内容进行指纹识别, 或是确定内容是否属于真实用户.  我们会在4.1节中详细说明我们是如何在每次勒索软件运行时自动生成一个人造但贴近现实的用户环境.</p>

<h2 id="312-文件系统活动监视">3.1.2 文件系统活动监视</h2>

<p>UNVEIL中的文件系统监视器可以直接访问I/O请求中涉及的数据缓冲区, 从而使系统可以全面地查看所有文件系统的改动. 每一次I/O操作包括有进程名, 时间戳, 操作类型, 文件系统路径, 读/写请求的数据缓冲区指针及对应熵值. I/O请求均在尽可能最低的层中生成. 比方说, 在用户/内核模式中, 有多种方式可以去读, 写以及列举文件, 但所有这些函数最终都会转换为一系列的I/O请求. 无论何时一个用户线程调用I/O请求API, 都会生成一个I/O请求并传递给文件系统驱动. 图1展示的是Windows环境中UNVEIL的上层设计.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/unveil-figure1.png" alt="figure1.png" /></p>

<p>图 1: UNVEIL中I/O访问监视器的设计概览. 该模块监视了用户模式下进程的系统范围的文件系统访问, 这使得UNVEIL全面掌握与用户文件的交互信息</p>

<p>UNVEIL的监视器对所有指向用户模式进程生成的文件系统的I/O请求设置了回调函数. 我们注意到, 对于UNVEIL操作, 由于性能原因, 最好仅为每个I/O请求设置一个回调函数, 并且这也能保持对I/O操作完全的可见性. 在UNVEIL中, 用户模式进程与文件系统的交互被形式化为访问模式. 我们来考虑I/O请求记录中的访问模式, 其中访问踪迹(trace) $T$ 是序列 $t_i$ 的集合.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/unveil-latex-1.png" alt="latex1.png" /></p>

<p>对于我们研究的文件锁定类的所有勒索软件样本, 我们根据经验观察到, 这些样本会产生一些具有独特重复模式的I/O访问记录. 这是因为这些样本都使用了单一的特定策略来拒绝用户文件访问. 在执行攻击时, 每个文件重复的I/O访问模式可以准确地反映出这种攻击策略. 因此, 这些I/O访问模式可以提取为特定勒索软件家族的独特I/O指纹. 要注意的是, 这里我们的方法主要考虑写入和删除请求. 我们将在3.1.2节中阐释为每个文件提取I/O访问模式的过程.</p>

<h3 id="io-数据缓冲区熵值">I/O 数据缓冲区熵值</h3>

<p>在I/O访问记录中发现的每一个对文件的读写请求, UNVEIL都会计算对应数据缓冲区的熵值. 比较同一个文件的读写请求相应的熵值可以绝妙地衡量加密勒索软件的行为. 则是因为勒索软件的一个共同策略就是读取源文件数据, 加密数据并使用加密后的数据覆写原始数据. 我们的系统使用香农熵进行计算. 在一个特定情形中, 假定数据块 $d$ 中的字节均匀随机分布, 我们有以下公式:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/unveil-latex-2.png" alt="latex2.png" /></p>

<h3 id="构建访问模式">构建访问模式</h3>

<p>对每次执行, UNVEIL为勒索软件样本生成I/O访问记录后, 它会根据文件名和请求时间戳对I/O访问请求排序. 这方便系统提取给定的某次运行中每个文件的I/O访问序列, 并检查哪些进程访问了哪些文件. 关键的想法在于, 对每个文件的I/O访问请求进行排序后, 可以轻易地在恶意进程生成I/O请求时观察到重复请求.</p>

<p>系统用来检测勒索软件样本的特定检测标准就是, 在每个恶意软件运行时识别出I/O序列中对应的写入和删除操作.</p>

<p>一次成功的勒索软件攻击, 恶意进程通常意图在攻击期间的某个时刻加密, 覆写或删除用户文件. 在UNVEIL中, 这些I/O请求模式会引发警报, 并被检测为可疑的文件系统活动. 我们研究了不同勒索软件家族中不同文件锁定类的勒索软件样本. 我们的分析结果表明, 尽管这些攻击在其攻击策略(例如, 规避技术, 密钥生成, 密钥管理, 与C&amp;C服务器建立通讯)方面可能大有不同, 但根据其访问请求, 它们主要可以分为三类.</p>

<p>图2显示的是我们在实验中研究的多个勒索软件家族的高级访问模式. 例如, 左侧显示的访问模式表示具有不同密钥长度和桌面锁定技术的Cryptolocker变体. 但其访问模式在家族变体方面并无变化. 我们也观察到, CryptoWall家族中的样本也具有相同的I/O活动. 虽然这些家族成员被识别为两个不同的勒索软件家族, 但由于它们使用相同的加密函数来加密文件(即 Windows CryptoAPI), 因此它们在攻击用户文件时具有相似的I/O模式</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/unveil-figure2.png" alt="figure2" /></p>

<p>图 2: 勒索软件家族在I/O访问模式上的策略差异. (1) 攻击者使用加密版本覆写用户文件; (2) 攻击者读取, 加密和删除文件, 但不会从存储介质中抹除文件; (3) 攻击者读取, 创建一个新的加密版本, 并通过覆写内容安全抹除原始文件</p>

<p>又如, 在FileCoder家族中, 勒索软件首先创建一个新文件, 从受害者文件中读取数据, 生成原始数据的加密版本, 再将加密数据缓冲区写入新生成的文件, 并简单删除原始用户文件的符号链接(见图2.2). 在这类文件锁定类勒索软件中, 恶意软件不会擦除磁盘上原始文件的数据. 对于这样的攻击手段, 受害者有很大可能恢复数据而无需支付赎金. 然而在第三种方法(图2.3)中, 勒索软件会根据原始文件的数据创建一个新的加密文件, 然后使用标准Windows API或自动以覆盖来安全地删除原始文件的数据(例如, CrypVault家族).</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>编写YARA规则检测恶意软件</title>
      <link href="http://www.vancir.com/2018/04/14/creat-yara-rules/"/>
      <pubDate>2018-04-14T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/04/14/creat-yara-rules</guid>
      <content:encoded><![CDATA[<h2 id="简介">简介</h2>

<p>我们都知道, 黑掉漏洞百出的代码比修补代码有趣得多. 但只会入侵的黑客并不一定能满足雇主的需求. 一些公司就希望安全研究人员能够基于他们收集和发现的恶意软件样本或泄露数据进行补丁.</p>

<p>本文适合人群: 新手和爱好者</p>

<h3 id="阅读本文需要的知识">阅读本文需要的知识</h3>

<p>其实并不需要太多知识要求, 当你对恶意软件分析和逆向工程理解越深, 你就越有独特的方式捕获恶意软件. 不过这并不妨碍你写出惊人的yara规则出来. 我所见过的大部分规则都相当基础. 大部分看上去就像5分钟就能写好的python脚本. 编写规则, yara规则本身十分简单, 真正的技巧和细节都在分析部分 .</p>

<ul>
  <li>熟悉GNU Linux</li>
  <li>熟悉C语言语法(不作要求, 但十分有用)</li>
  <li>正则表达式 (同上, 不作要求, 但很有用)</li>
</ul>

<h3 id="声明">声明</h3>

<p>我是自学yara规则, 学校并没有教我这些. 我学习yara大约有30个小时, 花费了我一个周末的时间.</p>

<h2 id="大纲">大纲</h2>

<p>我将介绍以下内容:</p>

<ol>
  <li>规则标识符</li>
  <li>Yara关键字</li>
  <li>字符串
    <ol>
      <li>十六进制值</li>
      <li>文本字符串</li>
      <li>字符串修饰符</li>
      <li>正则表达式</li>
      <li>字符串集</li>
      <li>匿名字符串</li>
    </ol>
  </li>
  <li>条件
    <ol>
      <li>布尔值</li>
      <li>字符串实例计数</li>
      <li>字符串偏移或虚拟地址</li>
      <li>匹配长度</li>
      <li>文件大小</li>
      <li>可执行程序入口点</li>
      <li>访问指定位置的数据</li>
      <li>对多字符串应用同一条件</li>
      <li>迭代字符串出现次数</li>
    </ol>
  </li>
  <li>引用其他规则</li>
  <li>Yara要点
    <ol>
      <li>全局规则</li>
      <li>私有规则</li>
      <li>规则标签</li>
      <li>元数据</li>
      <li>使用模块</li>
      <li>未定义值</li>
      <li>外部变量/参数值</li>
      <li>文件包含</li>
    </ol>
  </li>
</ol>

<p>让我们现在开始吧.</p>

<hr />

<p>Yara与C语言语法十分相像, 以下是一个简单的规则, 这个规则没有进行任何操作:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">HelloRule</span> 
<span class="p">{</span>
<span class="n">condition</span><span class="o">:</span>
<span class="nb">false</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="规则标识符">规则标识符</h2>

<p>规则标识符是上面简单规则示例中跟在<code class="highlighter-rouge">rule</code>后的词,  比如单词”dummy”也可以是一个规则标识符, 标识符命名有如下要求:</p>

<ul>
  <li>是由英文字母或数字组成的字符串</li>
  <li>可以使用下划线字符</li>
  <li>第一个字符不能是数字</li>
  <li>对大小写敏感</li>
  <li>不能超出128个字符长度</li>
</ul>

<h2 id="yara关键字">Yara关键字</h2>

<p>下面这些词不能用作规则标识符, 因为这些单词在yara语言里有特定用处</p>

<blockquote>
  <p>all, and, any, ascii, at, condition, contains entrypoint, false, filesize, fullword, for, global, in import, include, int8,  nt16, int32, int8be, int16be int32be, matches, meta, nocase, not, or, of private, rule, strings, them, true, uint8, uint16 uint32,  int8be, uint16be, uint32be, wide</p>
</blockquote>

<p>通常yara有两部分: <strong>字符串定义</strong>和<strong>条件</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">HelloRule2</span>    <span class="c1">// This is an example
</span><span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">my_text_string</span> <span class="o">=</span> <span class="s">"text here"</span>
        <span class="err">$</span><span class="n">my_hex_string</span> <span class="o">=</span> <span class="p">{</span> <span class="n">E2</span> <span class="mi">34</span> <span class="n">A1</span> <span class="n">C8</span> <span class="mi">23</span> <span class="n">FB</span> <span class="p">}</span>

    <span class="n">condition</span><span class="o">:</span>
        <span class="err">$</span><span class="n">my_text_string</span> <span class="n">or</span> <span class="err">$</span><span class="n">my_hex_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当发现有规则里定义的任意字符串, 规则就会生效. 如你所见, 你还可以在规则里添加注释.</p>

<h2 id="十六进制字符串">十六进制字符串</h2>

<h3 id="通配符">通配符</h3>

<p>十六进制字符串可以用通配符表示, 通配符符号用”?”表示</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">GambitWildcard</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
       <span class="err">$</span><span class="n">hex_string</span> <span class="o">=</span> <span class="p">{</span> <span class="n">EF</span> <span class="mi">44</span> <span class="o">??</span> <span class="n">D8</span> <span class="n">A</span><span class="o">?</span> <span class="n">FB</span> <span class="p">}</span>

    <span class="n">condition</span><span class="o">:</span>
       <span class="err">$</span><span class="n">hex_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个规则可以匹配下面的两个字符串</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EF 44 01 D8 AA FB
EF 44 AA D8 AB FB
</code></pre></div></div>

<h3 id="不定长通配符">不定长通配符</h3>

<p>不定长的字符串可以用下面这个方法表示</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">MarioJump</span>
<span class="p">{</span>
        <span class="n">strings</span><span class="o">:</span>
           <span class="err">$</span><span class="n">hex_string</span> <span class="o">=</span> <span class="p">{</span> <span class="n">F4</span> <span class="mi">23</span> <span class="p">[</span><span class="mi">4</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span> <span class="mi">62</span> <span class="n">B4</span> <span class="p">}</span>

        <span class="n">condition</span><span class="o">:</span>
           <span class="err">$</span><span class="n">hex_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个规则可以匹配下面的两个字符串</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F4 23 01 02 03 04 62 B4
F4 23 AA BB CC DD EE FF 62 B4
</code></pre></div></div>

<p>当然无限长的字符串也是可以的.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">BuzzLightyear</span>
<span class="p">{</span>
        <span class="n">strings</span><span class="o">:</span>
           <span class="err">$</span><span class="n">hex_string</span> <span class="o">=</span> <span class="p">{</span> <span class="n">F4</span> <span class="mi">23</span> <span class="p">[</span><span class="o">-</span><span class="p">]</span> <span class="mi">62</span> <span class="n">B4</span> <span class="p">}</span>

        <span class="n">condition</span><span class="o">:</span>
           <span class="err">$</span><span class="n">hex_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个规则可以匹配下面的两个字符串</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F4 23 AA FF 62 B4
F4 23 AA AA AA AA AA...FF FF 62 B4
</code></pre></div></div>

<h3 id="有条件的字符串">有条件的字符串</h3>

<p>你可以创建一个字符串应对多种情况</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">WorriedRabbit</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
       <span class="err">$</span><span class="n">hex_string</span> <span class="o">=</span> <span class="p">{</span> <span class="n">BA</span> <span class="mi">21</span> <span class="p">(</span> <span class="n">DA</span> <span class="n">BC</span> <span class="o">|</span> <span class="n">C6</span> <span class="p">)</span> <span class="n">A5</span> <span class="p">}</span>

    <span class="n">condition</span><span class="o">:</span>
       <span class="err">$</span><span class="n">hex_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个规则可以匹配下面的两个字符串</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BA 21 DA BC A5
BA 21 C6 A5
</code></pre></div></div>

<h3 id="混合">混合</h3>

<p>当然, 你也可以将上面这几种方法结合起来.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">WorriedGabmitLightyearJump</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
       <span class="err">$</span><span class="n">hex_string</span> <span class="o">=</span> <span class="p">{</span> <span class="n">BA</span> <span class="o">??</span> <span class="p">(</span> <span class="n">DA</span> <span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">|</span> <span class="n">C6</span> <span class="p">)</span> <span class="n">A5</span> <span class="p">}</span>

    <span class="n">condition</span><span class="o">:</span>
       <span class="err">$</span><span class="n">hex_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个规则可以匹配下面的三个字符串</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BA 01 DA 01 02 03 04 A5
BA AA C6 A5
BA FF DA 01 02 A5
</code></pre></div></div>

<h2 id="文本字符串">文本字符串</h2>

<p>除开使用十六进制字符串, 我们也还可以使用文本字符串</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">KimPossible</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">alert_string</span> <span class="o">=</span> <span class="s">"Whats the Sitch"</span>

    <span class="n">condition</span><span class="o">:</span>
       <span class="err">$</span><span class="n">alert_string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>你也可以像C语言那样使用如下的转义符:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">\</span><span class="s">" 双引号</span><span class="err">
</span><span class="se">\\</span><span class="s"> 反斜杠</span><span class="err">
</span><span class="se">\t</span><span class="s"> 水平制表符</span><span class="err">
</span><span class="se">\n</span><span class="s"> 换行符</span><span class="err">
</span><span class="se">\xdd</span><span class="s"> 以十六进制表示的任何字节</span><span class="err">
</span></code></pre></div></div>

<h2 id="修饰符">修饰符</h2>

<h3 id="不区分大小写的字符串">不区分大小写的字符串</h3>

<p>Yara默认对大小写敏感, 但你可以使用修饰符将其关闭</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">ThickSkin</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">strong_string</span> <span class="o">=</span> <span class="s">"Iron"</span> <span class="n">nocase</span>

    <span class="n">condition</span><span class="o">:</span>
        <span class="err">$</span><span class="n">strong_string</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="宽字符串">宽字符串</h3>

<p><code class="highlighter-rouge">wide</code>修饰符可以用来搜寻以2字节表示1字符这种方式编码的字符串, 这种宽字符串在许多二进制文件中都有出现. 如果字符串”FatTony”以2字节表示1字符的方式编码并在二进制文件中出现, 我们就可以使用<code class="highlighter-rouge">wide</code>修饰符将其捕获. 因为”FatTony”也可能是”fattony”, 我们也可以添加<code class="highlighter-rouge">nocase</code>修饰符以免错过.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">FatTony</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">fat_villain</span> <span class="o">=</span> <span class="s">"FatTony"</span> <span class="n">wide</span> <span class="n">nocase</span>

    <span class="n">condition</span><span class="o">:</span>
        <span class="err">$</span><span class="n">fat_villain</span>
<span class="p">}</span>
</code></pre></div></div>

<p>[!]重要提示: 请记住, 该修饰符只是将字符串中字符的ASCII码和\x00交错起来组成宽字符, 它并不支持包含非英文字符的UTF-16字符串. 要想对既有ASCII字符和宽字符的字符串进行搜索, 请使用如下命令:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">ASCIIFatTony</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">fat_villain</span> <span class="o">=</span> <span class="s">"FatTony"</span> <span class="n">wide</span> <span class="n">ascii</span> <span class="n">nocase</span>

    <span class="n">condition</span><span class="o">:</span>
        <span class="err">$</span><span class="n">fat_villain</span>
<span class="p">}</span>
</code></pre></div></div>

<p>字符串默认是ASCII编码, 所以如果你想单独用<code class="highlighter-rouge">ascii</code>搜索”FatTony”, 你并不需要添加<code class="highlighter-rouge">ascii</code>修饰符</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">ASCIIFatTony</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">fat_villain</span> <span class="o">=</span> <span class="s">"FatTony"</span>

    <span class="n">condition</span><span class="o">:</span>
        <span class="err">$</span><span class="n">fat_villain</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果你想在不使用<code class="highlighter-rouge">wide</code>和<code class="highlighter-rouge">nocase</code>修饰符的情况下进行搜索, 上述这个规则可以生效.</p>

<h3 id="fullwords修饰符">Fullwords修饰符</h3>

<p>该修饰符可用于匹配那些前后没有附加其他字符的单词(全词匹配).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">ShadyDomain</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">shady_domain</span> <span class="o">=</span> <span class="s">"faceebook"</span> <span class="n">fullword</span>

    <span class="n">condition</span><span class="o">:</span>
       <span class="err">$</span><span class="n">shady_domain</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个规则可以匹配下面的三个字符串</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>www.faceebook.com
www.myportal.faceebook.com
https://secure.faceebook.com
</code></pre></div></div>

<p>但这个规则<strong>不能</strong>匹配以下的字符串:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>www.myfaceebook.com
thefaceebook.com
</code></pre></div></div>

<p>两者区别在于匹配的全词前后可以附加特殊字符, 不能是普通字符.</p>

<h2 id="正则表达式">正则表达式</h2>

<p>yara允许使用正则表达式, 不过要用正斜杠而非双引号括起来使用(像Perl编程那样)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rule</span> <span class="n">RegularShow</span>
<span class="p">{</span>
    <span class="n">strings</span><span class="o">:</span>
        <span class="err">$</span><span class="n">re1</span> <span class="o">=</span> <span class="o">/</span><span class="n">md5</span><span class="o">:</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">a</span><span class="o">-</span><span class="n">fA</span><span class="o">-</span><span class="n">F</span><span class="p">]{</span><span class="mi">32</span><span class="p">}</span><span class="o">/</span>
        <span class="err">$</span><span class="n">re2</span> <span class="o">=</span> <span class="o">/</span><span class="n">state</span><span class="o">:</span> <span class="p">(</span><span class="n">on</span><span class="o">|</span><span class="n">off</span><span class="p">)</span><span class="o">/</span>

    <span class="n">condition</span><span class="o">:</span>
        <span class="err">$</span><span class="n">re1</span> <span class="n">and</span> <span class="err">$</span><span class="n">re2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该规则将捕获任何状态下找到的所有md5字符串.</p>

<p>你也可以在正则表达式中使用文本修饰符, 如<strong>nocase</strong>,<strong>ascii</strong>,<strong>wide</strong>和<strong>fullword</strong>.</p>

<h3 id="元字符">元字符</h3>

<p>元字符是一个字符对计算机程序有特定含义(而非字面含义)的字符. 在正则表达式中, 有以下含义:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>** 引用下一个元字符
^ 匹配文件的开头
$ 匹配文件的末尾
| 多选
() 分组
[] 方括号字符类
</code></pre></div></div>

<p>也可以使用以下量词:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 匹配0次或多次
+ 匹配1次或多次
? 匹配0次或1次
{n} 只匹配n次
{n, } 至少匹配n次
{ ,m} 至多匹配m次
{n,m} 匹配n到m次
</code></pre></div></div>

<p>也可以使用以下的转义符:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\t 水平制表符 (HT, TAB)
\n 换行符 (LF, NL)
\r 回车符 (CR)
\f 换页符 (FF)
\a 响铃
\xNN 十六进制代码为NN的字符
</code></pre></div></div>

<p>也可以使用以下字符类:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\w 匹配单词字符 (单词可由字母数字加"_"组成)
\W 匹配非单词字符
\s 匹配空白符
\S 匹配非空白字符
\d 匹配一个十进制数字字符
\D 匹配一个非数字字符
\b 匹配单词边界
\B 匹配非单词边界
</code></pre></div></div>

<h3 id="字符串集">字符串集</h3>

<p>如果你想要中列表中选择一定数量的字符串, 你可以执行以下操作:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule MigosPresent
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"

    condition:
        2 of ($m1,$m2,$m3)
}
</code></pre></div></div>

<p>如果<code class="highlighter-rouge">$m1</code>, <code class="highlighter-rouge">$m2</code>和<code class="highlighter-rouge">$m3</code>任意存在两个, 那么就满足上述规则中的条件.</p>

<p>你还可以使用通配符来表示一个字符集. 像如下这样使用通配符<code class="highlighter-rouge">*</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule MigosPresent
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"

    condition:
        2 of ($m*)
}
</code></pre></div></div>

<p>要表示<code class="highlighter-rouge">strings</code>中的所有变量, 你可以使用关键字<code class="highlighter-rouge">them</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule ThreeRappersPresent
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"
        $q1 = "Cardi B"

    condition:
        3 of them // equivalent to 3 of ($*)
}
</code></pre></div></div>

<p>你可以使用任何返回数值的表达式. 以下是使用关键字<code class="highlighter-rouge">any</code>和<code class="highlighter-rouge">all</code>的一个示例</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Squad
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"
        $q1 = "Cardi B"

    condition:
        3 of them // equivalent to 3 of ($*)
        all of them
        any of ($*) and 2 of ($*)    // Fancy way of using any in a rule that requires 3.
}
</code></pre></div></div>

<h3 id="带有of和forof的匿名字符串">带有of和for…of的匿名字符串</h3>

<p>如果你没有专门引用字符串的事件, 你可以仅使用<code class="highlighter-rouge">$</code>来将它们全部引用.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule AnonymousStrings
{
    strings:
        $ = "dummy1"
        $ = "dummy2"

    condition:
        1 of them
}
</code></pre></div></div>

<h2 id="条件">条件</h2>

<table>
  <tbody>
    <tr>
      <td>Yara允许通过and, or, 和not等相关运算符来表示布尔表达式, 算术运算符(+,-,*,%)和位运算符(&amp;,</td>
      <td>, «, », ~, ^)也可用于数值表达式中.</td>
    </tr>
  </tbody>
</table>

<h3 id="布尔运算">布尔运算</h3>

<p>字符串标识符也可在条件中充当布尔变量, 其值取决于文件中相关字符串是否存在.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Example
{
    strings:
        $hero1a = "Batman"
        $hero1b = "Robin"
        $hero2a = "Edward"
        $hero2b = "Alphonse"

    condition:
        ($hero1a or $hero1b) and ($hero2a or $hero2b)
}
</code></pre></div></div>

<h3 id="计数字符串实例">计数字符串实例</h3>

<p>有时我们不仅需要知道某个字符串是否存在, 还需要知道字符串在文件或进程内存中出现的次数. 每个字符串的出现次数由一个变量表示, 变量名是用<code class="highlighter-rouge">#</code>代替<code class="highlighter-rouge">$</code>的字符串标识符. 例如:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Ransomware
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        #a == 2 and #b &gt; 2
}
</code></pre></div></div>

<p>这个规则会匹配任何包含两个字符串<code class="highlighter-rouge">$a</code>以及出现至少两次字符串<code class="highlighter-rouge">$b</code>的文件或进程.</p>

<h3 id="字符串偏移虚拟地址">字符串偏移(虚拟地址)</h3>

<p>在大多数情况下, 当在条件中使用字符串标识符, 我们都只需知道关联的字符串是否在文件或进程内存内就行了. 但有时我们还是需要知道该字符串是否在文件的某个特定偏移处, 或是在进程地址空间的某个虚拟地址处. 在这种情况下, 我们就需要操作符<code class="highlighter-rouge">at</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Offset
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        $a at 100 and $b at 200
}
</code></pre></div></div>

<p>如果在文件的偏移100处(或者在一个正在运行的进程中, 位于虚拟地址100位置)发现了字符串<code class="highlighter-rouge">$a</code>, 我们的规则就能捕获到该字符串. 当然字符串<code class="highlighter-rouge">$b</code>也要在偏移200位置上才行. 你也可以使用十六进制表示而不一定要十进制.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Offset
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        $a at 0x64 and $b at 0xC8
}
</code></pre></div></div>

<p><code class="highlighter-rouge">at</code>操作符指定到一个具体的偏移量, 而你可以使用操作符<code class="highlighter-rouge">in</code>来指定字符串的位置范围.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule InExample
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        $a in (0..100) and $b in (100..filesize)
}
</code></pre></div></div>

<p>字符串<code class="highlighter-rouge">$a</code>必须在偏移0-100之间才能找到, 而<code class="highlighter-rouge">$b</code>则必须是在偏移100到文件末尾位置(才能找到).</p>

<p>你也可以使用<code class="highlighter-rouge">@a[i]</code>来取得字符串<code class="highlighter-rouge">$a</code>第<code class="highlighter-rouge">i</code>个字符的偏移量或虚拟地址. 字符串索引以<code class="highlighter-rouge">1</code>开头 , 故第1个字符是<code class="highlighter-rouge">@a[1]</code>, 第2个是<code class="highlighter-rouge">@[a2]</code>并依此类推, 而不是以<code class="highlighter-rouge">@a[0]</code>开始. 如果你提供的索引值大过字符串总共出现的次数. 那结果就将是值<code class="highlighter-rouge">NaN</code>(Not a Number, 非数字).</p>

<h3 id="匹配长度">匹配长度</h3>

<p>对于包含跳转的许多正则表达式和十六进制字符串, 匹配长度用一个变量表示. 如果你有一个正则表达式<code class="highlighter-rouge">/fo*/</code>, 可以匹配字符串<code class="highlighter-rouge">fo</code>, <code class="highlighter-rouge">foo</code>和<code class="highlighter-rouge">fooo</code>, 那么各个的匹配长度都是不同的.</p>

<p>在字符串标识符前加一个<code class="highlighter-rouge">!</code>得到匹配长度, 你就可以将匹配长度作为你条件的一部分. 跟你获取偏移时使用字符<code class="highlighter-rouge">@</code>类似, <code class="highlighter-rouge">!a[1]</code>是第一个匹配到的字符串<code class="highlighter-rouge">$a</code>的长度, 而<code class="highlighter-rouge">!a[2]</code>就是第二个匹配到的字符串的长度, 依此类推. <code class="highlighter-rouge">!a</code>是<code class="highlighter-rouge">!a[1]</code>的缩写.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Hak5
{
    strings:
        $re1 = /hack*/    // Will catch on hacker, hacked, hack, hack*

    condition:
        !re1[1] == 4 and !re1[2] &gt; 6
}
</code></pre></div></div>
<p>该规则可以匹配如下字符串:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>We hack things. We are hackers.
</code></pre></div></div>

<p>第一个<code class="highlighter-rouge">hack</code>是<code class="highlighter-rouge">re1[1]</code>且其长度等于4. 第二个<code class="highlighter-rouge">hack</code>长度则至少为6</p>

<h3 id="文件大小">文件大小</h3>

<p>字符串标识符并不是唯一可以在条件中出现的变量(实际上, 可以不定义任何字符串来编写一个规则), 还可以使用其他变量. <code class="highlighter-rouge">filesize</code>就保存着正在扫描的文件的大小. 大小以字节为单位.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule FileSizeExample
{
    condition:
       filesize &gt; 200KB
}
</code></pre></div></div>

<p>我们可以使用后缀<code class="highlighter-rouge">KB</code>将文件大小设置为<code class="highlighter-rouge">200KB</code>, 它会自动将常量的值乘上1024, 后缀<code class="highlighter-rouge">MB</code>会可以将值乘以<code class="highlighter-rouge">2^20</code>. 这两个后缀都只能用于十进制常量</p>

<p>[!]重要提示: <code class="highlighter-rouge">filesize</code>仅在规则应用于文件的时候生效. 如果应用于正在运行的进程, 那么它会永远都匹配不了.</p>

<h3 id="可执行程序入口点">可执行程序入口点</h3>

<p>如果我们正扫描的文件是一个PE或ELF文件, 那么变量<code class="highlighter-rouge">entry_point</code>会存有可执行文件的入口点偏移值. 而如果我们正扫描一个运行的进程, 那么<code class="highlighter-rouge">entry_point</code>会存有可执行文件入口点的虚拟地址. 变量<code class="highlighter-rouge">entry_point</code>的经典用法是用于搜索入口点的一些pattern, 以检测壳或简单的感染病毒. 目前使用<code class="highlighter-rouge">entry_point</code>的方式是通过导入PE和/或ELF的库并使用它们各自的功能. Yara的<code class="highlighter-rouge">entrypoint</code>函数自第3版开始就已经过时了. 以下是它在第3版之前的样子.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule EntryPointExample1
{
    strings:
        $a = { E8 00 00 00 00 }

    condition:
       $a at entrypoint
}

rule EntryPointExample2
{
    strings:
        $a = { 9C 50 66 A1 ?? ?? ?? 00 66 A9 ?? ?? 58 0F 85 }

    condition:
       $a in (entrypoint..entrypoint + 10)
}
</code></pre></div></div>

<p>[!]重要提示: 再次强调, 不要使用yara的<code class="highlighter-rouge">entrypoint</code>, 请在导入PE或ELF文件后使用对应的<code class="highlighter-rouge">pe.entry_point</code>和<code class="highlighter-rouge">elf.entry_point</code></p>

<h3 id="访问指定位置的数据">访问指定位置的数据</h3>

<p>如果你想从特定偏移位置读取数据, 并将其存为一个变量. 那么你可以使用以下任何一个方式:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">int8</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">int16</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">int32</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>

<span class="n">uint8</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">uint16</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">uint32</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>

<span class="n">int8be</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">int16be</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">int32be</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>

<span class="n">uint8be</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">uint16be</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
<span class="n">uint32be</span><span class="p">(</span><span class="o">&lt;</span><span class="n">offset</span> <span class="n">or</span> <span class="k">virtual</span> <span class="n">address</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>数据存储默认以小端序, 如果你想要读取大端序的整形数, 请使用下面几个以<code class="highlighter-rouge">be</code>结尾的对应函数.</p>

<p>参数<code class="highlighter-rouge">&lt;offset or virtual address&gt;</code>可以是任何一个返回无符号整数的表达式, 包括可以是<code class="highlighter-rouge">uintXX</code>函数的返回值.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule IsPE
{
  condition:
     // MZ signature at offset 0 and ...
     uint16(0) == 0x5A4D and
     // ... PE signature at offset stored in MZ header at 0x3C
     uint32(uint32(0x3C)) == 0x00004550
}
</code></pre></div></div>

<h3 id="forof-对许多字符串应用同一个条件">for…of: 对许多字符串应用同一个条件</h3>

<p>要用for循环来检查一组字符串是否满足特定条件, 请使用如下语法:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for num of string_set : ( boolean_expression )
</code></pre></div></div>

<p>对每个<code class="highlighter-rouge">string_set</code>的字符串, 都会计算<code class="highlighter-rouge">boolean_expression</code>的值, 并且这些值必须至少有1个为真.</p>

<p>当然你也可以使用其他关键字, 如<code class="highlighter-rouge">all</code>或<code class="highlighter-rouge">any</code>代替<code class="highlighter-rouge">num</code>来使用.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for any of ($a,$b,$c) : ( $ at elf.entry_point  )
</code></pre></div></div>

<p><code class="highlighter-rouge">$</code>表示集合中的所有字符串. 本例中, 它是字符串<code class="highlighter-rouge">$a</code>, <code class="highlighter-rouge">$b</code>和<code class="highlighter-rouge">$c</code>.</p>

<p>你也可以使用符号<code class="highlighter-rouge">#</code>和<code class="highlighter-rouge">@</code>来引用每一个字符串的出现次数和首字符偏移量.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for all of them : ( # &gt; 3 )
for all of ($a*) : ( @ &gt; @b )
</code></pre></div></div>

<h3 id="迭代字符串出现次数">迭代字符串出现次数</h3>

<p>如果你想对偏移迭代并测试条件. 你可以如下操作:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Three_Peat
{
    strings:
        $a = "dummy1"
        $b = "dummy2"

    condition:
        for all i in (1,2,3) : ( @a[i] + 10 == @b[i] )
}
</code></pre></div></div>

<p>这个规则说的是, <code class="highlighter-rouge">$b</code>出现前三个的字符串应当分别隔<code class="highlighter-rouge">$a</code>出现的前三个的字符串10个字节远. 另外一种写法如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for all i in (1..3) : ( @a[i] + 10 == @b[i] )
</code></pre></div></div>

<p>我们也可以使用表达式. 在本例中, 我们迭代每一次出现的<code class="highlighter-rouge">$a</code>(记住, <code class="highlighter-rouge">#a</code>代表<code class="highlighter-rouge">$a</code>的出现次数). 该规则指定, 每一次<code class="highlighter-rouge">$a</code>都应当出现在文件的前100个字节内.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for all i in (1..#a) : ( @a[i] &lt; 100 )
</code></pre></div></div>

<p>你也可以指定字符串的某一次出现需要满足条件(而非全部).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for any i in (1..#a) : ( @a[i] &lt; 100 )
for 2 i in (1..#a) : ( @a[i] &lt; 100 )
</code></pre></div></div>

<h3 id="引用其他规则">引用其他规则</h3>

<p>就像C语言中引用函数那样. 函数, 或是这里说的规则, 都必须在使用前进行定义.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule Rule1
{
    strings:
        $a = "dummy1"

    condition:
        $a
}

rule Rule2
{
    strings:
        $a = "dummy2"

    condition:
        $a and Rule1
}
</code></pre></div></div>

<h2 id="yara要点">Yara要点</h2>

<h3 id="全局规则">全局规则</h3>

<p>Yara允许用户在所有规则中进行约束. 如果你希望所有规则都忽略掉那些超出特定大小限制的文件, 那么你可以对规则进行必要的修改, 或是编写一条像以下这样的全局规则:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>global rule SizeLimit
{
    condition:
        filesize &lt; 2MB
}
</code></pre></div></div>

<p>你可以根据需要定义各种全局规则. 这些规则会在其他规则之前运行.</p>

<h3 id="私有规则">私有规则</h3>

<p>私有规则在匹配时没有任何输出. 当和其它规则成对引用时, 这样就可以使输出更为清楚. 比如为了判断文件是否恶意, 有这样一条私有规则, 要求文件必须是ELF文件. 一旦满足这个要求, 随后就会执行下一条规则. 但我们在输出里想看的并不是该文件它是不是ELF, 我们只想知道文件是否恶意, 那么私有规则就派上用场了.  要想创建一条私有规则, 只需要在<code class="highlighter-rouge">rule</code>前添加一个<code class="highlighter-rouge">private</code>即可.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private rule PrivateRule
{
    ...
}
</code></pre></div></div>

<h3 id="规则标签">规则标签</h3>

<p>如果你只想查看<code class="highlighter-rouge">ruleName</code>类型的规则输出, 你可以对你的规则打上标签</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule TagsExample1 : Foo Bar Baz
{
    ...
}

rule TagsExample2 : Bar
{
    ...
}
</code></pre></div></div>

<h3 id="元数据">元数据</h3>

<p>Yara允许在规则中存储一些额外数据.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule MetadataExample
{
    meta:
        my_identifier_1 = "Some string data"
        my_identifier_2 = 24
        my_identifier_3 = true

    strings:
        $my_text_string = "text here"
        $my_hex_string = { E2 34 A1 C8 23 FB }

    condition:
        $my_text_string or $my_hex_string
}
</code></pre></div></div>

<h3 id="使用模块">使用模块</h3>

<p>一些模块由YARA官方发布, 比如<code class="highlighter-rouge">PE</code>和<code class="highlighter-rouge">Cukoo</code>模块. 这些模块就如python那样导入即可, 不过在导入时模块名需要添加双引号</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "pe"
import "cuckoo"
</code></pre></div></div>

<p>一旦模块成功导入, 你就可以在函数前加模块名, 来使用这些功能.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pe.entry_point == 0x1000
cuckoo.http_request(/someregexp/)
</code></pre></div></div>

<h3 id="未定义的值">未定义的值</h3>

<p>一些值在运行时保留为<code class="highlighter-rouge">undefined</code>. 如果以下规则在ELF文件上执行并找到对应的字符串, 那么它的结果相当于<code class="highlighter-rouge">TRUE &amp; Undefined</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "pe"

rule Test
{
  strings:
      $a = "some string"

  condition:
      $a and pe.entry_point == 0x1000
}
</code></pre></div></div>

<p>所以在用的时候要注意咯!</p>

<h3 id="外部变量">外部变量</h3>

<p>外部变量允许你定义一些, 依赖于<code class="highlighter-rouge">第三方</code>提供值的规则.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule ExternalVariable1
{
    condition:
       ext_var == 10
}
</code></pre></div></div>

<p><code class="highlighter-rouge">ext_var</code>是一个外部变量, 它在运行时会分配有一个值, (见命令行的<code class="highlighter-rouge">-d</code>选项以及yara-python中<code class="highlighter-rouge">compile</code>和<code class="highlighter-rouge">match</code>方法的参数). 外部变量可以是<code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">str</code>或<code class="highlighter-rouge">boolean</code>类型</p>

<p>外部变量可以和操作符<code class="highlighter-rouge">contains</code>和<code class="highlighter-rouge">matches</code>一起使用. <code class="highlighter-rouge">contains</code>在字符串包含特定子串的情况下返回<code class="highlighter-rouge">true</code>. 而<code class="highlighter-rouge">matches</code>在字符串匹配给定的正则表达式时返回<code class="highlighter-rouge">true</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule ExternalVariable2
{
    condition:
        string_ext_var contains "text"
}

rule ExternalVariable3
{
    condition:
        string_ext_var matches /[a-z]+/
}
</code></pre></div></div>

<p>你也可以将<code class="highlighter-rouge">matches</code>操作符和正则表达式一起使用</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rule ExternalVariableExample5
{
    condition:
        /* case insensitive single-line mode */
        string_ext_var matches /[a-z]+/is
}
</code></pre></div></div>

<p><code class="highlighter-rouge">/[a-z]+/is</code>中的<code class="highlighter-rouge">i</code>表示匹配时不区分大小写. <code class="highlighter-rouge">s</code>表示是在单行(single line)模式</p>

<p>记住, 你必须在运行时定义好所有的外部变量. 你可以使用<code class="highlighter-rouge">-d</code>参数来指定.</p>

<h3 id="文件包含">文件包含</h3>

<p>当然在yara里你可以使用类似C语言的导入方式(#include, 不过yara里并不使用#, 并且包含的文件需要加双引号)来包含其他文件. 你可以在包含时使用相对路径, 绝对路径. 如果是windows系统, 还可以是驱动设备的路径.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include "Migos.yar"
include "../CardiB.yar"
include "/home/user/yara/IsRapper.yar"
include "c:\\yara\\includes\\oldRappers.yar"
include "c://yara/includes/oldRappers.yar"
</code></pre></div></div>

<h2 id="总结">总结</h2>

<p>好吧. 现在你应该知道如何写一些Yara规则了. 
这里有一些恶意软件的仓库, 规则和工具, 可以让你来生成yara规则. 如果你安装了<code class="highlighter-rouge">yarGem</code>, 你只需要将它指向到恶意软件, 它就会为该恶意软件生成一个签名. 如果你想捕捉一个恶意软件家族, 你最好是将规则推广到整个家族去.</p>

<p>资源:</p>

<ul>
  <li><a href="https://github.com/Yara-Rules/rules">Yara-Rules/rules</a></li>
  <li><a href="https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/">How to Write Simple but Sound Yara Rules - BSK Consulting GmbH</a></li>
  <li><a href="https://www.f-secure.com/v-descs/worm_w32_downadup_al.shtml">descs/worm_w32_downadup_al.shtml</a></li>
  <li><a href="https://www.f-secure.com/v-descs/worm_w32_downadup.shtml">https://www.f-secure.com/v-descs/worm_w32_downadup.shtml</a></li>
  <li><a href="https://support.microsoft.com/en-us/help/962007/virus-alert-about-the-win32-conficker-worm">https://support.microsoft.com/en-us/help/962007/virus-alert-about-the-win32-conficker-worm</a></li>
  <li><a href="https://www.f-secure.com/v-descs/worm_w32_downadup_a.shtml">https://www.f-secure.com/v-descs/worm_w32_downadup_a.shtml</a></li>
  <li><a href="https://www.f-secure.com/v-descs/worm_w32_downadup_gen.shtml">https://www.f-secure.com/v-descs/worm_w32_downadup_gen.shtml</a></li>
  <li><a href="https://www.f-secure.com/v-descs/worm_w32_downaduprun_a.shtml">https://www.f-secure.com/v-descs/worm_w32_downaduprun_a.shtml</a></li>
</ul>

<p>Yara:</p>

<ul>
  <li><a href="https://www.experts-exchange.com/questions/29042297/How-to-test-yara-rule.html">How to test yara rule?</a></li>
  <li><a href="https://www.securityartwork.es/2013/10/11/yara-101/">https://www.securityartwork.es/2013/10/11/yara-101/</a></li>
  <li><a href="https://stixproject.github.io/documentation/idioms/yara-test-mechanism/">https://stixproject.github.io/documentation/idioms/yara-test-mechanism/</a></li>
  <li><a href="https://github.com/Neo23x0/yarGen">Neo23x0/yarGen</a></li>
  <li><a href="https://github.com/radare/radare2/blob/master/doc/yara.md">radare/radare2/blob/master/doc/yara.md</a></li>
  <li><a href="https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/">How to Write Simple but Sound Yara Rules - BSK Consulting GmbH</a></li>
  <li><a href="https://www.bsk-consulting.de/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/">How to Write Simple but Sound Yara Rules - Part 2 - BSK Consulting GmbH</a></li>
  <li><a href="https://www.bsk-consulting.de/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/">How to Write Simple but Sound Yara Rules – Part 3 - BSK Consulting GmbH</a></li>
</ul>

<p>xxd:</p>

<ul>
  <li><a href="https://www.systutorials.com/docs/linux/man/1-xxd/">https://www.systutorials.com/docs/linux/man/1-xxd</a></li>
</ul>

<p>比较命令</p>

<p><code class="highlighter-rouge">awk ‘FNR==NR{a[$1];next}($1 in a){print}’ malcourse.strings zoo.conficker.strings &gt; same-strings</code></p>

<p>恶意软件仓库</p>

<ul>
  <li><a href="https://github.com/Malshare/MalShare-Toolkit">Malshare/MalShare-Toolkit</a></li>
  <li><a href="http://malshare.com/about.php">http://malshare.com/about.php</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>模糊测试-初学者入门指南</title>
      <link href="http://www.vancir.com/2018/04/07/fuzz-testing-beginners-guide/"/>
      <pubDate>2018-04-07T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/04/07/fuzz-testing-beginners-guide</guid>
      <content:encoded><![CDATA[<h2 id="模糊测试简介">模糊测试简介</h2>

<p>模糊测试(Fuzzing), 简而言之, 就是为了触发新的或不可预见的代码执行路径或bug而在程序中插入异常的, 非预期的, 甚至是随机的输入. 因为模糊测试涉及到为目标提供大量的测试样例, 因此至少也会实现部分自动化. 模糊测试可以也应当用于测试每个需要接受某种形式输入的接口. 实际上, 模糊测试最起码就应该拿来用于测试每个从潜在恶意来源(比如互联网或用户提供的文件)获取输入的接口.</p>

<p>模糊测试是对其他测试技术的补充. 由模糊测试揭露出的问题往往是开发人员不太可能构建的输入(例如, 在处理一些边界情况, 数据正确性和错误处理例程时的输入)触发的. 在常规自动化测试过程中, 模糊测试扩大了代码覆盖范围, 提高了代码覆盖率测试程度. 通过模糊测试使用的非预期输入通常会触发一些平时不会触发的执行流.</p>

<p>很多地方都需要进行模糊测试. 它是你系统开发生命周期(SDLC)的一部分, 在这部分里, 你需要确保你完成了改善目标所要的系统性工作, 或是你只是想解决一些bug也行. 要如何费心于模糊测试取决于你的最终目标和相关资源, 本文只是帮你如何从模糊测试中获取更多的回报.</p>

<h2 id="开始之前">开始之前</h2>

<p>也许到现在你已经跃跃欲试了. 很多组织和个体经常急于根据博客文章中的思路或会议上看到的酷炫演示来进行一次模糊测试, 这虽不一定是坏事, 但我们经常可以看到在模糊测试系统的背后有着大量的工作投入, 这些模糊测试系统仅在作者分配去完成其他任务之前有在使用, 稍加改动就会破坏兼容性. 更糟糕的是这些模糊测试系统长年消耗硬件资源, 却经常没能得出什么结果来. 就如同软件开发项目的其他任何部分一样, 测试自动化和模糊测试与否, 都需要一定的规划, 维护和提交.</p>

<h3 id="你想拿fuzz干什么">你想拿fuzz干什么?</h3>

<p>这是一个简单的问题, 但是答案却并不一定如你所想那样显而易见. 如果你已经有了一个目标, 那很不错. 如果没有, 那你就得去找一个接受输入的接口. 接口可以是对外的, 像是网络连接, 可以是一些文件. 当然也完全可以是对内的, 像是一个你代码正在使用的实用程序库(utility)里的函数调用约定. 模糊测试就是为你所选择的接口创建输入, 并观察这些接口如何处理这些极端的输入. 你可以通过威胁建模(Threat modelling)和回执数据流图来发现目标所拥有的潜在接口.</p>

<p>在每个接口背后可以有许多软件层, 选择对哪个层进行模糊测试就显得至关重要, 因为输入要到达那个层, 就需要通过前面各层的所有检查.</p>

<p>举个例子, 我们来看一个接收带签名二进制数据的HTTP服务器. 我们有一个含JSON字符串的二进制数据, 字符串里是我们应用程序要用到的值. 在这个例子里, 我们就有4个潜在的层需要进行模糊测试:</p>

<ol>
  <li>服务器接收的HTTP消息</li>
  <li>二进制数据的签名校验</li>
  <li>JSON字符串解析</li>
  <li>我们处理实际值的代码</li>
</ol>

<p>暂且假定我们的HTTP, 签名和JSON库都是鲁棒的(我们并不想以这些库为目标). 要对我们自己的代码进行模糊测试, 我们就需要生成这些实际值, 然后将这些实际值包装为JSON字符串, 对二进制数据签名, 创建一个HTTP消息并将其发送给目标. 除非我们已经有了可以复用的自动化测试代码, 否则单独构建这些测试样例需要相当长的时间. 在堆栈中进行模糊测试也会不断带来开销, 并且在更改某些层时也更容易被破坏.</p>

<p>在模糊测试中, 测试样例的吞吐量也相当关键. 你应当考虑下目标是否有一些可禁用或绕过的功能, 以减少开销并扩大模糊测试覆盖范围. 通常我们实现一个直接使用模糊值调用目标代码的小程序可以带来不少好处. 在上面这个例子里, 写一个直接将值传递给我们处理代码的程序, 就可以绕过发送网络消息, 好几次哈希计算, 加密检查, JSON转字符串以及解析这些步骤. 在一些优化更好的模糊测试环境里, 诸如不必要的日志记录, CRC校验, 文件I/O以及远程资源调用等功能都会在一个更适合模糊测试的模式(“fuzz-friendly mode”)下禁用. 我们可以用一些<code class="highlighter-rouge">ifdef</code>, 创建虚拟(Mock)函数或其他仅用于构建模糊测试的配置来实现一个对模糊测试友好的模式(“fuzz-friendly mode”). 当然, 当你在进行一些会改变目标行为的模糊测试优化时, 你必须能确保这些修改不会创建或隐含任何的bug.</p>

<p>不过, 在刚开始时, 不要太担心想着要一个高效的每秒将数千个测试用例注入进优化的模糊测试环境中去的策略. 开始模糊测试的一个非常有效的办法就是将随机(或位翻转)的数据发送到你找到的任何接口去. 如果这能很快地找到问题, 那么你就算是找到了你第一个目标接口了!</p>

<h3 id="你想找寻的是什么">你想找寻的是什么?</h3>

<p>很多时候当你进行模糊测试, 目标可能会崩溃, 这是很难避免的. 然而, 为了能充分利用你的劳动, 你就还需要找到其他的错误情况. 目标都有它自己的功能需求, 需求里定义了程序应该干什么, 你可以从跟这个点找到它不应该做的事情. 除此之外, 所有程序都可能存在逻辑缺陷, 可能导致内存泄露或CPU及内存消耗过多等问题. 根据底层技术, 目标也可能容易发生内存腐败, 命令注入或其他应当注意的问题类别.</p>

<p>起初, 所有可能的潜在问题类型及其影响都应该记录下来. 现有的检测工具和技术可以适用于不同的问题类型, 但有些检测工具和技术使用起来相当复杂, 或是执行开销高昂. 影响评估有助于你判断使用工具或某技术是否值得. 例如, 图像压缩中颜色值的错误计算可能影响很小, 但却难以检测. 如果你只是想找到这些问题, 那么一些能使用模糊的和无效的身份绕过验证的地方十分致命, 也相当容易被检测到.</p>

<p>在研究不同的工具和技术时, 还要考虑其他的自动化测试方法. 例如, 在很多情况下, 你会发现你的单元测试(unit test)一次又一次触发了一些错误, 但你可能因为没有用到单元测试而无法发觉.</p>

<h3 id="如何进行模糊测试">如何进行模糊测试?</h3>

<p>模糊测试是一项一人一机器就能执行的技术. 中等规模的模糊测试可以作为持续集成(CI)系统的一部分来执行, 针对不同的项目每天运行几次模糊测试. 大规模的模糊测试可以通过使用数百上千台机器在云端并行自动地模糊测试. 所有这些环境都有着最终系统必须满足的不同需求. 因为最初基本不会考虑到与另一些部件的可用性, 所以通常情况下不会使用大型fuzzer</p>

<p>和所有的测试相同, 测试规模越大, 自动化就越重要. 使用单个实例来fuzz你的程序非常简单. 你可用不断地将模糊输入注入到目标程序中, 直到触发bug, 然后修复bug, 如此不断重复即可. 但当你同时处理成百上千个实例时, 你就会知道为什么重复筛选等功能相当重要了. 在一个在CI中针对不同构建版本并行运行模糊测试的大型组织中, 你也可能会忽视自动问题报告, 最小化测试用例和补丁验证这些需要注意的问题.</p>

<h2 id="准备开始">准备开始</h2>

<p>在这里, 你应该对模糊测试所需的三个部件建立一个粗略的需求规格说明: 测试用例生成方案, 测试用例注入方法和装置. 现在你终于可以开始真正的工作了.</p>

<p>互联网里有许多开源或商业性质的模糊测试解答方案. 有些仅仅实现了测试用例生成, 有些则结合了测试用例生成和注入, 还有一些则具备完整的含有装置和自动化的堆栈. 一般而言, 商业产品可用性更强, 并且通常可以为大部分测试用例提供完整的解答方案. 特别是对于希望快速开始对多个产品进行模糊测试的组织而言, 商业解决方案是真正的选择. 而对于因为乐趣和利润, 想解决bug的个人, 商业解决方案通常会超出预算.</p>

<p>无论你是决定使用已有的解决方案或是自己实现一个, 都总会遇上一些问题.</p>

<h3 id="fuzzer灵活性">Fuzzer灵活性</h3>

<p>特别当你的最终目标是能对多个不同目标使用同一个工具解决时, 务必要确保你要使用的解决方案足够灵活, 以涵盖所有的样例. 如果整个系统必须进行重构, 或者最坏可能需要构建另一个系统, 那么对目标模糊测试会浪费大量的时间. 不同的工具也会揭示出不同的问题, 以长远眼光来看, 总会有新的工具再次揭露出新的问题. 所以组件切换, 特别是装置切换, 是一个十分有价值的功能.</p>

<h3 id="处理结果">处理结果</h3>

<p>如果你正在建立一个模糊测试系统, 但你并不是实际发现问题解决问题的开发人员之一, 那么请联系那些正准备处理你系统得出结果的人员. 他们想从模糊测试的的bug报告中得到什么呀的信息呢? 如果开发人员每天早上在收件箱里一眼看到满满的像下面这样的bug报告, 那他们是真的很少意识到自己想要的信息:</p>

<blockquote>
  <p>标题: 程序X出现了崩溃</p>
</blockquote>

<blockquote>
  <p>描述: 附件里的数据使得程序X崩溃了</p>
</blockquote>

<blockquote>
  <p>附件: fuzz-test-case-1337 (22MB)</p>
</blockquote>

<p>默认情况下, 错误报告至少应该包含重现问题的全部信息. 例如这样但不限于这样: 配置信息, 使用的操作系统, 目标的版本或构建版本号, CPU和内存信息, 以及适用的编译器选项和调试标志.</p>

<p>模糊测试中使用的设置对于开发人员来说应该要很容易重现才行, 并且你应该为每次对目标模糊测试所做的优化进行解释. 举个例子, 开发人员可能并不想解决只有在CRC校验被关闭的情形下才能重现的问题, 除非你能解释清楚, 当启用CRC校验时如何构造输入也能重现bug.</p>

<p>自动化模糊测试还包括有: 相似问题分类, 测试用例最小化, 回归范围查找, 修复验证, 甚至可以提供像容器, 虚拟机, 映像一样配好的测试环境.</p>

<h3 id="跟踪进展">跟踪进展</h3>

<p>在长时间运行模糊测试之后, 你可能没有发现任何新错误, 这表明可能是如下两种情况之一:</p>

<ol>
  <li>你的模糊测试工作非常出色, 目标的鲁棒性正在提高.</li>
  <li>或者你的模糊测试卡住了, 一次又一次地重复相同的代码路径.</li>
</ol>

<p>正如模糊测试简介那一节所述, 模糊测试需要不断的维护和提交, 以保持长时间有效. 你可以使用一些技术来帮助你确保你的模糊测试始终保持有效, 并且还能对目标发生的一些变化进行测试.</p>

<p>如果你正在使用基于代码覆盖率的fuzzer, 你也许已经覆盖到了该覆盖的范围. 只要你的代码覆盖率在模糊测试过程中持续上升, 就无需担心. 但如果你的代码覆盖率不再上升了, 那你可能就遇到了一些需要更加深入分析的问题.</p>

<p>你不能仅根据现已覆盖的代码行数获知多少信息. 例如, 目标可能有的代码行, 没有特别配置是无法执行的. 或是可能存在无法到达的代码, 使得无法完全覆盖等等情况. 使用工具来显示运行测试样例时, 哪些部分的代码有执行, 哪些没有执行是相当有帮助的. 将这次的结果与之前fuzzer跑出的结果, 或其他自动化测试的结果进行比对, 并检查之前出现bug的位置, 可以帮助确保你的模糊测试效果不会倒退, 并且依旧涵盖着所有相关的代码路径. 如果还是少了一些未经过的代码路径, 那么下一步就是分析如何让你的测试用例生成器生成能触发这些路径的测试数据了. 特别是对于那些基于模型的fuzzer, 你经常会发现说fuzzer并没有拿到模型实现所需要的信息或字段. 变异测试的模糊器缺少代码覆盖率的原因通常都是因为初始样本文件覆盖率过低, 或是对输入的验证过于严格所导致的. 对于后一种情况, 请考虑”fuzz-friendly mode”</p>

<p>没有代码覆盖反馈, 事情就会变得有些棘手. 如果你已经实现了”fuzz-friendly mode”, 那么你有一个简单的解决方案: 那就是制造bug. 在你fuzzer应该到达的位置添加适当的print函数, assert断言或aborts函数, 并根据实际这些位置的到达情况进行跟踪. 你也可以将类似的”bug”添加到之前存在bug的位置. 只要记住, 你进行检查的时候不应影响到你的fuzzer, 使得你的fuzzer过于注重你刚刚添加”bug”的那部分代码, 并且在最后的投入使用之前将这些检查移除掉. 你可以自动化测试可以使用旧的构建版本进行测试, 那你还可以用那些有已知bug的版本来验证你的fuzzer能否找到这些已知bug, 测试那些已发现的旧bug同样也是一个找到系统中有待提高之处的好办法.</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>SHMALL简单堆内存分配器(Simple Heap Memory ALLocator)</title>
      <link href="http://www.vancir.com/2018/04/05/simple-heap-allocator/"/>
      <pubDate>2018-04-05T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/04/05/simple-heap-allocator</guid>
      <content:encoded><![CDATA[<p><a href="https://github.com/CCareaga/heap_allocator">SHMALL</a>是作者<a href="https://github.com/CCareaga">@CCareaga</a>为OS爱好者而编写的一个简单堆分配器. CCareaga编写的这个堆分配器力图尽可能易于理解. 希望能帮到那些OS开发的初学者以及那些对malloc和free的简单函数实现感兴趣的人.</p>

<blockquote>
  <p>我在学习原repo的过程中, 将README里的解释以及代码中的注释翻译成了中文, 详情可见: <a href="https://github.com/Vancir/heap_allocator">Vancir/heap_allocator</a></p>
</blockquote>

<h2 id="compiling">Compiling</h2>
<hr />
<p>代码中包含两个头文件, 各自用于定义堆和链表.</p>

<p>编译命令:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc main.c llist.c heap.c -o heap_test 
$ ./heap_test
</code></pre></div></div>

<p>这会运行分配器的一个demo并输出一些信息.</p>

<h2 id="initialization">Initialization</h2>

<p>需要提供一块内存用以初始化堆空间. 在这里是用的<code class="highlighter-rouge">malloc</code>进行分配. <code class="highlighter-rouge">heap_t</code>结构中的bins也同样需要分配内存</p>

<p>调用函数<code class="highlighter-rouge">init_heap</code>必须要提供一个空白堆结构的地址. 函数<code class="highlighter-rouge">init_heap</code>会创建一个chunk, chunk包含有一个header(<code class="highlighter-rouge">node_t</code>结构)和一个footer(<code class="highlighter-rouge">footer_t</code>结构). 函数需要使用常量<code class="highlighter-rouge">HEAP_INIT_SIZE</code>来确定chunk的大小, 并将其添加到<code class="highlighter-rouge">start</code>参数中以便确定heap的终结位置.</p>

<h2 id="metadata-and-design">Metadata and Design</h2>

<p>每个chunk的内存都包含一个位于开头的node结构和一个位于结尾的footer结构. 无论chunk被释放与否, node结构都包含有chunk的size以及2个用于双向链表中的指针(next和prev). footer结构只包含一个指向header的指针(当要释放相邻chunk时会用到这个指针). 在堆末尾的chunk被称为<code class="highlighter-rouge">wilderness chunk</code>. 它是堆中最大的chunk并且它的最大最小值都有在heap.h中声明. 合并或扩展chunk时就可以通过伸缩wilderness chunk来实现. 被释放的chunk存储在<code class="highlighter-rouge">bin</code>里, 每个bin实际上只是一个由大小相近的node组成的双向链表. 堆结构包含一定数量的bin, 数量在heap.h里的<code class="highlighter-rouge">BIN_COUNT</code>有定义. 要确定哪个bin放哪种chunk, 使用函数<code class="highlighter-rouge">get_bin_index</code>, 将chunk的size作为索引进行确定.</p>

<p>这种一致的binning函数可以确保chunk可以以预定的方式来访问和存储. chunks按顺序插入到bin中, 所以chunk的插入操作并不是O(1), 但也变得更加方便查找最合适的chunk. 注意, 你可以自己定义binning函数, 尽管默认的binning函数的表现已经足够优秀. 确定一个可以帮助快速检索chunk的更复杂binning函数也许是十分值得的.</p>

<h2 id="allocation">Allocation</h2>

<p>函数<code class="highlighter-rouge">heap_alloc</code>取刚刚分配的heap结构地址以及一个size作为参数. 使用函数<code class="highlighter-rouge">get_bin_index</code>来确定对应size的chunk的位置, 当然也许并没有那个size的chunk存在. 如果没有在对应的bin中找到合适的chunk, 那么就会检查下一个bin, 直到找到一个合适的chunk, 或是在找的过程中到达了最后一个bin(也没有找到), 这种情况下会从wilderness堆块中取一块内存出来创建chunk. 如果找到的chunk过大, 那么就会将该chunk分割一小块回收进bin里. 在判定一个chunk是否需要分割的时候, 会减去chunk中不需要使用的元数据(overhead)的大小, 根据剩下的size来确定. 如果chunk分割后, chunk左边的部分内存大于或等于<code class="highlighter-rouge">MIN_ALLOC_SZ</code>, 那我们就应该继续分割chunk并将剩余部分放到合适的bin中. 一旦我们准备好返回我们找到的chunk, 我们返回chunk的<code class="highlighter-rouge">next</code>地址. 这是因为分配chunk时我们并没有用到<code class="highlighter-rouge">next</code>和<code class="highlighter-rouge">prev</code>, 因此chunk的使用者可以将数据写进<code class="highlighter-rouge">next</code>域, 而这不会对堆的内部工作产生丝毫影响.</p>

<h2 id="freeing">Freeing</h2>

<p>函数<code class="highlighter-rouge">heap_free</code>获取<code class="highlighter-rouge">heap_alloc</code>返回的指针. 通过减去合适的偏移量以获取node结构的正确地址. 函数<code class="highlighter-rouge">heap_free</code>并不是简单地将chunk放置在对应的bin里就行了, 还会检查chunk周边的其他chunk. 如果周边的chunk处于空闲状态那么我们就可以将这些chunk合并成一个更大的chunk. 为了合并这些chunk, 我们需要使用footer来获取前一个chunk和后一个chunk的node结构. 比方说, 我们有一个叫<code class="highlighter-rouge">to_free</code>的chunk. 我们减去<code class="highlighter-rouge">sizeof(footer_t)</code>可以获取前一个chunk的footer, 这个footer包含一个指向前一个chunk头部的指针. 而获取后一个chunk , 我们相反加上<code class="highlighter-rouge">sizeof(footer_t)</code>即可. 当合并完毕, 我们会重新计算合并后的chunk的大小并放置进bin里</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>检测Android虚拟机的方法和代码实现</title>
      <link href="http://www.vancir.com/2018/04/04/android-anti-emulator/"/>
      <pubDate>2018-04-04T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/04/04/android-anti-emulator</guid>
      <content:encoded><![CDATA[<p>刚刚看了一些关于Detect Android Emulator的开源项目/文章/论文, 我看的这些其实都是13年14年提出的方法, 方法里大多是检测一些环境属性, 检查一些文件这样, 但实际上检测的思路并不局限于此. 有的是很直接了当去检测qemu, 而其它的方法则是旁敲侧击比如检测adb, 检测ptrace之类的. 思路也很灵活. 最后看到有提出通过利用QEMU这样的模拟CPU与物理CPU之间的实际差异(任务调度差异), 模拟传感器和物理传感器的差异, 缓存的差异等方法来检测. 相比检测环境属性, 检测效果会提升很多.</p>

<p>下面我就列出各个资料中所提出的一些方法/思路/代码供大家交流学习.</p>

<h2 id="qemu-properties">QEMU Properties</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Property</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="n">seek_value</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Property</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">String</span> <span class="n">seek_value</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">seek_value</span> <span class="o">=</span> <span class="n">seek_value</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="cm">/** 
 * 已知属性, 格式为 [属性名, 属性值], 用于判定当前是否为QEMU环境
 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="n">Property</span><span class="o">[]</span> <span class="n">known_props</span> <span class="o">=</span> <span class="o">{</span><span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"init.svc.qemud"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"init.svc.qemu-props"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"qemu.hw.mainkeys"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"qemu.sf.fake_camera"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"qemu.sf.lcd_density"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.bootloader"</span><span class="o">,</span> <span class="s">"unknown"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.bootmode"</span><span class="o">,</span> <span class="s">"unknown"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.hardware"</span><span class="o">,</span> <span class="s">"goldfish"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.kernel.android.qemud"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.kernel.qemu.gles"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.kernel.qemu"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.product.device"</span><span class="o">,</span> <span class="s">"generic"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.product.model"</span><span class="o">,</span> <span class="s">"sdk"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.product.name"</span><span class="o">,</span> <span class="s">"sdk"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.serialno"</span><span class="o">,</span> <span class="kc">null</span><span class="o">)};</span>
<span class="cm">/**
 * 一个阈值, 因为所谓"已知"的模拟器属性并不完全准确, 有可能出现假阳性结果, 因此保持一定的阈值能让检测效果更好
 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">MIN_PROPERTIES_THRESHOLD</span> <span class="o">=</span> <span class="mh">0x5</span><span class="o">;</span>
<span class="cm">/**
 * 尝试通过查询指定的系统属性来检测QEMU环境, 最后跟阈值比较得出检测结果.
 *
 * @param context A {link Context} object for the Android application.
 * @return {@code true} if enough properties where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasQEmuProps</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">found_props</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Property</span> <span class="n">property</span> <span class="o">:</span> <span class="n">known_props</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">property_value</span> <span class="o">=</span> <span class="n">Utilities</span><span class="o">.</span><span class="na">getProp</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">property</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="c1">// See if we expected just a non-null</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">property</span><span class="o">.</span><span class="na">seek_value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">property_value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">found_props</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="c1">// See if we expected a value to seek</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">property</span><span class="o">.</span><span class="na">seek_value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">property_value</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">property</span><span class="o">.</span><span class="na">seek_value</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">found_props</span><span class="o">++;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">found_props</span> <span class="o">&gt;=</span> <span class="n">MIN_PROPERTIES_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这些都是基于一些经验和特征来比对的属性, 这里的属性以及之后的一些文件呀属性啊之类的我就不再多作解释.</p>

<h2 id="device-id">Device ID</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_device_ids</span> <span class="o">=</span> <span class="o">{</span><span class="s">"000000000000000"</span><span class="o">,</span> <span class="c1">// Default emulator id</span>
        <span class="s">"e21833235b6eef10"</span><span class="o">,</span> <span class="c1">// VirusTotal id</span>
        <span class="s">"012345678912345"</span><span class="o">};</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasKnownDeviceId</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TelephonyManager</span> <span class="n">telephonyManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">);</span>

    <span class="n">String</span> <span class="n">deviceId</span> <span class="o">=</span> <span class="n">telephonyManager</span><span class="o">.</span><span class="na">getDeviceId</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">known_deviceId</span> <span class="o">:</span> <span class="n">known_device_ids</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">known_deviceId</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">deviceId</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="default-number">Default Number</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_numbers</span> <span class="o">=</span> <span class="o">{</span>
        <span class="s">"15555215554"</span><span class="o">,</span> <span class="c1">// 模拟器默认电话号码 + VirusTotal</span>
        <span class="s">"15555215556"</span><span class="o">,</span> <span class="s">"15555215558"</span><span class="o">,</span> <span class="s">"15555215560"</span><span class="o">,</span> <span class="s">"15555215562"</span><span class="o">,</span> <span class="s">"15555215564"</span><span class="o">,</span> <span class="s">"15555215566"</span><span class="o">,</span>
        <span class="s">"15555215568"</span><span class="o">,</span> <span class="s">"15555215570"</span><span class="o">,</span> <span class="s">"15555215572"</span><span class="o">,</span> <span class="s">"15555215574"</span><span class="o">,</span> <span class="s">"15555215576"</span><span class="o">,</span> <span class="s">"15555215578"</span><span class="o">,</span>
        <span class="s">"15555215580"</span><span class="o">,</span> <span class="s">"15555215582"</span><span class="o">,</span> <span class="s">"15555215584"</span><span class="o">,};</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasKnownPhoneNumber</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TelephonyManager</span> <span class="n">telephonyManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">);</span>

    <span class="n">String</span> <span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">telephonyManager</span><span class="o">.</span><span class="na">getLine1Number</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">number</span> <span class="o">:</span> <span class="n">known_numbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">phoneNumber</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="imsi">IMSI</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_imsi_ids</span> <span class="o">=</span> <span class="o">{</span><span class="s">"310260000000000"</span> <span class="c1">// 默认IMSI编号</span>
<span class="o">};</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasKnownImsi</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TelephonyManager</span> <span class="n">telephonyManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">);</span>
    <span class="n">String</span> <span class="n">imsi</span> <span class="o">=</span> <span class="n">telephonyManager</span><span class="o">.</span><span class="na">getSubscriberId</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">known_imsi</span> <span class="o">:</span> <span class="n">known_imsi_ids</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">known_imsi</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">imsi</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="build类">Build类</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasEmulatorBuild</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">BOARD</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">BOARD</span><span class="o">;</span> <span class="c1">// The name of the underlying board, like "unknown".</span>
    <span class="c1">// This appears to occur often on real hardware... that's sad</span>
    <span class="c1">// String BOOTLOADER = android.os.Build.BOOTLOADER; // The system bootloader version number.</span>
    <span class="n">String</span> <span class="n">BRAND</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">BRAND</span><span class="o">;</span> <span class="c1">// The brand (e.g., carrier) the software is customized for, if any.</span>
    <span class="c1">// "generic"</span>
    <span class="n">String</span> <span class="n">DEVICE</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">DEVICE</span><span class="o">;</span> <span class="c1">// The name of the industrial design. "generic"</span>
    <span class="n">String</span> <span class="n">HARDWARE</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">HARDWARE</span><span class="o">;</span> <span class="c1">// The name of the hardware (from the kernel command line or</span>
    <span class="c1">// /proc). "goldfish"</span>
    <span class="n">String</span> <span class="n">MODEL</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">MODEL</span><span class="o">;</span> <span class="c1">// The end-user-visible name for the end product. "sdk"</span>
    <span class="n">String</span> <span class="n">PRODUCT</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">PRODUCT</span><span class="o">;</span> <span class="c1">// The name of the overall product.</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">BOARD</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"unknown"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="cm">/* || (BOOTLOADER.compareTo("unknown") == 0) */</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">BRAND</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"generic"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">DEVICE</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"generic"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">MODEL</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"sdk"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">PRODUCT</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"sdk"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">HARDWARE</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"goldfish"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="运营商名">运营商名</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isOperatorNameAndroid</span><span class="o">(</span><span class="n">Context</span> <span class="n">paramContext</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">szOperatorName</span> <span class="o">=</span> <span class="o">((</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">paramContext</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">)).</span><span class="na">getNetworkOperatorName</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">isAndroid</span> <span class="o">=</span> <span class="n">szOperatorName</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">"android"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">isAndroid</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="qemu驱动">QEMU驱动</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_qemu_drivers</span> <span class="o">=</span> <span class="o">{</span><span class="s">"goldfish"</span><span class="o">};</span>
<span class="cm">/**
 * 读取驱动文件, 检查是否包含已知的qemu驱动
 *
 * @return {@code true} if any known drivers where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasQEmuDrivers</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">File</span> <span class="n">drivers_file</span> <span class="o">:</span> <span class="k">new</span> <span class="n">File</span><span class="o">[]{</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/proc/tty/drivers"</span><span class="o">),</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/proc/cpuinfo"</span><span class="o">)})</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">drivers_file</span><span class="o">.</span><span class="na">exists</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">drivers_file</span><span class="o">.</span><span class="na">canRead</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// We don't care to read much past things since info we care about should be inside here</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">drivers_file</span><span class="o">);</span>
                <span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                <span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">String</span> <span class="n">driver_data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">known_qemu_driver</span> <span class="o">:</span> <span class="n">FindEmulator</span><span class="o">.</span><span class="na">known_qemu_drivers</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">driver_data</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">known_qemu_driver</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="qemu文件">QEMU文件</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_files</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/system/lib/libc_malloc_debug_qemu.so"</span><span class="o">,</span> <span class="s">"/sys/qemu_trace"</span><span class="o">,</span>
        <span class="s">"/system/bin/qemu-props"</span><span class="o">};</span>
<span class="cm">/**
 * 检查是否存在已知的QEMU环境文件
 *
 * @return {@code true} if any files where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasQEmuFiles</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">pipe</span> <span class="o">:</span> <span class="n">known_files</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">qemu_file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">pipe</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qemu_file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="genymotion文件">Genymotion文件</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_geny_files</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/dev/socket/genyd"</span><span class="o">,</span> <span class="s">"/dev/socket/baseband_genyd"</span><span class="o">};</span>
<span class="cm">/**
 * 检查是否存在已知的Genemytion环境文件
 *
 * @return {@code true} if any files where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasGenyFiles</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">file</span> <span class="o">:</span> <span class="n">known_geny_files</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">geny_file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">geny_file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="qemu管道">QEMU管道</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_pipes</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/dev/socket/qemud"</span><span class="o">,</span> <span class="s">"/dev/qemu_pipe"</span><span class="o">};</span>
<span class="cm">/**
 * 检查是否存在已知的QEMU使用的管道
 *
 * @return {@code true} if any pipes where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasPipes</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">pipe</span> <span class="o">:</span> <span class="n">known_pipes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">qemu_socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">pipe</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qemu_socket</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="设置断点">设置断点</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">{</span>
    <span class="c1">// This is only valid for arm</span>
    <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">"anti"</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">native</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">qemuBkpt</span><span class="o">();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkQemuBreakpoint</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">hit_breakpoint</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// Potentially you may want to see if this is a specific value</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">qemuBkpt</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hit_breakpoint</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">hit_breakpoint</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以下是对应的c++代码</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">handler_sigtrap</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler_sigbus</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">setupSigTrap</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// BKPT throws SIGTRAP on nexus 5 / oneplus one (and most devices)
</span>  <span class="n">signal</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">handler_sigtrap</span><span class="p">);</span>
  <span class="c1">// BKPT throws SIGBUS on nexus 4
</span>  <span class="n">signal</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">handler_sigbus</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This will cause a SIGSEGV on some QEMU or be properly respected
</span><span class="kt">int</span> <span class="nf">tryBKPT</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">"bkpt 255"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">jint</span> <span class="nf">Java_diff_strazzere_anti_emulator_FindEmulator_qemuBkpt</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">jObject</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">child_status</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setupSigTrap</span><span class="p">();</span>
    <span class="n">tryBKPT</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_status</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="c1">// Time could be adjusted here, though in my experience if the child has not returned instantly
</span>      <span class="c1">// then something has gone wrong and it is an emulated device
</span>      <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Process timed out - likely an emulated device and child is frozen
</span>      <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">WIFEXITED</span><span class="p">(</span><span class="n">child_status</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 子进程正常退出
</span>      <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Didn't exit properly - very likely an emulator
</span>      <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Ensure child is dead
</span>    <span class="n">kill</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我的描述可能并不准确, 因为并没有找到相关的资料. 我只能以自己的理解来解释一下:</p>

<p><code class="highlighter-rouge">SIGTRAP</code>是调试器设置断点时发生的信号, 在nexus5或一加手机等大多数手机都可以触发. <code class="highlighter-rouge">SIGBUS</code>则是在一个总线错误, 指针也许访问了一个有效地址, 但总线会因为数据未对齐等原因无法使用, 在nexus4手机上可以触发. 而<code class="highlighter-rouge">bkpt</code>则是arm的断点指令, 这是曾经qemu被提出来的一个issue, qemu会因为<code class="highlighter-rouge">SIGSEGV</code>信号而崩溃, 作者想利用这个崩溃来检测qemu. 如果程序没有正常退出或被冻结, 那么就可以认定很可能是在模拟器里.</p>

<h2 id="adb">ADB</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasEmulatorAdb</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">FindDebugger</span><span class="o">.</span><span class="na">hasAdbInEmulator</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="isuseramonkey">isUserAMonkey()</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isUserAMonkey</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ActivityManager</span><span class="o">.</span><span class="na">isUserAMonkey</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这个其实是用于检测当前操作到底是用户还是脚本在要求应用执行.</p>

<h2 id="isdebuggerconnected">isDebuggerConnected()</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 你信或不信, 还真有许多加固程序使用这个方法...
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBeingDebugged</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Debug</span><span class="o">.</span><span class="na">isDebuggerConnected</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法是用来检测调试, 判断是否有调试器连接.</p>

<h2 id="ptrace">ptrace</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">tracerpid</span> <span class="o">=</span> <span class="s">"TracerPid"</span><span class="o">;</span>
<span class="cm">/**
 * 阿里巴巴用于检测是否在跟踪应用进程
 * 
 * 容易规避, 用法是创建一个线程每3秒检测一次, 如果检测到则程序崩溃
 * 
 * @return
 * @throws IOException
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasTracerPid</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"/proc/self/status"</span><span class="o">)),</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">line</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">tracerpid</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">tracerpid</span><span class="o">.</span><span class="na">length</span><span class="o">()).</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">tracerpid</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">tracerpid</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">trim</span><span class="o">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法是通过检查<code class="highlighter-rouge">/proc/self/status</code>的<code class="highlighter-rouge">TracerPid</code>项, 这个项在没有跟踪的时候默认为0, 当有程序在跟踪时会修改为对应的pid. 因此如果<code class="highlighter-rouge">TracerPid</code>不等于0, 那么就可以认为是在模拟器环境.</p>

<h2 id="tcp连接">TCP连接</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasAdbInEmulator</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">adbInEmulator</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"/proc/net/tcp"</span><span class="o">)),</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="c1">// Skip column names</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">tcpList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;();</span>

        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tcpList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tcp</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\W+"</span><span class="o">)));</span>
        <span class="o">}</span>

        <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="c1">// Adb is always bounce to 0.0.0.0 - though the port can change</span>
        <span class="c1">// real devices should be != 127.0.0.1</span>
        <span class="kt">int</span> <span class="n">adbPort</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">tcp</span> <span class="n">tcpItem</span> <span class="o">:</span> <span class="n">tcpList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tcpItem</span><span class="o">.</span><span class="na">localIp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">adbPort</span> <span class="o">=</span> <span class="n">tcpItem</span><span class="o">.</span><span class="na">localPort</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">adbPort</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">tcp</span> <span class="n">tcpItem</span> <span class="o">:</span> <span class="n">tcpList</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">tcpItem</span><span class="o">.</span><span class="na">localIp</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tcpItem</span><span class="o">.</span><span class="na">localPort</span> <span class="o">==</span> <span class="n">adbPort</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">adbInEmulator</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">adbInEmulator</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">tcp</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">localIp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">localPort</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">remoteIp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">remotePort</span><span class="o">;</span>

    <span class="kd">static</span> <span class="n">tcp</span> <span class="nf">create</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">tcp</span><span class="o">(</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">4</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">5</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">6</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">7</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">8</span><span class="o">],</span>
                        <span class="n">params</span><span class="o">[</span><span class="mi">9</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">10</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">11</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">12</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">13</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">14</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">tcp</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">localIp</span><span class="o">,</span> <span class="n">String</span> <span class="n">localPort</span><span class="o">,</span> <span class="n">String</span> <span class="n">remoteIp</span><span class="o">,</span> <span class="n">String</span> <span class="n">remotePort</span><span class="o">,</span> <span class="n">String</span> <span class="n">state</span><span class="o">,</span>
                    <span class="n">String</span> <span class="n">tx_queue</span><span class="o">,</span> <span class="n">String</span> <span class="n">rx_queue</span><span class="o">,</span> <span class="n">String</span> <span class="n">tr</span><span class="o">,</span> <span class="n">String</span> <span class="n">tm_when</span><span class="o">,</span> <span class="n">String</span> <span class="n">retrnsmt</span><span class="o">,</span> <span class="n">String</span> <span class="n">uid</span><span class="o">,</span>
                    <span class="n">String</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">String</span> <span class="n">inode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">localIp</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">localIp</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">localPort</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">localPort</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法是通过读取<code class="highlighter-rouge">/proc/net/tcp</code>的信息来判断是否存在adb. 比如真机的的信息为<code class="highlighter-rouge">0: 4604D20A:B512 A3D13AD8...</code>, 而模拟器上的对应信息就是<code class="highlighter-rouge">0: 00000000:0016 00000000:0000</code>, 因为adb通常是反射到<code class="highlighter-rouge">0.0.0.0</code>这个ip上, 虽然端口有可能改变, 但确实是可行的.</p>

<h2 id="taintdroid">TaintDroid</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasPackageNameInstalled</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">String</span> <span class="n">packageName</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">PackageManager</span> <span class="n">packageManager</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getPackageManager</span><span class="o">();</span>

    <span class="c1">// In theory, if the package installer does not throw an exception, package exists</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">packageManager</span><span class="o">.</span><span class="na">getInstallerPackageName</span><span class="o">(</span><span class="n">packageName</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasAppAnalysisPackage</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Utilities</span><span class="o">.</span><span class="na">hasPackageNameInstalled</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="s">"org.appanalysis"</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasTaintClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"dalvik.system.Taint"</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个比较单纯了. 就是通过检测包名, 检测<code class="highlighter-rouge">Taint</code>类来判断是否安装有<code class="highlighter-rouge">TaintDroid</code>这个污点分析工具. 另外也还可以检测<code class="highlighter-rouge">TaintDroid</code>的一些成员变量.</p>

<h2 id="eth0">eth0</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasEth0Interface</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Enumeration</span><span class="o">&lt;</span><span class="n">NetworkInterface</span><span class="o">&gt;</span> <span class="n">en</span> <span class="o">=</span> <span class="n">NetworkInterface</span><span class="o">.</span><span class="na">getNetworkInterfaces</span><span class="o">();</span> <span class="n">en</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">NetworkInterface</span> <span class="n">intf</span> <span class="o">=</span> <span class="n">en</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intf</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"eth0"</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SocketException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>检测是否存在<code class="highlighter-rouge">eth0</code>网卡.</p>

<h2 id="传感器">传感器</h2>

<p>手机上配备了各式各样的传感器, 但它们实质上都是基于从环境收集的信息输出值, 因此想要模拟传感器是非常具有挑战性的. 这些传感器为识别手机和模拟器提供了新的机会.</p>

<p>比如在论文<code class="highlighter-rouge">Rage Against the Virtual Machine: Hindering Dynamic Analysis of Android Malware</code>中, 作者对Android模拟器的加速器进行测试, 作者发现Android模拟器上的传感器会在相同的时间间隔内(观测结果是0.8s, 标准偏差为0.003043)产生相同的值. 显然对于现实世界的传感器, 这是不可能的.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-acc-cdf.png" alt="acc-cdf.png" /></p>

<p>于是我们可以先注册一个传感器监听器, 如果注册失败, 就可能是在模拟器中(排除实际设备不支持传感器的可能性). 如果注册成功, 那么检查<code class="highlighter-rouge">onSensorChanged</code>回调方法, 如果在连续调用这个方法的过程所观察到的传感器值或时间间隔相同, 那么就可以认定是在模拟器环境中.</p>

<h2 id="qemu任务调度">QEMU任务调度</h2>

<p>出于性能优化的原因, QEMU在每次执行指令时都不会主动更新程序计数器(PC), 由于翻译指令在本地执行, 而增加PC需要额外的指令带来开销. 所以QEMU只在执行那些从线性执行过程里中断的指令(例如分支指令)时才会更新程序计数器. 这也就导致在执行一些基本块的期间如果发生了调度事件, 那么也没有办法恢复调度前的PC, 也是出于这个原因, QEMU仅在执行基本块后才发生调度事件, 绝不会执行的过程中发生.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-sche-point.png" alt="sche-point.png" /></p>

<p>如上图, 因为调度可能在任意时间发生, 所以在非模拟器环境下, 会观察到大量的调度点. 而在模拟器环境中, 只能看到特定的调度点.</p>

<h2 id="smc识别">SMC识别</h2>

<p>因为QEMU会跟踪代码页的改动, 于是存在一种新颖的方法来检测QEMU–使用自修改代码(Self-Modifying Code, SMC)引起模拟器和实际设备之间的执行流变化.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-memory.png" alt="memory.png" /></p>

<p>ARM处理器包含有两个不同的缓冲Cache, 一个用于指令访问(I-Cache), 而另一个用于数据访问(D-Cache). 但如ARM这样的哈佛架构并不能保证I-Cache和D-Cache之间的一致性. 因此CPU有可能在新代码片已经写入主存后执行旧的代码片(也许是无效的).</p>

<p>这个问题可以通过强迫两个缓存一致得到解决, 这有两步:</p>

<ol>
  <li>清理主存, 以便将D-Cache中新写入的代码移入主存</li>
  <li>使I-Cache无效, 以便它可以用主存的新内容重新填充.</li>
</ol>

<p>在原生Android代码中, 可以使用<code class="highlighter-rouge">cacheflush</code>函数, 该函数通过系统调用完成上述操作.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-diff.png" alt="diff.png" /></p>

<p>识别代码, 使用一个具有读写权限的内存, 其中包含两个不同函数f1和f2的代码, 这两个函数其实很简单, 只是单纯在一个全局字符串变量的末尾附加各自的函数名称, 这两个函数会在循环里交错执行, 这样就可以通过结果的字符串推断出函数调用序列.</p>

<p>如前所述, 我们调用<code class="highlighter-rouge">cacheflush</code>来同步缓存. 在实际设备和模拟器上运行代码得到的结果是相同的–每次执行都会产生一致的函数调用序列.</p>

<p>接下来我们移除调用<code class="highlighter-rouge">cacheflush</code>, 执行相同的操作. 那么在实际设备中, 我们每次运行都会观察到一个随机的函数调用序列, 这也如前所述的那样, 因为I-Cache可能包含一些旧指令, 每次调用的时候缓存都不同步所导致的.</p>

<p>而模拟器环境却不会发生这样的情况, 而且函数调用序列会跟之前没有移除<code class="highlighter-rouge">cacheflush</code>时完全相同, 也就是每次函数调用前缓存都是一致的. 这是因为QEMU会跟踪代码页上的修改, 并确保生成的代码始终与内存中的目标指令匹配, 因此QEMU会放弃之前版本的代码翻译并重新生成新代码.</p>

<h2 id="结语">结语</h2>

<p>看到这里会不会已经觉得检测方法够多了. 可是我还只是看了13年14年的资料. 有关近几年的资料还未涉及.</p>

<p>最后我就把这些检测方法整合在一张<a href="http://od7mpc53s.bkt.clouddn.com/detect-android-emulator.png">思维导图</a>里供大家一览, 欢迎大家和我交流带带我</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="https://github.com/strazzere/anti-emulator">strazzere/anti-emulator</a>: 首次发表于2013年HitCon, 提出了检测虚拟机的一些方法和思路, 应该是Android模拟器检测的开山之作了, 本文也主要基于该仓库进行讲解.</li>
  <li><a href="http://www.syssec-project.eu/m/page-media/3/petsas_rage_against_the_virtual_machine.pdf">Rage Against the Virtual Machine: Hindering Dynamic Analysis of Android Malware</a>: 通过任务调度检测和使用SMC识别都是参考于这篇论文. 这篇论文和下面这篇论文十分有参考价值, 值得一读.</li>
  <li><a href="https://users.ece.cmu.edu/~tvidas/papers/ASIACCS14.pdf">Evading Android Runtime Analysis via Sandbox Detection</a>: 论文中提出了大量的检测Android运行环境的方法和思路, 内容丰富且十分全面, 也值得一读.</li>
  <li><a href="https://github.com/CalebFenton/AndroidEmulatorDetect">CalebFenton/AndroidEmulatorDetect</a>: 这个仓库其实是整合了一些文章和仓库中的检测方法和代码, 而且并不全面, 不过倒是给出了很多参考链接, 我顺藤摸瓜.</li>
  <li><a href="https://stackoverflow.com/questions/2799097/how-can-i-detect-when-an-android-application-is-running-in-the-emulator">How can I detect when an Android application is running in the emulator?</a>: 网友给出了很多解决方法. 但实际上并不全面, 也只是模拟器检测中的冰山一角罢了. 毕竟可以检测的地方多了去了.</li>
  <li><a href="http://cb.drops.wiki/drops/mobile-13486.html">利用任务调度特性检测Android模拟器</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>恶意软件&quot;TSCookie&quot;介绍</title>
      <link href="http://www.vancir.com/2018/03/06/tscookie/"/>
      <pubDate>2018-03-06T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/03/06/tscookie</guid>
      <content:encoded><![CDATA[<p>2018年1月17日左右, 社交媒体上开始出现一些关于恶意邮件的报道, 这些邮件声称来自日本的教育部, 文化部, 体育部和科技部. 这些邮件里包含有指向恶意软件”TSCookie”的URL链接(趋势科技将其称为为PLEAD恶意软件, 因为PLEAD取自趋势科技过往捕获到的一次APT攻击活动, 故本文中我们将该恶意软件命名为”TSCookie”). TSCookie在2015年在野外被发现, 并且怀疑黑客组织”BlackTech”与此次攻击活动有关. JPCERT/CC证实称, 使用恶意软件的敌对团伙已经对日本组织进行了针对性的攻击. 本文将介绍我们在分析TSCookie后的成果.</p>

<h2 id="tscookie概述">TSCookie概述</h2>

<p>下图描述了TSCookie的执行流程:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-1.png" alt="1.png" /></p>

<p>TSCookie本身只是用作一个下载器, 通过从C&amp;C服务器下载模块来扩展功能. 我们所检查的样本下载了一个具有传出信息和其他功能的DLL文件(以下简称”TSCookieRAT”). 下载的模块仅在内存上运行</p>

<p>TSCookie和TSCookieRAT的行为将在下面的章节中详细解释.</p>

<h2 id="tscookie行为">TSCookie行为</h2>

<p>TSCookie使用HTTP协议与C&amp;C服务器进行通信, 并下载用于加载模块的”模块”和”加载程序”. 恶意软件的资源中有一个加密的DLL文件. 当恶意软件被执行时, DLL文件被加载进内存并执行. DLL文件会执行一些主要功能, 例如与C&amp;C服务器进行通信. (在某些情况下, 主要功能部分并未经过加密并且存储在恶意软件中, 还有一些样本会启动另一个进程并注入解密后的DLL文件.) 恶意软件的配置信息包括有C&amp;C服务器信息且同时使用RC4进行加密. 有关配置的详细信息, 请参阅附录A.</p>

<p>以下是TSCookie在开始时发送的HTTP GET请求的示例. 出站消息被编码包含在Cookie头信息中.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /Default.aspx HTTP/1.1
Cache-Control: no-cache
Connection: Keep-Alive
Date: Thu, 18 Jan 2018 10:20:55 GMT
Pragma: no-cache
Accept: */*
Cookie: 1405D7CD01C6978E54E86DA9525E1395C4DD2F276DD28EABCC3F6201ADAA66F55C15352D29D0FFE51BC9D431EB23E8E58959653D9366E372B5CFCC49BB
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Win32)
Host:[host name]:443
</code></pre></div></div>

<p>包含在Cookie头中的数据经RC4加密(密钥是Date标头值). 数据格式请参考附录B表B-1.</p>

<p>通过这个HTTP GET请求获得的数据使用一个8字节值进行RC4加密, 这个8字节值由配置中的一个固定值(附录A, 表A-1)和发送数据中的一个值(在附录B表B-1中, “根据系统信息生成的4字节值”)组成. 这些数据还包括有模块的加载程序.</p>

<p>TSCookie随后下载一个模块. 以下是下载模块的HTTP POST请求示例.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /Default.aspx HTTP/1.1
Connection: Keep-Alive
Date: Thu, 18 Jan 2018 10:30:55 GMT
Content-Type: application/x-www-form-urlencoded
Accept: */*
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Win32)
Content-Length: 34
Host: [host name]:443

[data]
</code></pre></div></div>

<p>发送的数据也同样是由RC4加密的(密钥是Date标头值). 数据格式请参考附录B表B-2. 通过该HTTP POST请求获得的数据也经过RC4加密, 使用的密钥与HTTP GET请求中密钥相同. 下载下来的模块可以先载入到内存中, 然后调用由HTTP GET请求获得的加载程序来得到执行.</p>

<h2 id="tscookierat行为">TSCookieRAT行为</h2>

<p>TSCookie在加载TSCookieRAT时提供一些参数比如C&amp;C服务器信息. 程序一旦执行后, 感染主机的信息将通过HTTP POST请求发送到外部服务器.(HTTP头信息格式与TSCookie相同.)</p>

<p>数据从开头到0x14(密钥为Date标头值)都有经RC4加密, 紧跟着的是感染主机的信息(主机名, 用户名, 操作系统版本等等). 数据格式请参考附录C表C-1.</p>

<p>下图是发送感染主机信息(已解码)的示例.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-2.png" alt="2.png" /></p>

<p>之后, TSCookieRAT发送一个HTTP GET请求.(HTTP头信息依旧与TSCookie相同.) 通过该请求, C&amp;C服务器发出命令, 而TSCookieRAT执行下列功能. (关于接收到的数据, 请参阅附录C, 表C-2, 关于命令列表, 请参阅附录D, 表D-1.)</p>

<ul>
  <li>执行任意shell命令</li>
  <li>发送驱动器信息</li>
  <li>发送系统信息</li>
  <li>进行文件操作</li>
  <li>从Internet Explorer，Edge，Firefox，Chrome，Outlook处收集密码</li>
</ul>

<p>命令执行的结果以第一个HTTP POST请求同样的格式发送出去(发送感染主机信息). 从C&amp;C服务器发出的命令并未经过编码. 以下是执行列举进程和模块信息的命令时, 发送数据(已解码)的示例。</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-3.png" alt="3.png" /></p>

<h2 id="tscookie解码工具">TSCookie解码工具</h2>

<p>JPCERT/CC制作了一个工具, 用于解码和提取TSCookie的配置信息. 你可以访问Github使用该工具:</p>

<p>JPCERTCC/aa-tools · GitHub
<a href="https://github.com/JPCERTCC/aa-tools/blob/master/tscookie_decode.py">https://github.com/JPCERTCC/aa-tools/blob/master/tscookie_decode.py</a></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-4.png" alt="4.png" /></p>

<h2 id="结语">结语</h2>

<p>使用TSCookie的敌对团伙一直在利用各种类型的恶意软件对日本组织进行攻击. 由于这次攻击行动很可能持续下去. JPCERT/CC将继续谨慎地观察这一趋势.</p>

<p>附录E列出了为本文所检查的样本的散列值. 附录F中还列出了与TSCookie相关的一些目标主机. 请确保您的设备没有与这些主机通信.</p>

<p>如有任何疑问，请联系global-cc [at] jpcert.or.jp</p>

<p>Shusei Tomonaga</p>

<h2 id="参考文章">参考文章</h2>

<p>[1] piyolog: Summary on Ministry of Education, Culture, Sports, Science and Technology Scam in January 2018 (Japanese)</p>

<p><a href="http://d.hatena.ne.jp/Kango/20180119/1516391079">http://d.hatena.ne.jp/Kango/20180119/1516391079</a></p>

<p>[2] Trend Micro: Following the Trail of BlackTech’s Cyber Espionage Campaigns</p>

<p><a href="https://documents.trendmicro.com/assets/appendix-following-the-trail-of-blacktechs-cyber-espionage-campaigns.pdf">https://documents.trendmicro.com/assets/appendix-following-the-trail-of-blacktechs-cyber-espionage-campaigns.pdf</a></p>

<p>[3] Trend Micro: Following the Trail of BlackTech’s Cyber Espionage Campaigns</p>

<p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/following-trail-blacktech-cyber-espionage-campaigns/">https://blog.trendmicro.com/trendlabs-security-intelligence/following-trail-blacktech-cyber-espionage-campaigns/</a></p>

<h2 id="附录-a-tscookie-配置信息">附录 A: TSCookie 配置信息</h2>

<p>表A: 配置信息清单</p>

<table>
  <thead>
    <tr>
      <th>偏移值</th>
      <th>描述</th>
      <th>备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x000</td>
      <td>主机1标志</td>
      <td>如果为0x01则进行通讯</td>
    </tr>
    <tr>
      <td>0x004</td>
      <td>主机1的端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x008</td>
      <td>主机1的端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x010</td>
      <td>主机1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x100</td>
      <td>主机2标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x104</td>
      <td>主机2的端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x108</td>
      <td>主机2的端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x110</td>
      <td>主机2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x200</td>
      <td>主机3标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x204</td>
      <td>主机3的端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x208</td>
      <td>主机3的端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x210</td>
      <td>主机3</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x300</td>
      <td>主机4标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x304</td>
      <td>主机4端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x308</td>
      <td>主机4端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x310</td>
      <td>主机4</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x400</td>
      <td>代理服务器</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x480</td>
      <td>代理端口号</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x484</td>
      <td>代理配置标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x500</td>
      <td>ID号</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x604</td>
      <td>固定值</td>
      <td>4字节的RC4密钥 (0x925A765D)</td>
    </tr>
    <tr>
      <td>0x89C</td>
      <td>暂停时间</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="附录-b-tscookie-发出接收的数据">附录 B: TSCookie 发出/接收的数据</h2>

<p>表 B-1: Cookie头中包含的数据的格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>根据系统信息生成的4字节 (*)</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>0x10050014</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>4</td>
      <td>0x10001</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>4</td>
      <td>0xAB1</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>4</td>
      <td>0x04</td>
    </tr>
    <tr>
      <td>0x14</td>
      <td>4</td>
      <td>根据系统信息生成的4字节</td>
    </tr>
    <tr>
      <td>0x18</td>
      <td>-</td>
      <td>随机数据</td>
    </tr>
  </tbody>
</table>

<p>(*) 表示是用固定值（0x925A765D）加密的RC4值</p>

<p>表 B-2: HTTP POST的数据格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>根据系统信息生成的4字节</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>0x10050014</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>4</td>
      <td>0x10001</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>4</td>
      <td>0xAAD</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>4</td>
      <td>位于0x14后的数据长度</td>
    </tr>
    <tr>
      <td>0x14</td>
      <td>-</td>
      <td>随机数据</td>
    </tr>
  </tbody>
</table>

<h2 id="附录-c-tscookierat-发出接收的数据">附录 C: TSCookieRAT 发出/接收的数据</h2>

<p>表 C-1: HTTP POST的数据格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>根据系统信息生成的4字节</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>0x10050014</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>4</td>
      <td>0x10001</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>4</td>
      <td>0xAAD</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>4</td>
      <td>位于0x14后的数据长度</td>
    </tr>
    <tr>
      <td>0x14</td>
      <td>-</td>
      <td>感染主机信息(使用”根据系统信息生成的4字节值”作为密钥进行RC4加密</td>
    </tr>
  </tbody>
</table>

<p>表 C-2: 接收到的数据格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>命令</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>位于0x8后的数据长度</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>-</td>
      <td>参数</td>
    </tr>
  </tbody>
</table>

<h2 id="附录dtscookierat使用的命令">附录D：TSCookieRAT使用的命令</h2>

<p>表 D-1: 命令清单</p>

<table>
  <thead>
    <tr>
      <th>值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x912</td>
      <td>配置暂停时间</td>
    </tr>
    <tr>
      <td>0x930</td>
      <td>列举进程和模块</td>
    </tr>
    <tr>
      <td>0x932</td>
      <td>终止</td>
    </tr>
    <tr>
      <td>0x934</td>
      <td>启动远程shell</td>
    </tr>
    <tr>
      <td>0x935</td>
      <td>执行远程shell指令</td>
    </tr>
    <tr>
      <td>0x936</td>
      <td>关闭远程shell</td>
    </tr>
    <tr>
      <td>0x946</td>
      <td>获取IP地址</td>
    </tr>
    <tr>
      <td>0x950</td>
      <td>执行文件 (windows会有显示)</td>
    </tr>
    <tr>
      <td>0x951</td>
      <td>执行文件 (windows不会显示)</td>
    </tr>
    <tr>
      <td>0x952</td>
      <td>发送消息</td>
    </tr>
    <tr>
      <td>0x953</td>
      <td>发送驱动消息</td>
    </tr>
    <tr>
      <td>0x954</td>
      <td>发送文件清单</td>
    </tr>
    <tr>
      <td>0x955</td>
      <td>发送文件大小</td>
    </tr>
    <tr>
      <td>0x956</td>
      <td>发送文件</td>
    </tr>
    <tr>
      <td>0x957</td>
      <td>关闭对象句柄</td>
    </tr>
    <tr>
      <td>0x958</td>
      <td>选择文件发送 (发送文件同时执行0x955, 0x956命令)</td>
    </tr>
    <tr>
      <td>0x959</td>
      <td>下载文件</td>
    </tr>
    <tr>
      <td>0x95A</td>
      <td>删除文件</td>
    </tr>
    <tr>
      <td>0x95C</td>
      <td>移动文件</td>
    </tr>
    <tr>
      <td>0x95E</td>
      <td>-</td>
    </tr>
    <tr>
      <td>0x960</td>
      <td>-</td>
    </tr>
    <tr>
      <td>0x96B</td>
      <td>获取windows窗体名</td>
    </tr>
    <tr>
      <td>0x96E</td>
      <td>从Internet Explorer, Edge, Firefox, Chrome, Outlook收集密码</td>
    </tr>
  </tbody>
</table>

<h2 id="附录-e-样本的sha-256值">附录 E: 样本的SHA-256值</h2>

<p>TSCookie</p>

<ul>
  <li>6d2f5675630d0dae65a796ac624fb90f42f35fbe5dec2ec8f4adce5ebfaabf75</li>
  <li>cdf0e4c415eb55bccb43a650e330348b63bc3cbb53f71a215c44ede939b4b830</li>
  <li>17f1996ad7e602bd2a7e9524d7d70ee8588dac51469b08017df9aaaca09d8dd9</li>
  <li>1fa7cbe57eedea0ebc8eb37b91e7536c07be7da7775a6c01e5b14489387b9ca8</li>
  <li>e451a1e05c0cc363a185a98819cd2af421ac87154702bf72007ecc0134c7f417</li>
  <li>1da9b4a84041b8c72dad9626db822486ce47b9a3ab6b36c41b0637cd1f6444d6</li>
  <li>35f966187098ac42684361b2a93b0cee5e2762a0d1e13b8d366a18bccf4f5a91</li>
  <li>0683437aebd980c395a83e837a6056df1a21e137e875f234d1ed9f9a91dfdc7f</li>
  <li>0debbcc297cb8f9b81c8c217e748122243562357297b63749c3847af3b7fd646</li>
  <li>96306202b0c4495cf93e805e9185ea6f2626650d6132a98a8f097f8c6a424a33</li>
  <li>6b66c6d8859dfe06c0415be4df2bd836561d5a6eabce98ddd2ee54e89e37fd44</li>
  <li>06a9c71342eeb14b7e8871f77524e8acc7b86670411b854fa7f6f57c918ffd2b</li>
  <li>20f7f367f9cb8beca7ce1ba980fafa870863245f27fea48b971859a8cb47eb09</li>
  <li>f16befd79b7f8ffdaf934ef337a91a5f1dc6da54c4b2bee5fe7a0eb38e8af39e</li>
  <li>12b0f1337bda78f8a7963d2744668854d81e1f1b64790b74d486281bc54e6647</li>
  <li>201bf3cd2a723d6c728d18a9e41ff038549eac8406f453c5197a1a7b45998673</li>
  <li>5443ee54a532846da3182630e2bb031f54825025700bcd5f0e34802e7345c7b2</li>
  <li>39d7d764405b9c613dff6da4909d9bc46620beee7a7913c4666acf9e76a171e4</li>
  <li>afe780ba2af6c86babf2d0270156da61f556c493259d4ca54c67665c17b02023</li>
  <li>4a8237f9ecdad3b51ffd00d769e23f61f1e791f998d1959ad9b61d53ea306c09</li>
  <li>203c924cd274d052e8e95246d31bd168f3d8a0700a774c98eff882c8b8399a2f</li>
</ul>

<p>TSCookieRAT</p>

<ul>
  <li>2bd13d63797864a70b775bd1994016f5052dc8fd1fd83ce1c13234b5d304330d</li>
</ul>

<h2 id="附录-f-与tscookie相关的目标主机">附录 F: 与TSCookie相关的目标主机</h2>

<ul>
  <li>220.130.216.76</li>
  <li>60.244.52.29</li>
  <li>45.76.102.145</li>
  <li>jpcerts.jpcertinfo.com</li>
  <li>jpcert.ignorelist.com</li>
  <li>twnicsi.ignorelist.com</li>
  <li>twcertcc.jumpingcrab.com</li>
  <li>okinawas.ssl443.org</li>
  <li>apk36501.flnet.org</li>
  <li>appinfo.fairuse.org</li>
  <li>carcolors.effers.com</li>
  <li>edu.microsoftmse.com</li>
  <li>eoffice.etowns.org</li>
  <li>epayplus.flnet.org</li>
  <li>fatgirls.fatdiary.org</li>
  <li>gethappy.effers.com</li>
  <li>iawntsilk.dnset.com</li>
  <li>inewdays.csproject.org</li>
  <li>ktyguxs.dnset.com</li>
  <li>lang.suroot.com</li>
  <li>langlang.dnset.com</li>
  <li>longdays.csproject.org</li>
  <li>lookatinfo.dnset.com</li>
  <li>newtowns.flnet.org</li>
  <li>ntp.ukrootns1.com</li>
  <li>office.dns04.com</li>
  <li>savecars.dnset.com</li>
  <li>splashed.effers.com</li>
  <li>sslmaker.ssl443.org</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>the White Rabbit CrackMe 解答</title>
      <link href="http://www.vancir.com/2018/02/06/solve-white-habbit-crackme/"/>
      <pubDate>2018-02-06T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/02/06/solve-white-habbit-crackme</guid>
      <content:encoded><![CDATA[<p>Crackme文件可以从此处下载: <a href="https://hshrzd.wordpress.com/2018/02/03/white-rabbit-crackme/">White Rabbit crackme!</a></p>

<p>因为crackme里稍微使用了混淆和一些像恶意程序的把戏, 所以可能会被一些杀毒软件标记为恶意程序, 所以也建议在虚拟机下运行.</p>

<p>这个crackme运行的截图如下:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/1.png" alt="1.png" /></p>

<p>OK, 首先要做的第一件事就是将其载入到IDA中(我这里使用的是刚刚发布的<a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">IDA 7的免费版本</a>). 通过搜索字符串<code class="highlighter-rouge">Password#1</code>来看它的交叉引用以及前后都发生了些什么.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/2.png" alt="2.png" /></p>

<p>就这了! 我们可以看到它被<code class="highlighter-rouge">sub_4034D0</code>所引用. 现在我们将跟随到引用处, 来看看接下来发生什么</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/3.png" alt="3.png" /></p>

<p>在<code class="highlighter-rouge">sub_403D90</code>中有一些初始化操作, 随后在<code class="highlighter-rouge">sub_404150</code>的结果与可疑值<code class="highlighter-rouge">0x57585384</code>的比较后又一个分支跳转. 子分支中的<code class="highlighter-rouge">sub_403990</code>输出了一些提示语以及后续一些有关接受用户输入的内容.</p>

<p>我们首先来看初始化部分(<code class="highlighter-rouge">sub_403D90</code>):</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/4.png" alt="4.png" /></p>

<p>函数取了两个参数, 内容看上去也非常清楚: 通过给出的标识符查找资源文件, 加载资源文件, 确定它的文件大小, 然后申请内存空间并将资源文件的数据复制进去. 该函数返回那个新申请的内存空间的指针, 并将资源文件的大小存储在第一个参数中.</p>

<p>现在我们唯一需要注意的就是图中的<code class="highlighter-rouge">sub_406A70</code>, 它取了3个参数(target pointer, source pointer 以及 data size)并且看起来非常像是<code class="highlighter-rouge">memcpy</code>(或<code class="highlighter-rouge">memmove</code>, 是哪个不重要, 因为内存区域没有重叠). 但是函数内的代码却包含有大量的分支, 难以分析. 所以我们不能确定它有没有在复制的过程中以某种方式修改了数据(比如, 解密数据). 最简便的检查方式就是在调试器里动态分析, 比较函数返回时, <code class="highlighter-rouge">soure</code>和<code class="highlighter-rouge">target</code>内存是否有区别.</p>

<p>我使用<code class="highlighter-rouge">[x64Dbg](https://x64dbg.com/)</code>来分析. 在启动调试器后我们打开crackme, 调试器会自动运行程序并暂停在入口点位置.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/5.png" alt="5.png" /></p>

<p>现在我们需要在我们感兴趣的函数返回处设下一个断点. 指令地址是<code class="highlighter-rouge">0x00403DF9</code>(给定<code class="highlighter-rouge">.text</code>段的基址是<code class="highlighter-rouge">0x00401000</code>). 你可以根据内存布局来了解真正<code class="highlighter-rouge">.text</code>段载入的基址(我这里是<code class="highlighter-rouge">0x00281000</code>). 因此我的实际断点地址应该是<code class="highlighter-rouge">0x00283DF9</code>.</p>

<p>现在我们用<code class="highlighter-rouge">bp 0x00283DF9</code>命令设下断点, 继续执行触发断点. 然后我们右键点击右侧面板<code class="highlighter-rouge">ebx</code>和<code class="highlighter-rouge">edi</code>寄存器的值, 选择在数据窗口跟随. 现在我们就可以确认<code class="highlighter-rouge">sub_406A70</code>仅仅复制了内存<code class="highlighter-rouge">as is</code>, 我们可以放心地将该函数重命名为更易理解的<code class="highlighter-rouge">memcpy</code>. 同样我们也把<code class="highlighter-rouge">sub_403D90</code>重命名为<code class="highlighter-rouge">loadResource</code></p>

<p>现在我们来分析<code class="highlighter-rouge">sub_404150</code></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/6.png" alt="6.png" /></p>

<p>映入眼帘的是一个常量<code class="highlighter-rouge">0x82F63B78</code>. 通过google搜索知道说这是一个用于CRC32计算的多项式值. 代码里看也有从输入缓冲区里对每个字节的值异或累加, 随后再移位/异或8次. 因此它确实是一个<code class="highlighter-rouge">crc32c</code>计算函数.</p>

<p>在重命名和初期的分析后, 我们再来看看改动后的代码</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/7.png" alt="7.png" /></p>

<p>注意: 也许你会对lea/cmovnb指令有些许困惑. 不过很好解释: <code class="highlighter-rouge">lpPasswordText</code>的值实际上是如下的结构体:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="k">static</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">dynamic</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这可能就是栈上<code class="highlighter-rouge">std::string</code>的形式. 当字符串仅有<code class="highlighter-rouge">static</code>数组那么长时, 不会申请额外的内存空间(并且<code class="highlighter-rouge">static</code>缓冲区的地址用<code class="highlighter-rouge">lea</code>加载). 相反如果超出了缓冲区, <code class="highlighter-rouge">cmovnb</code>会获取<code class="highlighter-rouge">dynamic</code>域所分配的内存的指针. 最后, <code class="highlighter-rouge">eax</code>会获得指向真正字符串数据的指针, 不论其位置具体在哪.</p>

<p>因此, <code class="highlighter-rouge">sub_401000</code>读取键盘输入到<code class="highlighter-rouge">std::string</code>, <code class="highlighter-rouge">std::string</code>随后传递给<code class="highlighter-rouge">crc32c</code>函数. 现在我们知道说我们的password应该含有CRC32的<code class="highlighter-rouge">0x57585384</code>, 我们可以根据这个条件判断我们是否获取到了正确的password.</p>

<p>现在我们来假定password跟给出的CRC32值相匹配, 来继续往下分析:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/8.png" alt="8.png" /></p>

<p>有趣的第一点就是<code class="highlighter-rouge">sub_403C90</code>, 因为它同时取了<code class="highlighter-rouge">password</code>和<code class="highlighter-rouge">资源数据</code>作为参数.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/9.png" alt="9.png" /></p>

<p>很显然这里是一个异或加密的操作. 它首先确定<code class="highlighter-rouge">password</code>的长度, 随后用相应的<code class="highlighter-rouge">password</code>字符对输入缓冲区的每一个字节进行异或.</p>

<p>随后生成一个临时文件名, 将解密的资源数据内容写入到该文件(在函数<code class="highlighter-rouge">sub_403090</code>里). 待一切完成, 却也再没有给出任何关于<code class="highlighter-rouge">password</code>的线索了. 我们来看一下<code class="highlighter-rouge">sub_403D20</code>, 该函数接收新创建的文件名并执行了一些操作.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/10.png" alt="10.png" /></p>

<p>OK, 现在事情已经越发清晰. crackme尝试设置新生成的文件作为桌面壁纸, 因此很显然这个文件应该是一个图片.</p>

<p>现在我们要提取crackme里的资源文件, 看看我们能否有所收获. 你可以使用任意的资源编辑软件, 例如: <a href="https://medium.com/@alexskalozub/solving-the-white-rabbit-crackme-d6b627c02ad4">Resource Hacker</a></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/11.png" alt="11.png" /></p>

<p>我们可以看到它的大小是<code class="highlighter-rouge">6,220,854</code>字节, 对于一个图像来说已经很大了, 据此我们猜测, 这是一个无压缩的BMP图像文件.</p>

<p>BMP格式已经是众所周知, 并且有文档说明. 文件起始于一个<code class="highlighter-rouge">"BM"</code>签名, 随后是<code class="highlighter-rouge">4字节</code>的文件大小(小端序), 接着是两个<code class="highlighter-rouge">4字节</code>的保留字(全0), 一个<code class="highlighter-rouge">4字节</code>存储着位图数据的起始位置, 再紧接着是<code class="highlighter-rouge">40字节</code>的位图信息头(起始的是该信息头所占用的字节数). 再下面就是各种关于BMP信息了, 我们现在也不知道.</p>

<p>由于我们得知了真正的文件大小值, 所以我们可以较准确地推测出文件的前18个字节.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>资源文件里的字节:
24 22 5A 80 31 77 5F 64 61 5F 44 61 62 62 41 74 7A 66
期待的结果:
42 4D 36 EC 5E 00 00 00 00 00 36 00 00 00 28 00 00 00
</code></pre></div></div>

<p>现在我们逐个将实际资源文件里的字节和说期望的字节进行异或, 这样我们就可以恢复出部分key的内容. 如果幸运的话, 我们可以获得一个完整的key</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>66 6F 6C 6C 6F 77 5F 64 61 5F 72 61 62 62 69 74 7A 66
</code></pre></div></div>

<p>异或得到的结果是<code class="highlighter-rouge">"follow_da_rabbitzf"</code>. 最后的这一个<code class="highlighter-rouge">"f"</code>也许是重复的下一个key的起始字母, 也许就是这个key的一部分. 最简单的检查方法就是将其输入到crackme里看看结果如何.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/12.png" alt="12.png" /></p>

<p>Yeah. 我们的结果是正确的. 我们再继续.</p>

<p>现在我们有一个超酷的桌面壁纸, 然后还有另外一个<code class="highlighter-rouge">password</code>需要破解出来. 我们再次搜索<code class="highlighter-rouge">"Password#2"</code>字符串并跟随到交叉引用处:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/13.png" alt="13.png" /></p>

<p>这看起来跟之前非常相似, 因此我们自己向下来到解密开始的部分:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/14.png" alt="14.png" /></p>

<p>有趣的部分在<code class="highlighter-rouge">sub_403E10</code>, 这里在写入数据到文件之前进行了解密:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/15.png" alt="15.png" /></p>

<p>这里根据<code class="highlighter-rouge">password</code>导出一个<code class="highlighter-rouge">AES128</code>的密钥(使用<code class="highlighter-rouge">SHA256</code>作为密钥导出算法)并用于解密资源数据.</p>

<p>没有必要去破解AES加密(恐怕就连NSA也无法破解), 我们只知道<code class="highlighter-rouge">password</code>的crc32值. 很显然不足以通过暴力破解的手段来获取它(我尝试过!). 但等等, 我们有一个壁纸啊! 或许在壁纸里会有某些隐藏的信息!</p>

<p>用图像编辑器打开并使用”颜色选择”工具:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/16.png" alt="16.png" /></p>

<p>这应该就是我们一直在寻找的key! 接下来继续:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/17.png" alt="17.png" /></p>

<p>但是事情还没结束. 现在我们在临时目录下有一个解密过的可执行文件, 但我们还是没有拿到flag. 我们还需要用IDA继续分析.</p>

<p>因为第二个可执行文件按并没有产生任何字符串信息, 也就难以下手. 我们就来看看导入表情况:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/18.png" alt="18.png" /></p>

<p>这里有一系列的按顺序导入的<code class="highlighter-rouge">ws2_32.dll</code>的函数, 这给我们两个线索:</p>

<ul>
  <li>程序有在进行网络socket操作</li>
  <li>程序有隐藏些什么!</li>
</ul>

<p>因此我们的第一步就是去到这些函数被调用的地方, 并将这些函数重命名为可读性更高更有意义的名称. 序号与之对应的函数名称可以很容易地通过google搜索找到.</p>

<p>现在我们知道了所有的网络操作都在<code class="highlighter-rouge">sub_404480</code>里, 因此接下来仔细看看这个函数. 该函数开始是一个标准流程(<code class="highlighter-rouge">WSAStartup/socket/bind/listen</code>), 所以没太多亮点, 有趣的部分在下图:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/19.png" alt="19.png" /></p>

<p>因此它等待接受一个连接, 从连接中读取4字节, 基于静态缓冲区<code class="highlighter-rouge">buf</code>和接收的数据在<code class="highlighter-rouge">sub_404640</code>中执行一些操作. 如果操作成功转型(函数返回非零值), 它就会将<code class="highlighter-rouge">buf</code>的内容发回给客户端随后关闭连接. 否则它会关闭连接监听新的连接. 所有的操作都是同步的, 所以在<code class="highlighter-rouge">sub_404640</code>成功执行前不会退出函数.</p>

<p>来看看<code class="highlighter-rouge">sub_404640</code>的内容:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/20.png" alt="20.png" /></p>

<p>看起来非常像是一个小的状态机, 成功转移到下一状态时返回1, 有如下几个转移:</p>

<ul>
  <li>从 初始状态(0) 到 ‘Y’ 状态 (如果接收到9)</li>
  <li>从 ‘Y’ 状态 到 ‘E’ 状态 (如果接收到3)</li>
  <li>从 ‘E’ 状态 到 ‘S’ 状态 (如果接收到5)</li>
  <li>接收到其他的任何值, 都会将状态机重置为 初始状态(0)</li>
</ul>

<p>因此, 我们可能需要按顺序发起3个连接, 连到<code class="highlighter-rouge">"server"</code>, 更新状态机到下一状态.</p>

<p>但是我们仍有两个问题需要解决:</p>

<ol>
  <li>我们不知道需要连接到哪一个端口(函数需要取端口号作参数)</li>
  <li>在每次成功转移状态后, 监听的套接字都会关闭</li>
</ol>

<p>因此我们需要找到所有的函数被调用的地方, 然后跟踪看它启动了哪一个端口.</p>

<p>如同我们所预料的那样, 函数被调用了3次(因为有3次合法的状态转移), 并且幸运的是, 它都是在同一个步骤里被调用的:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/21.png" alt="21.png" /></p>

<p>在这里</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/22.png" alt="22.png" /></p>

<p>所以, server一开始开启了端口<code class="highlighter-rouge">1337</code>, 随后是<code class="highlighter-rouge">1338</code>, 最后是<code class="highlighter-rouge">1339</code>. 因此我们首先需要连接到<code class="highlighter-rouge">1337</code>端口并发送<code class="highlighter-rouge">9</code>, 然后连接到<code class="highlighter-rouge">1338</code>端口, 发送<code class="highlighter-rouge">3</code>. 最后连接到<code class="highlighter-rouge">1339</code>端口, 发送<code class="highlighter-rouge">5</code>. 我们可以使用内置的<code class="highlighter-rouge">telnet</code>工具来完成这一操作.</p>

<p>完成上述操作后会打开一个简短视频的YouTube页面:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/23.png" alt="23.png" /></p>

<p>我们成功地拿到了flag. 收工回家!</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Unicorn Engine简介</title>
      <link href="http://www.vancir.com/2018/01/26/unicorn-intro/"/>
      <pubDate>2018-01-26T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/01/26/unicorn-intro</guid>
      <content:encoded><![CDATA[<h2 id="什么是unicorn引擎">什么是Unicorn引擎</h2>

<p>Unicorn是一个轻量级, 多平台, 多架构的CPU模拟器框架. 我们可以更好地关注CPU操作, 忽略机器设备的差异. 想象一下, 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的CPU去完成那些操作, 又或者想要更安全地分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义. 使用CPU模拟器可以很好地帮助我们提供便捷.</p>

<p>它的亮点(这也归功于Unicorn是基于<a href="http://www.qemu.org">qemu</a>而开发的)有:</p>

<ul>
  <li>支持多种架构: Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64).</li>
  <li>对Windows和*nix系统(已确认包含Mac OSX, Linux, *BSD &amp; Solaris)的原生支持</li>
  <li>具有平台独立且简洁易于使用的API</li>
  <li>使用JIT编译技术, 性能表现优异</li>
</ul>

<p>你可以在<a href="http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf">Black Hat USA 2015</a>获悉有关Unicorn引擎的更多技术细节. Github项目主页: <a href="https://github.com/unicorn-engine/unicorn">unicorn</a></p>

<p>尽管它不同寻常, 但它无法模拟整个程序或系统, 也不支持系统调用. 你需要手动映射内存并写入数据进去, 随后你才能从指定地址开始模拟.</p>

<h2 id="应用的情景">应用的情景</h2>

<p>什么时候能够用到Unicorn引擎呢?</p>

<ul>
  <li>你可以调用恶意软件中一些有趣的函数, 而不用创建一个有害的进程.</li>
  <li>用于CTF竞赛</li>
  <li>用于模糊测试</li>
  <li>用于gdb插件, 基于代码模拟执行的插件</li>
  <li>模拟执行一些混淆代码</li>
</ul>

<h2 id="如何安装">如何安装</h2>

<p>安装Unicorn最简单的方式就是使用pip安装, 只要在命令行中运行以下命令即可(这是适合于喜爱用python的用户的安装方法, 对于那些想要使用C的用户, 则需要去官网查看文档编译源码包):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install unicorn
</code></pre></div></div>

<p>但如果你想用源代码进行本地编译的话, 你需要在<a href="http://www.unicorn-engine.org/download/">下载</a>页面中下载源代码包, 然后可以按照以下命令执行:</p>

<ul>
  <li>*nix 平台用户</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>bindings/python
<span class="nv">$ </span><span class="nb">sudo </span>make install
</code></pre></div></div>

<ul>
  <li>Windows平台用户</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>bindings/python
python setup.py install
</code></pre></div></div>

<p>对于Windows, 在执行完上述命令后, 还需要将<a href="http://www.unicorn-engine.org/download/">下载</a>页面的<code class="highlighter-rouge">Windows core engine</code>的所有dll文件复制到<code class="highlighter-rouge">C:\locationtopython\Lib\site-packages\unicorn</code>位置处.</p>

<h2 id="使用unicorn的快速指南">使用unicorn的快速指南</h2>

<p>我们将会展示如何使用python调用unicorn的api以及它是如何轻易地模拟二进制代码. 当然这里用的api仅是一小部分, 但对于入门已经足够了.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">1</span> <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
 <span class="mi">2</span> <span class="kn">from</span> <span class="nn">unicorn</span> <span class="kn">import</span> <span class="o">*</span>
 <span class="mi">3</span> <span class="kn">from</span> <span class="nn">unicorn.x86_const</span> <span class="kn">import</span> <span class="o">*</span>
 <span class="mi">4</span> 
 <span class="mi">5</span> <span class="c"># code to be emulated</span>
 <span class="mi">6</span> <span class="n">X86_CODE32</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x41\x4a</span><span class="s">"</span> <span class="c"># INC ecx; DEC edx</span>
 <span class="mi">7</span> 
 <span class="mi">8</span> <span class="c"># memory address where emulation starts</span>
 <span class="mi">9</span> <span class="n">ADDRESS</span> <span class="o">=</span> <span class="mh">0x1000000</span>
<span class="mi">10</span> 
<span class="mi">11</span> <span class="k">print</span><span class="p">(</span><span class="s">"Emulate i386 code"</span><span class="p">)</span>
<span class="mi">12</span> <span class="k">try</span><span class="p">:</span>
<span class="mi">13</span>     <span class="c"># Initialize emulator in X86-32bit mode</span>
<span class="mi">14</span>     <span class="n">mu</span> <span class="o">=</span> <span class="n">Uc</span><span class="p">(</span><span class="n">UC_ARCH_X86</span><span class="p">,</span> <span class="n">UC_MODE_32</span><span class="p">)</span>
<span class="mi">15</span> 
<span class="mi">16</span>     <span class="c"># map 2MB memory for this emulation</span>
<span class="mi">17</span>     <span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
<span class="mi">18</span> 
<span class="mi">19</span>     <span class="c"># write machine code to be emulated to memory</span>
<span class="mi">20</span>     <span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="n">X86_CODE32</span><span class="p">)</span>
<span class="mi">21</span> 
<span class="mi">22</span>     <span class="c"># initialize machine registers</span>
<span class="mi">23</span>     <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_ECX</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">)</span>
<span class="mi">24</span>     <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_EDX</span><span class="p">,</span> <span class="mh">0x7890</span><span class="p">)</span>
<span class="mi">25</span> 
<span class="mi">26</span>     <span class="c"># emulate code in infinite time &amp; unlimited instructions</span>
<span class="mi">27</span>     <span class="n">mu</span><span class="o">.</span><span class="n">emu_start</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="n">ADDRESS</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">X86_CODE32</span><span class="p">))</span>
<span class="mi">28</span> 
<span class="mi">29</span>     <span class="c"># now print out some registers</span>
<span class="mi">30</span>     <span class="k">print</span><span class="p">(</span><span class="s">"Emulation done. Below is the CPU context"</span><span class="p">)</span>
<span class="mi">31</span> 
<span class="mi">32</span>     <span class="n">r_ecx</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_ECX</span><span class="p">)</span>
<span class="mi">33</span>     <span class="n">r_edx</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_EDX</span><span class="p">)</span>
<span class="mi">34</span>     <span class="k">print</span><span class="p">(</span><span class="s">"&gt;&gt;&gt; ECX = 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span><span class="n">r_ecx</span><span class="p">)</span>
<span class="mi">35</span>     <span class="k">print</span><span class="p">(</span><span class="s">"&gt;&gt;&gt; EDX = 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span><span class="n">r_edx</span><span class="p">)</span>
<span class="mi">36</span> 
<span class="mi">37</span> <span class="k">except</span> <span class="n">UcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="mi">38</span>     <span class="k">print</span><span class="p">(</span><span class="s">"ERROR: </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果如下:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python test1.py 
Emulate i386 code
Emulation <span class="k">done</span><span class="nb">.</span> Below is the CPU context
<span class="o">&gt;&gt;&gt;</span> ECX <span class="o">=</span> 0x1235
<span class="o">&gt;&gt;&gt;</span> EDX <span class="o">=</span> 0x788f
</code></pre></div></div>

<p>样例里的注释已经非常直观, 但我们还是对每一行代码做出解释:</p>
<ul>
  <li>行号2~3: 在使用Unicorn前导入<code class="highlighter-rouge">unicorn</code>模块. 样例中使用了一些x86寄存器常量, 所以也需要导入<code class="highlighter-rouge">unicorn.x86_const</code>模块</li>
  <li>行号6: 这是我们需要模拟的二进制机器码, 使用十六进制表示, 代表的汇编指令是: “INC ecx” 和 “DEC edx”.</li>
  <li>行号9: 我们将模拟执行上述指令的所在虚拟地址</li>
  <li>行号14: 使用<code class="highlighter-rouge">Uc</code>类初始化Unicorn, 该类接受2个参数: 硬件架构和硬件位数(模式). 在样例中我们需要模拟执行x86架构的32位代码, 我们使用变量<code class="highlighter-rouge">mu</code>来接受返回值.</li>
  <li>行号17: 使用<code class="highlighter-rouge">mem_map </code>方法根据在行号9处声明的地址, 映射2MB用于模拟执行的内存空间. 所有进程中的CPU操作都应该只访问该内存区域. 映射的内存具有默认的读,写和执行权限.</li>
  <li>行号20: 将需要模拟执行的代码写入我们刚刚映射的内存中. <code class="highlighter-rouge">mem_write</code>方法接受2个参数: 要写入的内存地址和需要写入内存的代码.</li>
  <li>行号23~24: 使用<code class="highlighter-rouge">reg_write</code>方法设置<code class="highlighter-rouge">ECX</code>和<code class="highlighter-rouge">EDX</code>寄存器的值</li>
  <li>行号27: 使用<code class="highlighter-rouge">emu_start</code>方法开始模拟执行, 该API接受4个参数: 要模拟执行的代码地址, 模拟执行停止的内存地址(这里是<code class="highlighter-rouge">X86_CODE32</code>的最后1字节处), 模拟执行的时间和需要执行的指令数目. 如果我们像样例一样忽略后两个参数, Unicorn将会默认以无穷时间和无穷指令数目的条件来模拟执行代码.</li>
  <li>行号32~35: 打印输出<code class="highlighter-rouge">ECX</code>和<code class="highlighter-rouge">EDX</code>寄存器的值. 我们使用函数<code class="highlighter-rouge">reg_read</code>来读取寄存器的值.</li>
</ul>

<p>要想查看更多的python示例, 可以查看文件夹<a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings/python">bindings/python</a>下的代码. 而C的示例则可以查看<a href="https://github.com/unicorn-engine/unicorn/tree/master/samples">sample</a>文件夹下的代码.</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="http://www.unicorn-engine.org/">Unicorn Official Site</a></li>
  <li><a href="http://www.unicorn-engine.org/docs/">Quick tutorial on programming with Unicorn - with C &amp; Python.</a></li>
  <li><a href="http://eternal.red/2018/unicorn-engine-tutorial/">Unicorn Engine tutorial</a></li>
  <li><a href="https://platform.avatao.com/paths/8e720072-9169-4d4c-9569-c330ce7fd947/challenges/28f5ae81-6a01-11e6-bdf4-0800200c9a66">Avatao tool tutorials: Unicorn</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>pyc文件结构</title>
      <link href="http://www.vancir.com/2018/01/21/pyc-structure/"/>
      <pubDate>2018-01-21T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/01/21/pyc-structure</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>原文链接: <a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">The structure of .pyc files</a></p>
</blockquote>

<p>简单来说, 一个pyc文件包含以下三块</p>
<ul>
  <li>一个4字节的魔数(magic number)</li>
  <li>一个4直接的修改时间戳(modification timestamp)</li>
  <li>一个编排过的代码对象</li>
</ul>

<p>对于各个版本的python解释器, magic number都各不相同, 对于python 2.5则是<code class="highlighter-rouge">b3f20d0a</code></p>

<p>修改时间戳则是源文件生成.pyc文件的Unix修改时间戳, 当源文件改变的时候, 该值也会变化</p>

<p>整个文件剩下的部分则是在编译源文件产生的代码对象编排后的输出. marshal跟python的pickle类似, 它对python对象进行序列化操作. 不过marshal和pickle的目标不同. pickle目的在于产生一个持久的独立于版本的序列化, 而marshal则是为了短暂地序列化对象, 因此它的表示会随着python版本二改变.</p>

<p>而且, pickle被设计用于适用用户定义的类型, 而marshal这时用于处理python内部类型的复杂结构</p>

<p>marshal的特性给出了pyc文件的重要特征: 它对平台独立, 但依赖于python版本. 一个2.4版本的pyc文件不能在2.5版本下执行, 但是它可以很好地移植到不同操作系统里.</p>

<p>接下来的部分也简单: 对于两个长整数和一个marshalled的代码对象, 复杂点在于代码对象的结构. 它们包含有编译器禅师的各种信息, 其中内容最丰富的这是字节码本身.</p>

<p>所幸有了marshal和dis模块, 编写程序导出这些信息并不会很难.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span><span class="p">,</span> <span class="n">marshal</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">types</span>

<span class="k">def</span> <span class="nf">show_file</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
    <span class="n">magic</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">moddate</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">modtime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'L'</span><span class="p">,</span> <span class="n">moddate</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">print</span> <span class="s">"magic </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">magic</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">))</span>
    <span class="k">print</span> <span class="s">"moddate </span><span class="si">%</span><span class="s">s (</span><span class="si">%</span><span class="s">s)"</span> <span class="o">%</span> <span class="p">(</span><span class="n">moddate</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">),</span> <span class="n">modtime</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">show_code</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
     
<span class="k">def</span> <span class="nf">show_code</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">scode"</span> <span class="o">%</span> <span class="n">indent</span>
    <span class="n">indent</span> <span class="o">+=</span> <span class="s">'   '</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sargcount </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_argcount</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">snlocals </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_nlocals</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sstacksize </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_stacksize</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sflags </span><span class="si">%04</span><span class="s">x"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_flags</span><span class="p">)</span>
    <span class="n">show_hex</span><span class="p">(</span><span class="s">"code"</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_code</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">)</span>
    <span class="n">dis</span><span class="o">.</span><span class="n">disassemble</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sconsts"</span> <span class="o">%</span> <span class="n">indent</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">code</span><span class="o">.</span><span class="n">co_consts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">const</span><span class="p">)</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">CodeType</span><span class="p">:</span>
            <span class="n">show_code</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">indent</span><span class="o">+</span><span class="s">'   '</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"   </span><span class="si">%</span><span class="s">s</span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">snames </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_names</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">svarnames </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sfreevars </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_freevars</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">scellvars </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_cellvars</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sfilename </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sname </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sfirstlineno </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">)</span>
    <span class="n">show_hex</span><span class="p">(</span><span class="s">"lnotab"</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_lnotab</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">)</span>
     
<span class="k">def</span> <span class="nf">show_hex</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">s</span><span class="si">%</span><span class="s">s </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">s</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">60</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">s   </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">60</span><span class="p">])</span>

<span class="n">show_file</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<p>我们使用这段代码, 来处理一个极简单的python文件生成的pyc文件:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">if</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="n">a</span>
</code></pre></div></div>

<p>产生的结果如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>magic b3f20d0a
moddate 8a9efc47 (Wed Apr 09 06:46:34 2008)
code
   argcount 0
   nlocals 0
   stacksize 2
   flags 0040
   code
      6404005c02005a00005a0100650000700700016501006f0d000164020047
      65000047486e01000164030053
  1           0 LOAD_CONST               4 ((1, 0))
              3 UNPACK_SEQUENCE          2
              6 STORE_NAME               0 (a)
              9 STORE_NAME               1 (b)

  2          12 LOAD_NAME                0 (a)
             15 JUMP_IF_TRUE             7 (to 25)
             18 POP_TOP
             19 LOAD_NAME                1 (b)
             22 JUMP_IF_FALSE           13 (to 38)
        &gt;&gt;   25 POP_TOP

  3          26 LOAD_CONST               2 ('Hello')
             29 PRINT_ITEM
             30 LOAD_NAME                0 (a)
             33 PRINT_ITEM
             34 PRINT_NEWLINE
             35 JUMP_FORWARD             1 (to 39)
        &gt;&gt;   38 POP_TOP
        &gt;&gt;   39 LOAD_CONST               3 (None)
             42 RETURN_VALUE
   consts
      1
      0
      'Hello'
      None
      (1, 0)
   names ('a', 'b')
   varnames ()
   freevars ()
   cellvars ()
   filename 'C:\\ned\\sample.py'
   name '&lt;module&gt;'
   firstlineno 1
   lnotab 0c010e01
</code></pre></div></div>

<p>有很多内容我们都不明白, 但是字节码却很好地被反汇编并呈现了出来. python虚拟机是一个面向栈的解释器, 因此有许多操作都是load和pop, 并且当然也有很多jump和条件判断. 字节码的解释器则是在<a href="https://github.com/python/cpython/blob/master/Python/ceval.c"><code class="highlighter-rouge">ceval.c</code></a>中实现, 对于字节码的具体改变则会依赖于python的主版本. 比如<code class="highlighter-rouge">PRINT_ITEM </code>和<code class="highlighter-rouge">PRINT_NEWLINE</code>在python 3中则被去掉了.</p>

<p>在反汇编的输出中, 最左的数字(1,2,3)是源文件中的行号, 而接下来的数字(0,3,6,9)这是指令中的字节偏移. 指令的操作数这是直接用数字呈现, 而在括号内的这是符号性的解释. <code class="highlighter-rouge">&gt;&gt;</code>所表示的行实际上是代码中某处跳转指令的目标地址.</p>

<p>我们这个样例非常简单, 它只是一个模块中单一的代码对象中的指令流程. 在现实中有着类和函数定义的模块会十分复杂. 那些类和函数本身就是const列表中的代码对象, 在模块中进行了足够深的嵌套.</p>

<p>一旦你开始在这个级别挖掘, 会发现有各种各样适用于代码对象的工具. 在标准库中有内置的<a href="http://docs.python.org/lib/built-in-funcs.html#l2h-18">compile</a>函数, 以及<a href="http://docs.python.org/lib/module-compiler.html">compiler</a>, <a href="http://docs.python.org/lib/module-codeop.html">codeop</a>和<a href="http://docs.python.org/lib/bytecodes.html">opcode</a>模块. 在真实场景中会有很多第三方包比如<a href="http://www.aminus.org/rbre/python/index.html">codewalk</a>, <a href="http://wiki.python.org/moin/ByteplayDoc">byteplay</a>和<a href="http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html">bytecodehacks</a>等. <a href="https://www.python.org/dev/peps/pep-0339/">PEP 339</a>给出了有关编译和操作码的更多详细信息. 最后</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用WinAppDbg解决Flareon第3题</title>
      <link href="http://www.vancir.com/2017/12/24/flareon4-3-winappdbg/"/>
      <pubDate>2017-12-24T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2017/12/24/flareon4-3-winappdbg</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223525.htm">https://bbs.pediy.com/thread-223525.htm</a></p>
</blockquote>

<p>文章作者: Parsia’s Den</p>

<p>博客地址: <a href="https://parsiya.net/">https://parsiya.net/</a></p>

<p>原文链接: <a href="https://parsiya.net/blog/2017-11-15-winappdbg---part-4---bruteforcing-flareon-2017---challenge-3/#bruteforcing-in-action">WinAppDbg - Part 4 - Bruteforcing FlareOn 2017 - Challenge 3</a></p>

<p>翻译前言: 这是解决Flareon4第3题的第4种方法, 也是这个系列翻译的完结篇. 作者用的WinAppDbg跟ODScript有类似的感觉, 虽然不及之前2篇让人耳目一新, 但这是作者对于WinAppDbg写的简易教程的第4篇, 如果感兴趣可以点击原文链接从其它3篇WinAppDbg的教程开始阅读.</p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<p>如果朋友想看我之前翻译的用其他3种全新的方法解决该题的文章, 可以点击以下链接:</p>

<ol>
  <li><a href="http://vancir.com/2017/12/21/flareon4-3/">Flareon challenge 4 第3题</a></li>
  <li><a href="http://vancir.com/2017/12/22/flareon4-3-libpeconv/">使用libPeConv来解决Flareon4题目3</a></li>
  <li><a href="http://vancir.com/2017/12/23/flareon4-3-angr/">使用Angr解决Flareon4题目3</a></li>
</ol>

<h2 id="侦查">侦查</h2>

<p>首先我们要运行<code class="highlighter-rouge">strings</code>程序分析文件. 在Windows我喜欢从以下两种方式获取<code class="highlighter-rouge">strings</code></p>

<ul>
  <li>从Cygwin的binutils包获取strings</li>
  <li>从微软Sysinternals套件获取strings
运行<code class="highlighter-rouge">strings</code>我们获得下图:</li>
  <li><code class="highlighter-rouge">-nobanner</code>: 不要显示启动时的标语和版权信息</li>
  <li><code class="highlighter-rouge">-o</code>: 打印字符串偏移(如果想要找寻字符串地址这会很有帮助)</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; .\SysinternalsSuite\strings.exe -o -nobanner .\3-GreektoMe\greek_to_me.exe
0077:!This program cannot be run in DOS mode.
0176:Rich
0432:.text
0472:.rdata
...
1584:Nope, that's not it.
1608:Congratulations! But wait, where's my flag?
1652:127.0.0.1
1752:WS2_32.dll
</code></pre></div></div>

<p><code class="highlighter-rouge">ws2_32.dll</code>是Windows套接字库, 故程序中有着网络活动.</p>

<p>说个有趣的题外话, 当我在搜索这个DLL时我发现以下这个链接:</p>

<ul>
  <li><a href="https://nakedsecurity.sophos.com/2009/10/12/windows-ws232dll-file-safe/">Is Your Windows “ws2_32.dll” File Safe?</a></li>
</ul>

<p>回归正题, <code class="highlighter-rouge">127.0.0.1</code>表明程序有网络活动, 表明它尝试连接或监听本地端口.</p>

<p>为了进一步探明, 我们运行<code class="highlighter-rouge">procmon</code>或<code class="highlighter-rouge">wireshark</code></p>

<ul>
  <li>Procmon过滤条件:
    <ul>
      <li>进程名是<code class="highlighter-rouge">greek_to_me.exe</code></li>
      <li>操作是<code class="highlighter-rouge">TCP/UDP</code>连接</li>
    </ul>
  </li>
  <li>Wireshark:
    <ul>
      <li>使用npcap抓取Windows回环流量</li>
      <li><a href="https://wiki.wireshark.org/CaptureSetup/Loopback">https://wiki.wireshark.org/CaptureSetup/Loopback</a></li>
    </ul>
  </li>
</ul>

<p>什么都没有显示. 故程序是在进行本地监听.</p>

<p>运行程序并以管理员身份运行命令行, 输入<code class="highlighter-rouge">netstat -anb</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> TCP    127.0.0.1:2222         0.0.0.0:0              LISTENING       5816
[greek_to_me.exe]
</code></pre></div></div>

<p>程序正在监听本地端口2222</p>

<h2 id="简短分析">简短分析</h2>

<p>程序监听端口2222, 当接收到数据, 它使用了我们输入的第1个字节(也就只用了第1个字节). 如下所示:</p>

<pre><code class="language-asm">.text:00401029 loc_401029:      ; CODE XREF: sub_401008+1A
.text:00401029          mov     ecx, offset loc_40107C
.text:0040102E          add     ecx, 79h
.text:00401031          mov     eax, offset loc_40107C
.text:00401036          mov     dl, [ebp+buf]   ; first byte of input moved to dl
</code></pre>

<p>现在dl指向着我们发送给socket的第1个字节</p>

<pre><code class="language-asm">.text:00401039 loc_401039:      ; CODE XREF: sub_401008+3D
.text:00401039          mov     bl, [eax]   ; bl = grab a byte from blob
.text:0040103B          xor     bl, dl      ; bl = blob_byte xor our_first_byte
.text:0040103D          add     bl, 22h     ; bl += 0x22
.text:00401040          mov     [eax], bl   ; *eax = bl
.text:00401042          inc     eax         ; eax++ (next char)
.text:00401043          cmp     eax, ecx    ; ecx is the address of the second section
.text:00401045          jl      short loc_401039 ; check if we have reached the next section
</code></pre>

<p>它抓取了一些数据(准确说是<code class="highlighter-rouge">0x79</code>或121字节), 使用我们的第1个字节跟其异或随后加上<code class="highlighter-rouge">0x22</code>. 取出的数据则是位于<code class="highlighter-rouge">loc40107C</code>偏移处的十六进制块.</p>

<pre><code class="language-asm">33 E1 C4 99 11 06 81 16 F0 32 9F C4 91 17 06 81
14 F0 06 81 15 F1 C4 91 1A 06 81 1B E2 06 81 18
F2 06 81 19 F1 06 81 1E F0 C4 99 1F C4 91 1C 06
81 1D E6 06 81 62 EF 06 81 63 F2 06 81 60 E3 C4
99 61 06 81 66 BC 06 81 67 E6 06 81 64 E8 06 81
65 9D 06 81 6A F2 C4 99 6B 06 81 68 A9 06 81 69
EF 06 81 6E EE 06 81 6F AE 06 81 6C E3 06 81 6D
EF 06 81 72 E9 06 81 73 7C
</code></pre>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/01-crypto.png" alt="xor_add.png" /></p>

<p>随后修改的数据块(在异或和加法操作后)传递给<code class="highlighter-rouge">sub_4011E6</code>并继续处理:</p>

<pre><code class="language-asm">.text:00401047          mov     eax, offset loc_40107C  ; eax = *modified_blob
.text:0040104C          mov     [ebp+var_C], eax        ; varC = eax
.text:0040104F          push    79h                     ; length of modified_blob
.text:00401051          push    [ebp+var_C]
.text:00401054          call    sub_4011E6              ; sub_4011E6(*modified_blob, 0x79)
.text:00401059          pop     ecx
.text:0040105A          pop     ecx
.text:0040105B          movzx   eax, ax
.text:0040105E          cmp     eax, 0FB5Eh ; compare return value with 0xFB5E

.text:00401063          jz      short loc_40107C
.text:00401065          push    0               ; flags
.text:00401067          push    14h             ; len
.text:00401069          push    offset buf      ; "Nope, that's not it."
.text:0040106E          push    [ebp+s]         ; s
.text:00401071          call    ds:send
.text:00401077          jmp     loc_401107
</code></pre>

<p><code class="highlighter-rouge">sub_4011E6</code>的返回值跟<code class="highlighter-rouge">0xFB5E</code>进行比较, 如果不匹配, <code class="highlighter-rouge">jz</code>跳转将不会实现并继续执行, 程序也会传回来<code class="highlighter-rouge">Nope, that's not it.</code>.</p>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/02-result-comparison.png" alt="nope.png" /></p>

<p>现在就变得越发有趣了. 如果结果匹配, 它就会跳转到我们刚刚修改过的数据块并试图将其作为代码执行. 如果程序没有崩溃且运行到结尾, 那么它就会发送回来<code class="highlighter-rouge">Congratulations!</code>.</p>

<p>换句话说, 我们输入的第1个字节就是用来将那数据块转换成正确的汇编操作码.</p>

<p>现在我们应该用另外一种方式来解决该题. 我想所有人都会用打开套接字, 发送256个可能字节并查看结果的方法来解决它. 这确实可以解决这个问题.</p>

<h2 id="使用winappdbg暴力穷举">使用WinAppDbg暴力穷举</h2>

<p>我使用另外一种方法解决. 复现这个方法我们需要了解一点点WinAppDbg的知识.</p>

<h2 id="winappdbg设置断点">WinAppDbg设置断点</h2>

<p>WinAppDng允许我们在任意地址设置断点:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">debug</span><span class="o">.</span><span class="n">break_at</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">action_callback</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">action_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="c"># do something</span>
</code></pre></div></div>

<p>当断点触发, <code class="highlighter-rouge">action_callback</code>函数就会被调用</p>

<p>更多信息请看:</p>

<ul>
  <li><a href="https://winappdbg.readthedocs.io/en/latest/Debugging.html?highlight=break_at#example-11-setting-a-breakpoint">Documentation - Example #11: setting a breakpoint</a></li>
  <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/breakpoint.py#L3905">breakpoint.py source code</a></li>
</ul>

<h2 id="获取和设置内存">获取和设置内存</h2>

<p>WinAppDbg运行我们存储/恢复内存和上下文</p>

<ul>
  <li>获取内存: <code class="highlighter-rouge">memory = process.take_memory_snapshot()</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3261">take_memory_snapshot 源码</a></li>
    </ul>
  </li>
  <li>设置内存: <code class="highlighter-rouge">process.restore_memory_snapshot(memory, bSkipMappedFiles=True)</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3301">restore_memory_snapshot 源码</a></li>
      <li>通常来说, 请总是保持<code class="highlighter-rouge">bSkipMappedFiles</code>为<code class="highlighter-rouge">True</code>, 否则你会得到一个内存地址错误
        <ul>
          <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3317">Explanation of bSkipMappedFiles in source</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="获取和设置上下文">获取和设置上下文</h2>

<p>上下文包含寄存器和各种标志值, 是逐线程(而非逐进程的)</p>

<ul>
  <li>获取上下文: <code class="highlighter-rouge">context = thread.get_context()</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/thread.py#L469">get_context 源码</a></li>
      <li>处理上下文中的寄存器:
        <ul>
          <li><code class="highlighter-rouge">context["Edx"] = 0x1234</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>设置上下文: <code class="highlighter-rouge">thread.set_context(context)</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/thread.py#L570">set_context 源码</a></li>
    </ul>
  </li>
</ul>

<p>注意: 在设置完上下文后, 我们需要手动修改指令指针指向一个开始执行的具体位置. 比如说如果我们获取了上下文, 改变<code class="highlighter-rouge">Eip</code>指向一个地址, 实际的指令指针并不会变化. 我们在设置完上下文后, 需要使用<code class="highlighter-rouge">thread.set_pc(address)</code>手动将指令指针改成你需要的地址.</p>

<p>在进行内存和上下文的操作时, 请确保事先暂停了程序/线程, 在操作完成后再恢复.</p>

<h2 id="作战计划">作战计划</h2>

<p>现在我们有了建筑模块, 我们需要制定一个作战计划. 非常简单明了.</p>

<ol>
  <li>运行程序</li>
  <li>在<code class="highlighter-rouge">0x401036</code>和<code class="highlighter-rouge">0x40105B</code>设置断点</li>
  <li>打开socket并发送任何可能的字节</li>
  <li>在<code class="highlighter-rouge">0x401036</code>的断点
    <ul>
      <li>如果是第1次触发断点:
        <ul>
          <li>保存内存,上下文和<code class="highlighter-rouge">0x40107C</code>的数据块</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">context["Edx"] = key</code> - 交换key值</li>
      <li>key++</li>
      <li>绕过key的赋值指令并使用<code class="highlighter-rouge">thread.set_pc(0x401039)</code>手动跳转到<code class="highlighter-rouge">0x401039</code></li>
    </ul>
  </li>
  <li>在<code class="highlighter-rouge">0x40105B</code>的断点:
    <ul>
      <li>如果函数返回值是<code class="highlighter-rouge">0xFB5E</code>, 则打印key值</li>
      <li>否则:
        <ul>
          <li>复原内存, 上下文和<code class="highlighter-rouge">0x40107C</code>处的数据块(数据块已经被修改过了, 因此这里需要复原成原来的字节)</li>
          <li>使用<code class="highlighter-rouge">thread.set_pc(0x401036)</code>返回到<code class="highlighter-rouge">0x401036</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/03-bruteforcer-1.png" alt="plan.png" /></p>

<p>改变<code class="highlighter-rouge">buf</code>中第1个字节会比<code class="highlighter-rouge">edx</code>中更简单些, 而且能够避免途中标签2对应的跳转.</p>

<h2 id="开始暴力穷举">开始暴力穷举</h2>

<p>我们使用的脚本是<a href="https://github.com/parsiya/Parsia-Clone/blob/master/code/winappdbg/19-GreekToMe.py"><code class="highlighter-rouge">19-GreekToMe.py</code></a>, 你需要将<code class="highlighter-rouge">greek_to_me.exe</code>放在脚本的同一目录下, 该程序可以在附件里下载.</p>

<p>脚本运行非常快,因为我们的穷举空间仅仅只有1字节(0x00到0xFF)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python 19-GreekToMe.py
[21:23:48.0743] Starting simple_debugger
[21:23:48.0753] Started simple_debugger. Sleeping for 2 seconds.
[21:23:50.0756] Starting send_me.
[21:23:50.0875] Socket connected
[21:23:50.0875] Sent 0
[21:23:53.0490]
-------------------------------------------------------------------------------
Key: 0xa2
Eax: 0000FB5E
[21:23:54.0901] Reached 0x100
</code></pre></div></div>

<h2 id="flag">Flag</h2>

<p>重新在调试器中运行程序, 在”Congratulations!”处设下断点然后重新发送<code class="highlighter-rouge">0xA2</code>, 数据块正确解密, 我们也获得了flag</p>

<p><em>flag: et_tu_brute_force@flare-on.com</em></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
