<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>Heap Exploitation系列翻译-06 Core functions</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>Heap Exploitation系列翻译-06 Core functions</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2017-08-10">2017-08-10</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#translations" title="translations">translations</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#CTF" title="CTF">CTF</a>&nbsp;
  
  <a href="/tags/#pwn" title="pwn">pwn</a>&nbsp;
  
  <a href="/tags/#heap" title="heap">heap</a>&nbsp;
  
</span>

</section>
<section class="post">
<h2 id="core-functions">Core functions</h2>

<blockquote>
  <p>本文是对Dhaval Kapil的<a href="https://heap-exploitation.dhavalkapil.com/">Heap Exploitation</a>系列教程的译文</p>
</blockquote>

<h2 id="void--_int_malloc-mstate-av-size_t-bytes">void * _int_malloc (mstate av, size_t bytes)</h2>

<ol>
  <li>Updates <code class="highlighter-rouge">bytes</code> to take care of alignments, etc.</li>
  <li>检查<code class="highlighter-rouge">av</code>是否为NULL</li>
  <li>缺少可用arena的情况(<code class="highlighter-rouge">av = NULL</code>),会使用mmap方式调用<code class="highlighter-rouge">sysmalloc</code>来获得堆块，如果成功，则调用<code class="highlighter-rouge">alloc_perturb</code>返回堆块指针</li>
  <li>
    <ul>
      <li>如果堆块大小在fastbins范围内
        <ol>
          <li>根据申请的堆块大小在fastbins数组里获取一个指向合适bin的索引</li>
          <li>移除那个bin中的第一个堆块并用<code class="highlighter-rouge">victim</code>指针指向它</li>
          <li>如果<code class="highlighter-rouge">victim = NULL</code>，则退出继续到下一个情形(smallbin)</li>
          <li>如果<code class="highlighter-rouge">victim != NULL</code>，则检查堆块大小，则检查堆块大小以确保它确实是属于要求的那个bin的，如果不符合，则抛出error(“malloc(): memory corruption (fast)”)</li>
          <li>继续调用<code class="highlighter-rouge">alloc_perturb</code>并返回指针</li>
        </ol>
      </li>
      <li>如果堆块大小在smallbin的范围内
        <ol>
          <li>根据申请的堆块大小，在smallbins数组中获取一个指向合适bin的索引</li>
          <li>如果该bin中没有堆块，那么就退出继续到下一情形。这是通过比较指针<code class="highlighter-rouge">bin</code>和<code class="highlighter-rouge">bin-&gt;bk</code>来检查的</li>
          <li>创建<code class="highlighter-rouge">victim</code>指针使等于<code class="highlighter-rouge">bin-&gt;bk</code>(bin中的最后一个堆块).如果它为NULL(在<code class="highlighter-rouge">初始化</code>过程中会发生这种情况), 就调用<code class="highlighter-rouge">malloc_consolidate</code>并跳过bins是否相同的检查</li>
          <li>否则,当<code class="highlighter-rouge">victim != NULL</code>, 检查<code class="highlighter-rouge">victim-&gt;bk-&gt;fd</code>跟<code class="highlighter-rouge">victim</code>是否相等,如果不等,则抛出error(“malloc(): smallbin double linked list corrupted”)</li>
          <li>为<code class="highlighter-rouge">victim</code>设置下一个堆块(内存意义上的,并非指双向链表中)的PREV_INUSE位为1</li>
          <li>从bin中移除该堆块</li>
          <li>根据<code class="highlighter-rouge">av</code>为该堆块设置相应的arena位</li>
          <li>调用<code class="highlighter-rouge">alloc_perturb</code>并返回堆块指针</li>
        </ol>
      </li>
      <li>如果大小不在smallbin范围内
        <ol>
          <li>根据申请的堆块大小,在largebin数组中获取一个指向合适bin的索引</li>
          <li>看<code class="highlighter-rouge">av</code>是否有fastchunks. 这是通过<code class="highlighter-rouge">av-&gt;flags</code>中的<code class="highlighter-rouge">FASTCHUNKS_BIT</code>位来进行检查的, 如果确实有fastchunks,那么就调用<code class="highlighter-rouge">av</code>中的<code class="highlighter-rouge">malloc_consolidate</code></li>
        </ol>
      </li>
    </ul>
  </li>
  <li>如果到目前为止依旧没有任何指针返回, 那么只会是以下几种情形之一:</li>
  <li>大小在fastbin范围内,但是没有fastchunk是可用的</li>
  <li>大小在smallbin范围内,但是没有smallchunk是可用的(在初始化过程中调用<code class="highlighter-rouge">malloc_consolidate</code>)</li>
  <li>
    <p>大小在largebin范围内</p>
  </li>
  <li>接下来, 检查unsorted chunks, 遍历bin中的各个堆块</li>
  <li><code class="highlighter-rouge">victim</code>指针指向当前处理的堆块</li>
  <li>检查<code class="highlighter-rouge">victim</code>的堆块大小是否在最小范围(<code class="highlighter-rouge">2*SIZE_SZ</code>)和最大范围(<code class="highlighter-rouge">av-&gt;system_mem</code>)之间, 不在范围内的话则抛出error(“malloc(): memory corruption”)</li>
  <li>如果(申请堆块的大小在smallbin范围)并且(<code class="highlighter-rouge">victim</code>是last remainder chunl)并且同时(它是unsorted bin中唯一的堆块)同时(该堆块的大小&gt;=所需求的大小)
    将该堆块分成两部分
    <ul>
      <li>第一个堆块大小为所申请的大小并将其返回</li>
      <li>剩下的那块会成为新的last remainder chunk, 并插回到unsorted bin中:
        <ol>
          <li>为该堆块设置好对应的<code class="highlighter-rouge">chunl_size</code>和<code class="highlighter-rouge">chunk_prev_size</code></li>
          <li>在调用<code class="highlighter-rouge">alloc_perturb</code>后返回第一个堆块</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>如果上述情形都不满足, 进行如下控制. 在unsorted bin中移除<code class="highlighter-rouge">victim</code>, 如果<code class="highlighter-rouge">victim</code>的大小刚好满足所申请的堆块大小, 那么就在调用<code class="highlighter-rouge">alloc_perturb</code>后返回该堆块的指针</li>
  <li>如果<code class="highlighter-rouge">victim</code>的大小在smallbin范围内, 那么就将该堆块添加到对应的smallbin的<code class="highlighter-rouge">首部</code></li>
  <li>不在smallbin范围内的话, 就将其插入到合适的largebin中并维持原有的排序顺序
    * 首先检查最后一个堆块(也是最小的). 如果<code class="highlighter-rouge">victim</code>小过这最后一个堆块, 那么就将其插入到最后
    * 不然, 循环遍历寻找一个大小恰好大于等于<code class="highlighter-rouge">victim</code>大小的堆块, 并将<code class="highlighter-rouge">victim</code>插入到这个堆块后面. 如果恰好相等, 则将其插入到第二个的位置上</li>
  <li>
    <p>重复这整个步骤最多<code class="highlighter-rouge">MAX_ITERS</code>(10000)次直到所有的堆块都插入到unsorted bin中合适的位置</p>
  </li>
  <li>在检查完unsorted chunks, 检查需求的堆块大小是否不在smallbin范围内, 如果不在的话, 那么就将检查largebins</li>
  <li>根据申请的大小, 从largebin数组中获取一个合适的bin的索引</li>
  <li>
    <p>如果最大的堆块大小(bin中的第一个堆块)大于我们所申请的大小
    1. 从链表尾部开始迭代, 直到找到一个大于等于申请大小的最小堆块<code class="highlighter-rouge">victim</code>
    2. 调用<code class="highlighter-rouge">unlink</code>移除bin中的<code class="highlighter-rouge">victim</code>堆块
    3. 为<code class="highlighter-rouge">victim</code>堆块计算<code class="highlighter-rouge">remainder_size</code>(<code class="highlighter-rouge">remainder_size</code>大小为<code class="highlighter-rouge">victim</code>的堆块大小减去所申请的堆块大小)
    4.如果<code class="highlighter-rouge">remainder_size &gt;= MINSIZE</code>(包括头部在内的最小堆块大小), 那么就切分该该堆块成两部分. 否则, 返回整个<code class="highlighter-rouge">victim</code>. 将remainder chunk插入到unsorted bin中(插到尾部). 在unsorted bin中会检查<code class="highlighter-rouge">unsorted_chunks(av)-&gt;fd-&gt;bk</code>是否等于<code class="highlighter-rouge">unsorted_chunks(av)</code>. 不等的话抛出error(“malloc(): corrupted unsorted chunks”)
    5. 在调用<code class="highlighter-rouge">alloc_perturb</code>后返回<code class="highlighter-rouge">victim</code>堆块</p>
  </li>
  <li>到目前为止, 我们以及检查了unsorted bin以及各个fastbin, smallbin以及largebin. 要注意的是我们会根据所申请的堆块大小来检查每个bin(fast或small), 重复以下步骤直到所有的bin都被检查完.</li>
  <li>bin数组的索引通过自增来检查下一个bin</li>
  <li>使用<code class="highlighter-rouge">av-&gt;binmap</code>来跳过那些空的bin</li>
  <li><code class="highlighter-rouge">victim</code>指向当前bin的尾部</li>
  <li>使用binmap确保跳过的bin(在上述第二个步骤中)确实是空的. 然而这还不能确保所有的空白bin会被跳过, 还需要检查victim是否为空. 如果为空, 那么再次跳过该bin并重复以上步骤(或继续本次循环)直到到达一个非空的bin</li>
  <li>切分堆块(<code class="highlighter-rouge">victim</code>指向非空bin中的最后一个堆块)成两部分, 将remainder chunk插入到unsorted bin中(插入到尾部). 在unsorted bin中胡检查<code class="highlighter-rouge">unsorted_chunks(av)-&gt;fd-&gt;bk</code>是否等于<code class="highlighter-rouge">unsorted_chunks(av)</code>, 如果不等,则抛出一个error(“malloc(): corrupted unsorted chunks 2”)</li>
  <li>
    <p>在调用<code class="highlighter-rouge">alloc_perturb</code>后返回<code class="highlighter-rouge">victim</code>堆块</p>
  </li>
  <li>如果还是没能找到非空bin, 那么会使用top chunk来满足需求</li>
  <li><code class="highlighter-rouge">victim</code>指向<code class="highlighter-rouge">av-&gt;top</code></li>
  <li>如果<code class="highlighter-rouge">size of top chunk &gt;= requested size + MINSIZE</code>, 那么就将其分成两部分, 在这里, 剩下的remainder chun会变成新的<code class="highlighter-rouge">top chunk</code>, 另外一个chunk则会在调用<code class="highlighter-rouge">alloc_perturb</code>后返回给用户</li>
  <li>观察<code class="highlighter-rouge">av</code>是否有fastchunks, 这是通过<code class="highlighter-rouge">av-&gt;flags</code>中的<code class="highlighter-rouge">FASTCHUNKS_BIT</code>来检查的. 如果有fastchunks, 就对<code class="highlighter-rouge">av</code>调用<code class="highlighter-rouge">malloc_consolidate</code>并返回到步骤6(我们检查unsorted bin的地方)</li>
  <li>如果<code class="highlighter-rouge">av</code>没有fastchunks, 那么就调用<code class="highlighter-rouge">sysmalloc</code>并返回调用<code class="highlighter-rouge">alloc_perturb</code>获得的指针</li>
</ol>

<h2 id="__libc_malloc-size_t-bytes">__libc_malloc (size_t bytes)</h2>

<ol>
  <li>调用<code class="highlighter-rouge">arena_get</code>来获得一个<code class="highlighter-rouge">mstate</code>指针</li>
  <li>使用指向arena的指针及arena的大小作参调用<code class="highlighter-rouge">_init_malloc</code></li>
  <li>解锁arena</li>
  <li>在返回堆块指针之前, 以下所列之一应该为真
    <ul>
      <li>返回指针是NULL</li>
      <li>chunk是通过mmap映射得到的</li>
      <li>arena的chunk会和1中找到的那个相同</li>
    </ul>
  </li>
</ol>

<h2 id="_int_free-mstate-av-mchunkptr-p-int-have_lock">_int_free (mstate av, mchunkptr p, int have_lock)</h2>

<ol>
  <li>检查<code class="highlighter-rouge">p</code>在内存上是否在<code class="highlighter-rouge">p+chunksize(p)</code>之前(避免被覆写), 不然会抛出error(“free(): invalid pointer”)</li>
  <li>检查堆块的大小至少为<code class="highlighter-rouge">MINSIZE</code>或者是<code class="highlighter-rouge">MALLOC_ALIGNMENT</code>的倍数, 若不满足则抛出error(“free(): invalid size”)</li>
  <li>如果堆块大小在fastbin范围内:
    <ol>
      <li>检查下一个堆块的大小是否在最小值和最大值之间(<code class="highlighter-rouge">av-&gt;system_mem</code>), 不然抛出error(free(): invalid next size (fast)”)</li>
      <li>对chunk调用<code class="highlighter-rouge">free_perturb</code></li>
      <li>为<code class="highlighter-rouge">av</code>设置<code class="highlighter-rouge">FASTCHUNKS_BIT</code>位为1</li>
      <li>根据堆块大小获取fastbin数组中的索引</li>
      <li>检查确保bin的顶部不是我们将要添加的那个堆块, 否则抛出error(“double free or corruption (fasttop)”)</li>
      <li>检查确保在顶部的fastbin堆块的大小跟我们所要添加的堆块大小相同, 否则抛出error(“invalid fastbin entry (free)”)</li>
      <li>将该堆块插入到fastbin链表顶部并返回</li>
    </ol>
  </li>
  <li>如果堆块不是通过mmap映射得到的
    <ol>
      <li>检查堆块是否是top chunk, 如果是则抛出error(“double free or corruption (top)”)</li>
      <li>检查next chunk是否是在arena的范围内, 如果不在的话, 抛出error(“double free or corruption (out)”)</li>
      <li>检查next chunk(内存意义上的)的<code class="highlighter-rouge">PREV_INUSE</code>位是否设置为1, 如果没有, 则抛出error(“double free or corruption (!prev)”)</li>
      <li>检查next chunk的大小是否在最小值和最大值之间(<code class="highlighter-rouge">av-&gt;system_mem</code>), 如果不在, 则抛出error(“free(): invalid next size (normal)”)</li>
      <li>对该堆块调用<code class="highlighter-rouge">free_perturb</code></li>
      <li>如果前一个堆块(内存意义上的)处于空闲状态, 则对这个前一个堆块调用<code class="highlighter-rouge">unlink</code>
7.如果next chunk(内存意义上的)不是top chunk
        <ol>
          <li>如果next chunk处于空闲状态, 则对这个next chunk调用<code class="highlighter-rouge">unlink</code></li>
          <li>合并前后堆块(内存意义上的), 如果都是空闲状态, 则将其加入到unsorted bin的首部. 在插入之前, 会检查<code class="highlighter-rouge">unsorted_chunks(av)-&gt;fd-&gt;bk</code>是否等于<code class="highlighter-rouge">unsorted_chunks(av)</code>, 如果不等,则抛出error(“free(): corrupted unsorted chunks”)</li>
        </ol>
      </li>
      <li>如果next chunk(内存意义上的)是一个top chunk, 那么将该堆块适当地合并到top chunk去</li>
    </ol>
  </li>
  <li>如果堆块是通过mmap映射得到, 则调用<code class="highlighter-rouge">munmap_chunk</code></li>
</ol>

<h2 id="__libc_free-void-mem">__libc_free (void *mem)</h2>

<ol>
  <li>如果<code class="highlighter-rouge">mem</code>为NULL则返回</li>
  <li>如果相应的堆块通过mmap映射, 则会在需要调整动态brk/mmap阈的时候调用<code class="highlighter-rouge">munmap_chunk</code></li>
  <li>为相应堆块获取arena指针</li>
  <li>调用 <code class="highlighter-rouge">_int_free</code>.</li>
</ol>

</section>
<section align="right">
<br/>
<span>
	<a  href="/2017/08/10/Internal-functions/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2017/08/10/vimium/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.vancir.com/2017/08/10/Internal-functions/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.vancir.com/2017/08/10/vimium/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>