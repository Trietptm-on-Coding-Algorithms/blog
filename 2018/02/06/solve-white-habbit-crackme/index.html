<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>the White Rabbit CrackMe 解答</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>the White Rabbit CrackMe 解答</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2018-02-06">2018-02-06</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#crack" title="crack">crack</a>&nbsp;
  
  <a href="/categories/#translations" title="translations">translations</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#RE" title="RE">RE</a>&nbsp;
  
</span>

</section>
<section class="post">
<p>Crackme文件可以从此处下载: <a href="https://hshrzd.wordpress.com/2018/02/03/white-rabbit-crackme/">White Rabbit crackme!</a></p>

<p>因为crackme里稍微使用了混淆和一些像恶意程序的把戏, 所以可能会被一些杀毒软件标记为恶意程序, 所以也建议在虚拟机下运行.</p>

<p>这个crackme运行的截图如下:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/1.png" alt="1.png" /></p>

<p>OK, 首先要做的第一件事就是将其载入到IDA中(我这里使用的是刚刚发布的<a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">IDA 7的免费版本</a>). 通过搜索字符串<code class="highlighter-rouge">Password#1</code>来看它的交叉引用以及前后都发生了些什么.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/2.png" alt="2.png" /></p>

<p>就这了! 我们可以看到它被<code class="highlighter-rouge">sub_4034D0</code>所引用. 现在我们将跟随到引用处, 来看看接下来发生什么</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/3.png" alt="3.png" /></p>

<p>在<code class="highlighter-rouge">sub_403D90</code>中有一些初始化操作, 随后在<code class="highlighter-rouge">sub_404150</code>的结果与可疑值<code class="highlighter-rouge">0x57585384</code>的比较后又一个分支跳转. 子分支中的<code class="highlighter-rouge">sub_403990</code>输出了一些提示语以及后续一些有关接受用户输入的内容.</p>

<p>我们首先来看初始化部分(<code class="highlighter-rouge">sub_403D90</code>):</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/4.png" alt="4.png" /></p>

<p>函数取了两个参数, 内容看上去也非常清楚: 通过给出的标识符查找资源文件, 加载资源文件, 确定它的文件大小, 然后申请内存空间并将资源文件的数据复制进去. 该函数返回那个新申请的内存空间的指针, 并将资源文件的大小存储在第一个参数中.</p>

<p>现在我们唯一需要注意的就是图中的<code class="highlighter-rouge">sub_406A70</code>, 它取了3个参数(target pointer, source pointer 以及 data size)并且看起来非常像是<code class="highlighter-rouge">memcpy</code>(或<code class="highlighter-rouge">memmove</code>, 是哪个不重要, 因为内存区域没有重叠). 但是函数内的代码却包含有大量的分支, 难以分析. 所以我们不能确定它有没有在复制的过程中以某种方式修改了数据(比如, 解密数据). 最简便的检查方式就是在调试器里动态分析, 比较函数返回时, <code class="highlighter-rouge">soure</code>和<code class="highlighter-rouge">target</code>内存是否有区别.</p>

<p>我使用<code class="highlighter-rouge">[x64Dbg](https://x64dbg.com/)</code>来分析. 在启动调试器后我们打开crackme, 调试器会自动运行程序并暂停在入口点位置.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/5.png" alt="5.png" /></p>

<p>现在我们需要在我们感兴趣的函数返回处设下一个断点. 指令地址是<code class="highlighter-rouge">0x00403DF9</code>(给定<code class="highlighter-rouge">.text</code>段的基址是<code class="highlighter-rouge">0x00401000</code>). 你可以根据内存布局来了解真正<code class="highlighter-rouge">.text</code>段载入的基址(我这里是<code class="highlighter-rouge">0x00281000</code>). 因此我的实际断点地址应该是<code class="highlighter-rouge">0x00283DF9</code>.</p>

<p>现在我们用<code class="highlighter-rouge">bp 0x00283DF9</code>命令设下断点, 继续执行触发断点. 然后我们右键点击右侧面板<code class="highlighter-rouge">ebx</code>和<code class="highlighter-rouge">edi</code>寄存器的值, 选择在数据窗口跟随. 现在我们就可以确认<code class="highlighter-rouge">sub_406A70</code>仅仅复制了内存<code class="highlighter-rouge">as is</code>, 我们可以放心地将该函数重命名为更易理解的<code class="highlighter-rouge">memcpy</code>. 同样我们也把<code class="highlighter-rouge">sub_403D90</code>重命名为<code class="highlighter-rouge">loadResource</code></p>

<p>现在我们来分析<code class="highlighter-rouge">sub_404150</code></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/6.png" alt="6.png" /></p>

<p>映入眼帘的是一个常量<code class="highlighter-rouge">0x82F63B78</code>. 通过google搜索知道说这是一个用于CRC32计算的多项式值. 代码里看也有从输入缓冲区里对每个字节的值异或累加, 随后再移位/异或8次. 因此它确实是一个<code class="highlighter-rouge">crc32c</code>计算函数.</p>

<p>在重命名和初期的分析后, 我们再来看看改动后的代码</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/7.png" alt="7.png" /></p>

<p>注意: 也许你会对lea/cmovnb指令有些许困惑. 不过很好解释: <code class="highlighter-rouge">lpPasswordText</code>的值实际上是如下的结构体:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="k">static</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">dynamic</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这可能就是栈上<code class="highlighter-rouge">std::string</code>的形式. 当字符串仅有<code class="highlighter-rouge">static</code>数组那么长时, 不会申请额外的内存空间(并且<code class="highlighter-rouge">static</code>缓冲区的地址用<code class="highlighter-rouge">lea</code>加载). 相反如果超出了缓冲区, <code class="highlighter-rouge">cmovnb</code>会获取<code class="highlighter-rouge">dynamic</code>域所分配的内存的指针. 最后, <code class="highlighter-rouge">eax</code>会获得指向真正字符串数据的指针, 不论其位置具体在哪.</p>

<p>因此, <code class="highlighter-rouge">sub_401000</code>读取键盘输入到<code class="highlighter-rouge">std::string</code>, <code class="highlighter-rouge">std::string</code>随后传递给<code class="highlighter-rouge">crc32c</code>函数. 现在我们知道说我们的password应该含有CRC32的<code class="highlighter-rouge">0x57585384</code>, 我们可以根据这个条件判断我们是否获取到了正确的password.</p>

<p>现在我们来假定password跟给出的CRC32值相匹配, 来继续往下分析:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/8.png" alt="8.png" /></p>

<p>有趣的第一点就是<code class="highlighter-rouge">sub_403C90</code>, 因为它同时取了<code class="highlighter-rouge">password</code>和<code class="highlighter-rouge">资源数据</code>作为参数.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/9.png" alt="9.png" /></p>

<p>很显然这里是一个异或加密的操作. 它首先确定<code class="highlighter-rouge">password</code>的长度, 随后用相应的<code class="highlighter-rouge">password</code>字符对输入缓冲区的每一个字节进行异或.</p>

<p>随后生成一个临时文件名, 将解密的资源数据内容写入到该文件(在函数<code class="highlighter-rouge">sub_403090</code>里). 待一切完成, 却也再没有给出任何关于<code class="highlighter-rouge">password</code>的线索了. 我们来看一下<code class="highlighter-rouge">sub_403D20</code>, 该函数接收新创建的文件名并执行了一些操作.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/10.png" alt="10.png" /></p>

<p>OK, 现在事情已经越发清晰. crackme尝试设置新生成的文件作为桌面壁纸, 因此很显然这个文件应该是一个图片.</p>

<p>现在我们要提取crackme里的资源文件, 看看我们能否有所收获. 你可以使用任意的资源编辑软件, 例如: <a href="https://medium.com/@alexskalozub/solving-the-white-rabbit-crackme-d6b627c02ad4">Resource Hacker</a></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/11.png" alt="11.png" /></p>

<p>我们可以看到它的大小是<code class="highlighter-rouge">6,220,854</code>字节, 对于一个图像来说已经很大了, 据此我们猜测, 这是一个无压缩的BMP图像文件.</p>

<p>BMP格式已经是众所周知, 并且有文档说明. 文件起始于一个<code class="highlighter-rouge">"BM"</code>签名, 随后是<code class="highlighter-rouge">4字节</code>的文件大小(小端序), 接着是两个<code class="highlighter-rouge">4字节</code>的保留字(全0), 一个<code class="highlighter-rouge">4字节</code>存储着位图数据的起始位置, 再紧接着是<code class="highlighter-rouge">40字节</code>的位图信息头(起始的是该信息头所占用的字节数). 再下面就是各种关于BMP信息了, 我们现在也不知道.</p>

<p>由于我们得知了真正的文件大小值, 所以我们可以较准确地推测出文件的前18个字节.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>资源文件里的字节:
24 22 5A 80 31 77 5F 64 61 5F 44 61 62 62 41 74 7A 66
期待的结果:
42 4D 36 EC 5E 00 00 00 00 00 36 00 00 00 28 00 00 00
</code></pre></div></div>

<p>现在我们逐个将实际资源文件里的字节和说期望的字节进行异或, 这样我们就可以恢复出部分key的内容. 如果幸运的话, 我们可以获得一个完整的key</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>66 6F 6C 6C 6F 77 5F 64 61 5F 72 61 62 62 69 74 7A 66
</code></pre></div></div>

<p>异或得到的结果是<code class="highlighter-rouge">"follow_da_rabbitzf"</code>. 最后的这一个<code class="highlighter-rouge">"f"</code>也许是重复的下一个key的起始字母, 也许就是这个key的一部分. 最简单的检查方法就是将其输入到crackme里看看结果如何.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/12.png" alt="12.png" /></p>

<p>Yeah. 我们的结果是正确的. 我们再继续.</p>

<p>现在我们有一个超酷的桌面壁纸, 然后还有另外一个<code class="highlighter-rouge">password</code>需要破解出来. 我们再次搜索<code class="highlighter-rouge">"Password#2"</code>字符串并跟随到交叉引用处:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/13.png" alt="13.png" /></p>

<p>这看起来跟之前非常相似, 因此我们自己向下来到解密开始的部分:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/14.png" alt="14.png" /></p>

<p>有趣的部分在<code class="highlighter-rouge">sub_403E10</code>, 这里在写入数据到文件之前进行了解密:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/15.png" alt="15.png" /></p>

<p>这里根据<code class="highlighter-rouge">password</code>导出一个<code class="highlighter-rouge">AES128</code>的密钥(使用<code class="highlighter-rouge">SHA256</code>作为密钥导出算法)并用于解密资源数据.</p>

<p>没有必要去破解AES加密(恐怕就连NSA也无法破解), 我们只知道<code class="highlighter-rouge">password</code>的crc32值. 很显然不足以通过暴力破解的手段来获取它(我尝试过!). 但等等, 我们有一个壁纸啊! 或许在壁纸里会有某些隐藏的信息!</p>

<p>用图像编辑器打开并使用”颜色选择”工具:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/16.png" alt="16.png" /></p>

<p>这应该就是我们一直在寻找的key! 接下来继续:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/17.png" alt="17.png" /></p>

<p>但是事情还没结束. 现在我们在临时目录下有一个解密过的可执行文件, 但我们还是没有拿到flag. 我们还需要用IDA继续分析.</p>

<p>因为第二个可执行文件按并没有产生任何字符串信息, 也就难以下手. 我们就来看看导入表情况:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/18.png" alt="18.png" /></p>

<p>这里有一系列的按顺序导入的<code class="highlighter-rouge">ws2_32.dll</code>的函数, 这给我们两个线索:</p>

<ul>
  <li>程序有在进行网络socket操作</li>
  <li>程序有隐藏些什么!</li>
</ul>

<p>因此我们的第一步就是去到这些函数被调用的地方, 并将这些函数重命名为可读性更高更有意义的名称. 序号与之对应的函数名称可以很容易地通过google搜索找到.</p>

<p>现在我们知道了所有的网络操作都在<code class="highlighter-rouge">sub_404480</code>里, 因此接下来仔细看看这个函数. 该函数开始是一个标准流程(<code class="highlighter-rouge">WSAStartup/socket/bind/listen</code>), 所以没太多亮点, 有趣的部分在下图:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/19.png" alt="19.png" /></p>

<p>因此它等待接受一个连接, 从连接中读取4字节, 基于静态缓冲区<code class="highlighter-rouge">buf</code>和接收的数据在<code class="highlighter-rouge">sub_404640</code>中执行一些操作. 如果操作成功转型(函数返回非零值), 它就会将<code class="highlighter-rouge">buf</code>的内容发回给客户端随后关闭连接. 否则它会关闭连接监听新的连接. 所有的操作都是同步的, 所以在<code class="highlighter-rouge">sub_404640</code>成功执行前不会退出函数.</p>

<p>来看看<code class="highlighter-rouge">sub_404640</code>的内容:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/20.png" alt="20.png" /></p>

<p>看起来非常像是一个小的状态机, 成功转移到下一状态时返回1, 有如下几个转移:</p>

<ul>
  <li>从 初始状态(0) 到 ‘Y’ 状态 (如果接收到9)</li>
  <li>从 ‘Y’ 状态 到 ‘E’ 状态 (如果接收到3)</li>
  <li>从 ‘E’ 状态 到 ‘S’ 状态 (如果接收到5)</li>
  <li>接收到其他的任何值, 都会将状态机重置为 初始状态(0)</li>
</ul>

<p>因此, 我们可能需要按顺序发起3个连接, 连到<code class="highlighter-rouge">"server"</code>, 更新状态机到下一状态.</p>

<p>但是我们仍有两个问题需要解决:</p>

<ol>
  <li>我们不知道需要连接到哪一个端口(函数需要取端口号作参数)</li>
  <li>在每次成功转移状态后, 监听的套接字都会关闭</li>
</ol>

<p>因此我们需要找到所有的函数被调用的地方, 然后跟踪看它启动了哪一个端口.</p>

<p>如同我们所预料的那样, 函数被调用了3次(因为有3次合法的状态转移), 并且幸运的是, 它都是在同一个步骤里被调用的:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/21.png" alt="21.png" /></p>

<p>在这里</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/22.png" alt="22.png" /></p>

<p>所以, server一开始开启了端口<code class="highlighter-rouge">1337</code>, 随后是<code class="highlighter-rouge">1338</code>, 最后是<code class="highlighter-rouge">1339</code>. 因此我们首先需要连接到<code class="highlighter-rouge">1337</code>端口并发送<code class="highlighter-rouge">9</code>, 然后连接到<code class="highlighter-rouge">1338</code>端口, 发送<code class="highlighter-rouge">3</code>. 最后连接到<code class="highlighter-rouge">1339</code>端口, 发送<code class="highlighter-rouge">5</code>. 我们可以使用内置的<code class="highlighter-rouge">telnet</code>工具来完成这一操作.</p>

<p>完成上述操作后会打开一个简短视频的YouTube页面:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/23.png" alt="23.png" /></p>

<p>我们成功地拿到了flag. 收工回家!</p>

</section>
<section align="right">
<br/>
<span>
	<a  href="/2018/01/26/unicorn-intro/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2018/03/06/tscookie/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.vancir.com/2018/01/26/unicorn-intro/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.vancir.com/2018/03/06/tscookie/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>