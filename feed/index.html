<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Vancir</title>
    <link href="http://www.vancir.com/feed/" rel="self" />
    <link href="http://www.vancir.com" />
    <lastBuildDate>2018-04-04T22:22:14+08:00</lastBuildDate>
    <webMaster>vancirprince@gmail.com</webMaster>
    
    <item>
      <title>检测Android虚拟机的方法和代码实现</title>
      <link href="http://www.vancir.com/2018/04/04/android-anti-emulator/"/>
      <pubDate>2018-04-04T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/04/04/android-anti-emulator</guid>
      <content:encoded><![CDATA[<p>刚刚看了一些关于Detect Android Emulator的开源项目/文章/论文, 我看的这些其实都是13年14年提出的方法, 方法里大多是检测一些环境属性, 检查一些文件这样, 但实际上检测的思路并不局限于此. 有的是很直接了当去检测qemu, 而其它的方法则是旁敲侧击比如检测adb, 检测ptrace之类的. 思路也很灵活. 最后看到有提出通过利用QEMU这样的模拟CPU与物理CPU之间的实际差异(任务调度差异), 模拟传感器和物理传感器的差异, 缓存的差异等方法来检测. 相比检测环境属性, 检测效果会提升很多.</p>

<p>下面我就列出各个资料中所提出的一些方法/思路/代码供大家交流学习.</p>

<h2 id="qemu-properties">QEMU Properties</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Property</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="n">String</span> <span class="n">seek_value</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Property</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">String</span> <span class="n">seek_value</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">seek_value</span> <span class="o">=</span> <span class="n">seek_value</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="cm">/** 
 * 已知属性, 格式为 [属性名, 属性值], 用于判定当前是否为QEMU环境
 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="n">Property</span><span class="o">[]</span> <span class="n">known_props</span> <span class="o">=</span> <span class="o">{</span><span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"init.svc.qemud"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"init.svc.qemu-props"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"qemu.hw.mainkeys"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"qemu.sf.fake_camera"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"qemu.sf.lcd_density"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.bootloader"</span><span class="o">,</span> <span class="s">"unknown"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.bootmode"</span><span class="o">,</span> <span class="s">"unknown"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.hardware"</span><span class="o">,</span> <span class="s">"goldfish"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.kernel.android.qemud"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.kernel.qemu.gles"</span><span class="o">,</span> <span class="kc">null</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.kernel.qemu"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.product.device"</span><span class="o">,</span> <span class="s">"generic"</span><span class="o">),</span> <span class="k">new</span> <span class="n">Property</span><span class="o">(</span><span class="s">"ro.product.model"</span><span class="o">,</span> <span class="s">"sdk"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.product.name"</span><span class="o">,</span> <span class="s">"sdk"</span><span class="o">),</span>
        <span class="k">new</span> <span class="nf">Property</span><span class="o">(</span><span class="s">"ro.serialno"</span><span class="o">,</span> <span class="kc">null</span><span class="o">)};</span>
<span class="cm">/**
 * 一个阈值, 因为所谓"已知"的模拟器属性并不完全准确, 有可能出现假阳性结果, 因此保持一定的阈值能让检测效果更好
 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">MIN_PROPERTIES_THRESHOLD</span> <span class="o">=</span> <span class="mh">0x5</span><span class="o">;</span>
<span class="cm">/**
 * 尝试通过查询指定的系统属性来检测QEMU环境, 最后跟阈值比较得出检测结果.
 *
 * @param context A {link Context} object for the Android application.
 * @return {@code true} if enough properties where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasQEmuProps</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">found_props</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Property</span> <span class="n">property</span> <span class="o">:</span> <span class="n">known_props</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">property_value</span> <span class="o">=</span> <span class="n">Utilities</span><span class="o">.</span><span class="na">getProp</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">property</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="c1">// See if we expected just a non-null</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">property</span><span class="o">.</span><span class="na">seek_value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">property_value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">found_props</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="c1">// See if we expected a value to seek</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">property</span><span class="o">.</span><span class="na">seek_value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">property_value</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">property</span><span class="o">.</span><span class="na">seek_value</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">found_props</span><span class="o">++;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">found_props</span> <span class="o">&gt;=</span> <span class="n">MIN_PROPERTIES_THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这些都是基于一些经验和特征来比对的属性, 这里的属性以及之后的一些文件呀属性啊之类的我就不再多作解释.</p>

<h2 id="device-id">Device ID</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_device_ids</span> <span class="o">=</span> <span class="o">{</span><span class="s">"000000000000000"</span><span class="o">,</span> <span class="c1">// Default emulator id</span>
        <span class="s">"e21833235b6eef10"</span><span class="o">,</span> <span class="c1">// VirusTotal id</span>
        <span class="s">"012345678912345"</span><span class="o">};</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasKnownDeviceId</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TelephonyManager</span> <span class="n">telephonyManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">);</span>

    <span class="n">String</span> <span class="n">deviceId</span> <span class="o">=</span> <span class="n">telephonyManager</span><span class="o">.</span><span class="na">getDeviceId</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">known_deviceId</span> <span class="o">:</span> <span class="n">known_device_ids</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">known_deviceId</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">deviceId</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="default-number">Default Number</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_numbers</span> <span class="o">=</span> <span class="o">{</span>
        <span class="s">"15555215554"</span><span class="o">,</span> <span class="c1">// 模拟器默认电话号码 + VirusTotal</span>
        <span class="s">"15555215556"</span><span class="o">,</span> <span class="s">"15555215558"</span><span class="o">,</span> <span class="s">"15555215560"</span><span class="o">,</span> <span class="s">"15555215562"</span><span class="o">,</span> <span class="s">"15555215564"</span><span class="o">,</span> <span class="s">"15555215566"</span><span class="o">,</span>
        <span class="s">"15555215568"</span><span class="o">,</span> <span class="s">"15555215570"</span><span class="o">,</span> <span class="s">"15555215572"</span><span class="o">,</span> <span class="s">"15555215574"</span><span class="o">,</span> <span class="s">"15555215576"</span><span class="o">,</span> <span class="s">"15555215578"</span><span class="o">,</span>
        <span class="s">"15555215580"</span><span class="o">,</span> <span class="s">"15555215582"</span><span class="o">,</span> <span class="s">"15555215584"</span><span class="o">,};</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasKnownPhoneNumber</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TelephonyManager</span> <span class="n">telephonyManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">);</span>

    <span class="n">String</span> <span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">telephonyManager</span><span class="o">.</span><span class="na">getLine1Number</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">number</span> <span class="o">:</span> <span class="n">known_numbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">phoneNumber</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="imsi">IMSI</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_imsi_ids</span> <span class="o">=</span> <span class="o">{</span><span class="s">"310260000000000"</span> <span class="c1">// 默认IMSI编号</span>
<span class="o">};</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasKnownImsi</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TelephonyManager</span> <span class="n">telephonyManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">context</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">);</span>
    <span class="n">String</span> <span class="n">imsi</span> <span class="o">=</span> <span class="n">telephonyManager</span><span class="o">.</span><span class="na">getSubscriberId</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">known_imsi</span> <span class="o">:</span> <span class="n">known_imsi_ids</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">known_imsi</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">imsi</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="build类">Build类</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasEmulatorBuild</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">BOARD</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">BOARD</span><span class="o">;</span> <span class="c1">// The name of the underlying board, like "unknown".</span>
    <span class="c1">// This appears to occur often on real hardware... that's sad</span>
    <span class="c1">// String BOOTLOADER = android.os.Build.BOOTLOADER; // The system bootloader version number.</span>
    <span class="n">String</span> <span class="n">BRAND</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">BRAND</span><span class="o">;</span> <span class="c1">// The brand (e.g., carrier) the software is customized for, if any.</span>
    <span class="c1">// "generic"</span>
    <span class="n">String</span> <span class="n">DEVICE</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">DEVICE</span><span class="o">;</span> <span class="c1">// The name of the industrial design. "generic"</span>
    <span class="n">String</span> <span class="n">HARDWARE</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">HARDWARE</span><span class="o">;</span> <span class="c1">// The name of the hardware (from the kernel command line or</span>
    <span class="c1">// /proc). "goldfish"</span>
    <span class="n">String</span> <span class="n">MODEL</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">MODEL</span><span class="o">;</span> <span class="c1">// The end-user-visible name for the end product. "sdk"</span>
    <span class="n">String</span> <span class="n">PRODUCT</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Build</span><span class="o">.</span><span class="na">PRODUCT</span><span class="o">;</span> <span class="c1">// The name of the overall product.</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">BOARD</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"unknown"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="cm">/* || (BOOTLOADER.compareTo("unknown") == 0) */</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">BRAND</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"generic"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">DEVICE</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"generic"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">MODEL</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"sdk"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">PRODUCT</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"sdk"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">||</span> <span class="o">(</span><span class="n">HARDWARE</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="s">"goldfish"</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="运营商名">运营商名</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isOperatorNameAndroid</span><span class="o">(</span><span class="n">Context</span> <span class="n">paramContext</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">szOperatorName</span> <span class="o">=</span> <span class="o">((</span><span class="n">TelephonyManager</span><span class="o">)</span> <span class="n">paramContext</span><span class="o">.</span><span class="na">getSystemService</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">TELEPHONY_SERVICE</span><span class="o">)).</span><span class="na">getNetworkOperatorName</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">isAndroid</span> <span class="o">=</span> <span class="n">szOperatorName</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="s">"android"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">isAndroid</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="qemu驱动">QEMU驱动</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_qemu_drivers</span> <span class="o">=</span> <span class="o">{</span><span class="s">"goldfish"</span><span class="o">};</span>
<span class="cm">/**
 * 读取驱动文件, 检查是否包含已知的qemu驱动
 *
 * @return {@code true} if any known drivers where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasQEmuDrivers</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">File</span> <span class="n">drivers_file</span> <span class="o">:</span> <span class="k">new</span> <span class="n">File</span><span class="o">[]{</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/proc/tty/drivers"</span><span class="o">),</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">"/proc/cpuinfo"</span><span class="o">)})</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">drivers_file</span><span class="o">.</span><span class="na">exists</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">drivers_file</span><span class="o">.</span><span class="na">canRead</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// We don't care to read much past things since info we care about should be inside here</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">InputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">drivers_file</span><span class="o">);</span>
                <span class="n">is</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                <span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="n">String</span> <span class="n">driver_data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">known_qemu_driver</span> <span class="o">:</span> <span class="n">FindEmulator</span><span class="o">.</span><span class="na">known_qemu_drivers</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">driver_data</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">known_qemu_driver</span><span class="o">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="qemu文件">QEMU文件</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_files</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/system/lib/libc_malloc_debug_qemu.so"</span><span class="o">,</span> <span class="s">"/sys/qemu_trace"</span><span class="o">,</span>
        <span class="s">"/system/bin/qemu-props"</span><span class="o">};</span>
<span class="cm">/**
 * 检查是否存在已知的QEMU环境文件
 *
 * @return {@code true} if any files where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasQEmuFiles</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">pipe</span> <span class="o">:</span> <span class="n">known_files</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">qemu_file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">pipe</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qemu_file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="genymotion文件">Genymotion文件</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_geny_files</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/dev/socket/genyd"</span><span class="o">,</span> <span class="s">"/dev/socket/baseband_genyd"</span><span class="o">};</span>
<span class="cm">/**
 * 检查是否存在已知的Genemytion环境文件
 *
 * @return {@code true} if any files where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasGenyFiles</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">file</span> <span class="o">:</span> <span class="n">known_geny_files</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">geny_file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">geny_file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="qemu管道">QEMU管道</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">known_pipes</span> <span class="o">=</span> <span class="o">{</span><span class="s">"/dev/socket/qemud"</span><span class="o">,</span> <span class="s">"/dev/qemu_pipe"</span><span class="o">};</span>
<span class="cm">/**
 * 检查是否存在已知的QEMU使用的管道
 *
 * @return {@code true} if any pipes where found to exist or {@code false} if not.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasPipes</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">pipe</span> <span class="o">:</span> <span class="n">known_pipes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">qemu_socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">pipe</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qemu_socket</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="设置断点">设置断点</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">{</span>
    <span class="c1">// This is only valid for arm</span>
    <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">"anti"</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">native</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">qemuBkpt</span><span class="o">();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkQemuBreakpoint</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">hit_breakpoint</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// Potentially you may want to see if this is a specific value</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">qemuBkpt</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hit_breakpoint</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">hit_breakpoint</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>以下是对应的c++代码</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">handler_sigtrap</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">handler_sigbus</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">setupSigTrap</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// BKPT throws SIGTRAP on nexus 5 / oneplus one (and most devices)
</span>  <span class="n">signal</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">,</span> <span class="n">handler_sigtrap</span><span class="p">);</span>
  <span class="c1">// BKPT throws SIGBUS on nexus 4
</span>  <span class="n">signal</span><span class="p">(</span><span class="n">SIGBUS</span><span class="p">,</span> <span class="n">handler_sigbus</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This will cause a SIGSEGV on some QEMU or be properly respected
</span><span class="kt">int</span> <span class="nf">tryBKPT</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">"bkpt 255"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">jint</span> <span class="nf">Java_diff_strazzere_anti_emulator_FindEmulator_qemuBkpt</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">jObject</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">pid_t</span> <span class="n">child</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">child_status</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setupSigTrap</span><span class="p">();</span>
    <span class="n">tryBKPT</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">child</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">waitpid</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_status</span><span class="p">,</span> <span class="n">WNOHANG</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="c1">// Time could be adjusted here, though in my experience if the child has not returned instantly
</span>      <span class="c1">// then something has gone wrong and it is an emulated device
</span>      <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Process timed out - likely an emulated device and child is frozen
</span>      <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">WIFEXITED</span><span class="p">(</span><span class="n">child_status</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 子进程正常退出
</span>      <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Didn't exit properly - very likely an emulator
</span>      <span class="n">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Ensure child is dead
</span>    <span class="n">kill</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我的描述可能并不准确, 因为并没有找到相关的资料. 我只能以自己的理解来解释一下:</p>

<p><code class="highlighter-rouge">SIGTRAP</code>是调试器设置断点时发生的信号, 在nexus5或一加手机等大多数手机都可以触发. <code class="highlighter-rouge">SIGBUS</code>则是在一个总线错误, 指针也许访问了一个有效地址, 但总线会因为数据未对齐等原因无法使用, 在nexus4手机上可以触发. 而<code class="highlighter-rouge">bkpt</code>则是arm的断点指令, 这是曾经qemu被提出来的一个issue, qemu会因为<code class="highlighter-rouge">SIGSEGV</code>信号而崩溃, 作者想利用这个崩溃来检测qemu. 如果程序没有正常退出或被冻结, 那么就可以认定很可能是在模拟器里.</p>

<h2 id="adb">ADB</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasEmulatorAdb</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">FindDebugger</span><span class="o">.</span><span class="na">hasAdbInEmulator</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="isuseramonkey">isUserAMonkey()</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isUserAMonkey</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">ActivityManager</span><span class="o">.</span><span class="na">isUserAMonkey</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这个其实是用于检测当前操作到底是用户还是脚本在要求应用执行.</p>

<h2 id="isdebuggerconnected">isDebuggerConnected()</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 你信或不信, 还真有许多加固程序使用这个方法...
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBeingDebugged</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Debug</span><span class="o">.</span><span class="na">isDebuggerConnected</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法是用来检测调试, 判断是否有调试器连接.</p>

<h2 id="ptrace">ptrace</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">tracerpid</span> <span class="o">=</span> <span class="s">"TracerPid"</span><span class="o">;</span>
<span class="cm">/**
 * 阿里巴巴用于检测是否在跟踪应用进程
 * 
 * 容易规避, 用法是创建一个线程每3秒检测一次, 如果检测到则程序崩溃
 * 
 * @return
 * @throws IOException
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasTracerPid</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"/proc/self/status"</span><span class="o">)),</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">line</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">tracerpid</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">tracerpid</span><span class="o">.</span><span class="na">length</span><span class="o">()).</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">tracerpid</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">tracerpid</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="na">trim</span><span class="o">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法是通过检查<code class="highlighter-rouge">/proc/self/status</code>的<code class="highlighter-rouge">TracerPid</code>项, 这个项在没有跟踪的时候默认为0, 当有程序在跟踪时会修改为对应的pid. 因此如果<code class="highlighter-rouge">TracerPid</code>不等于0, 那么就可以认为是在模拟器环境.</p>

<h2 id="tcp连接">TCP连接</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasAdbInEmulator</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">adbInEmulator</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">"/proc/net/tcp"</span><span class="o">)),</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="c1">// Skip column names</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">tcpList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;();</span>

        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">tcpList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tcp</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\W+"</span><span class="o">)));</span>
        <span class="o">}</span>

        <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>

        <span class="c1">// Adb is always bounce to 0.0.0.0 - though the port can change</span>
        <span class="c1">// real devices should be != 127.0.0.1</span>
        <span class="kt">int</span> <span class="n">adbPort</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">tcp</span> <span class="n">tcpItem</span> <span class="o">:</span> <span class="n">tcpList</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tcpItem</span><span class="o">.</span><span class="na">localIp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">adbPort</span> <span class="o">=</span> <span class="n">tcpItem</span><span class="o">.</span><span class="na">localPort</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">adbPort</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">tcp</span> <span class="n">tcpItem</span> <span class="o">:</span> <span class="n">tcpList</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">tcpItem</span><span class="o">.</span><span class="na">localIp</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tcpItem</span><span class="o">.</span><span class="na">localPort</span> <span class="o">==</span> <span class="n">adbPort</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">adbInEmulator</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">exception</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">adbInEmulator</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">tcp</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">localIp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">localPort</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">remoteIp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">remotePort</span><span class="o">;</span>

    <span class="kd">static</span> <span class="n">tcp</span> <span class="nf">create</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">tcp</span><span class="o">(</span><span class="n">params</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">3</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">4</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">5</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">6</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">7</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">8</span><span class="o">],</span>
                        <span class="n">params</span><span class="o">[</span><span class="mi">9</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">10</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">11</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">12</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">13</span><span class="o">],</span> <span class="n">params</span><span class="o">[</span><span class="mi">14</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">tcp</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">localIp</span><span class="o">,</span> <span class="n">String</span> <span class="n">localPort</span><span class="o">,</span> <span class="n">String</span> <span class="n">remoteIp</span><span class="o">,</span> <span class="n">String</span> <span class="n">remotePort</span><span class="o">,</span> <span class="n">String</span> <span class="n">state</span><span class="o">,</span>
                    <span class="n">String</span> <span class="n">tx_queue</span><span class="o">,</span> <span class="n">String</span> <span class="n">rx_queue</span><span class="o">,</span> <span class="n">String</span> <span class="n">tr</span><span class="o">,</span> <span class="n">String</span> <span class="n">tm_when</span><span class="o">,</span> <span class="n">String</span> <span class="n">retrnsmt</span><span class="o">,</span> <span class="n">String</span> <span class="n">uid</span><span class="o">,</span>
                    <span class="n">String</span> <span class="n">timeout</span><span class="o">,</span> <span class="n">String</span> <span class="n">inode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">localIp</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">localIp</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">localPort</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">localPort</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法是通过读取<code class="highlighter-rouge">/proc/net/tcp</code>的信息来判断是否存在adb. 比如真机的的信息为<code class="highlighter-rouge">0: 4604D20A:B512 A3D13AD8...</code>, 而模拟器上的对应信息就是<code class="highlighter-rouge">0: 00000000:0016 00000000:0000</code>, 因为adb通常是反射到<code class="highlighter-rouge">0.0.0.0</code>这个ip上, 虽然端口有可能改变, 但确实是可行的.</p>

<h2 id="taintdroid">TaintDroid</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasPackageNameInstalled</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">String</span> <span class="n">packageName</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">PackageManager</span> <span class="n">packageManager</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getPackageManager</span><span class="o">();</span>

    <span class="c1">// In theory, if the package installer does not throw an exception, package exists</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">packageManager</span><span class="o">.</span><span class="na">getInstallerPackageName</span><span class="o">(</span><span class="n">packageName</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasAppAnalysisPackage</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Utilities</span><span class="o">.</span><span class="na">hasPackageNameInstalled</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="s">"org.appanalysis"</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasTaintClass</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"dalvik.system.Taint"</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个比较单纯了. 就是通过检测包名, 检测<code class="highlighter-rouge">Taint</code>类来判断是否安装有<code class="highlighter-rouge">TaintDroid</code>这个污点分析工具. 另外也还可以检测<code class="highlighter-rouge">TaintDroid</code>的一些成员变量.</p>

<h2 id="eth0">eth0</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasEth0Interface</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Enumeration</span><span class="o">&lt;</span><span class="n">NetworkInterface</span><span class="o">&gt;</span> <span class="n">en</span> <span class="o">=</span> <span class="n">NetworkInterface</span><span class="o">.</span><span class="na">getNetworkInterfaces</span><span class="o">();</span> <span class="n">en</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">NetworkInterface</span> <span class="n">intf</span> <span class="o">=</span> <span class="n">en</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intf</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"eth0"</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">SocketException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>检测是否存在<code class="highlighter-rouge">eth0</code>网卡.</p>

<h2 id="传感器">传感器</h2>

<p>手机上配备了各式各样的传感器, 但它们实质上都是基于从环境收集的信息输出值, 因此想要模拟传感器是非常具有挑战性的. 这些传感器为识别手机和模拟器提供了新的机会.</p>

<p>比如在论文<code class="highlighter-rouge">Rage Against the Virtual Machine: Hindering Dynamic Analysis of Android Malware</code>中, 作者对Android模拟器的加速器进行测试, 作者发现Android模拟器上的传感器会在相同的时间间隔内(观测结果是0.8s, 标准偏差为0.003043)产生相同的值. 显然对于现实世界的传感器, 这是不可能的.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-acc-cdf.png" alt="acc-cdf.png" /></p>

<p>于是我们可以先注册一个传感器监听器, 如果注册失败, 就可能是在模拟器中(排除实际设备不支持传感器的可能性). 如果注册成功, 那么检查<code class="highlighter-rouge">onSensorChanged</code>回调方法, 如果在连续调用这个方法的过程所观察到的传感器值或时间间隔相同, 那么就可以认定是在模拟器环境中.</p>

<h2 id="qemu任务调度">QEMU任务调度</h2>

<p>出于性能优化的原因, QEMU在每次执行指令时都不会主动更新程序计数器(PC), 由于翻译指令在本地执行, 而增加PC需要额外的指令带来开销. 所以QEMU只在执行那些从线性执行过程里中断的指令(例如分支指令)时才会更新程序计数器. 这也就导致在执行一些基本块的期间如果发生了调度事件, 那么也没有办法恢复调度前的PC, 也是出于这个原因, QEMU仅在执行基本块后才发生调度事件, 绝不会执行的过程中发生.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-sche-point.png" alt="sche-point.png" /></p>

<p>如上图, 因为调度可能在任意时间发生, 所以在非模拟器环境下, 会观察到大量的调度点. 而在模拟器环境中, 只能看到特定的调度点.</p>

<h2 id="smc识别">SMC识别</h2>

<p>因为QEMU会跟踪代码页的改动, 于是存在一种新颖的方法来检测QEMU–使用自修改代码(Self-Modifying Code, SMC)引起模拟器和实际设备之间的执行流变化.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-memory.png" alt="memory.png" /></p>

<p>ARM处理器包含有两个不同的缓冲Cache, 一个用于指令访问(I-Cache), 而另一个用于数据访问(D-Cache). 但如ARM这样的哈佛架构并不能保证I-Cache和D-Cache之间的一致性. 因此CPU有可能在新代码片已经写入主存后执行旧的代码片(也许是无效的).</p>

<p>这个问题可以通过强迫两个缓存一致得到解决, 这有两步:</p>

<ol>
  <li>清理主存, 以便将D-Cache中新写入的代码移入主存</li>
  <li>使I-Cache无效, 以便它可以用主存的新内容重新填充.</li>
</ol>

<p>在原生Android代码中, 可以使用<code class="highlighter-rouge">cacheflush</code>函数, 该函数通过系统调用完成上述操作.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/anti-emu-diff.png" alt="diff.png" /></p>

<p>识别代码, 使用一个具有读写权限的内存, 其中包含两个不同函数f1和f2的代码, 这两个函数其实很简单, 只是单纯在一个全局字符串变量的末尾附加各自的函数名称, 这两个函数会在循环里交错执行, 这样就可以通过结果的字符串推断出函数调用序列.</p>

<p>如前所述, 我们调用<code class="highlighter-rouge">cacheflush</code>来同步缓存. 在实际设备和模拟器上运行代码得到的结果是相同的–每次执行都会产生一致的函数调用序列.</p>

<p>接下来我们移除调用<code class="highlighter-rouge">cacheflush</code>, 执行相同的操作. 那么在实际设备中, 我们每次运行都会观察到一个随机的函数调用序列, 这也如前所述的那样, 因为I-Cache可能包含一些旧指令, 每次调用的时候缓存都不同步所导致的.</p>

<p>而模拟器环境却不会发生这样的情况, 而且函数调用序列会跟之前没有移除<code class="highlighter-rouge">cacheflush</code>时完全相同, 也就是每次函数调用前缓存都是一致的. 这是因为QEMU会跟踪代码页上的修改, 并确保生成的代码始终与内存中的目标指令匹配, 因此QEMU会放弃之前版本的代码翻译并重新生成新代码.</p>

<h2 id="结语">结语</h2>

<p>看到这里会不会已经觉得检测方法够多了. 可是我还只是看了13年14年的资料. 有关近几年的资料还未涉及.</p>

<p>最后我就把这些检测方法整合在一张<a href="http://od7mpc53s.bkt.clouddn.com/detect-android-emulator.png">思维导图</a>里供大家一览, 欢迎大家和我交流带带我</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="https://github.com/strazzere/anti-emulator">strazzere/anti-emulator</a>: 首次发表于2013年HitCon, 提出了检测虚拟机的一些方法和思路, 应该是Android模拟器检测的开山之作了, 本文也主要基于该仓库进行讲解.</li>
  <li><a href="http://www.syssec-project.eu/m/page-media/3/petsas_rage_against_the_virtual_machine.pdf">Rage Against the Virtual Machine: Hindering Dynamic Analysis of Android Malware</a>: 通过任务调度检测和使用SMC识别都是参考于这篇论文. 这篇论文和下面这篇论文十分有参考价值, 值得一读.</li>
  <li><a href="https://users.ece.cmu.edu/~tvidas/papers/ASIACCS14.pdf">Evading Android Runtime Analysis via Sandbox Detection</a>: 论文中提出了大量的检测Android运行环境的方法和思路, 内容丰富且十分全面, 也值得一读.</li>
  <li><a href="https://github.com/CalebFenton/AndroidEmulatorDetect">CalebFenton/AndroidEmulatorDetect</a>: 这个仓库其实是整合了一些文章和仓库中的检测方法和代码, 而且并不全面, 不过倒是给出了很多参考链接, 我顺藤摸瓜.</li>
  <li><a href="https://stackoverflow.com/questions/2799097/how-can-i-detect-when-an-android-application-is-running-in-the-emulator">How can I detect when an Android application is running in the emulator?</a>: 网友给出了很多解决方法. 但实际上并不全面, 也只是模拟器检测中的冰山一角罢了. 毕竟可以检测的地方多了去了.</li>
  <li><a href="http://cb.drops.wiki/drops/mobile-13486.html">利用任务调度特性检测Android模拟器</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>恶意软件&quot;TSCookie&quot;介绍</title>
      <link href="http://www.vancir.com/2018/03/06/tscookie/"/>
      <pubDate>2018-03-06T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/03/06/tscookie</guid>
      <content:encoded><![CDATA[<p>2018年1月17日左右, 社交媒体上开始出现一些关于恶意邮件的报道, 这些邮件声称来自日本的教育部, 文化部, 体育部和科技部. 这些邮件里包含有指向恶意软件”TSCookie”的URL链接(趋势科技将其称为为PLEAD恶意软件, 因为PLEAD取自趋势科技过往捕获到的一次APT攻击活动, 故本文中我们将该恶意软件命名为”TSCookie”). TSCookie在2015年在野外被发现, 并且怀疑黑客组织”BlackTech”与此次攻击活动有关. JPCERT/CC证实称, 使用恶意软件的敌对团伙已经对日本组织进行了针对性的攻击. 本文将介绍我们在分析TSCookie后的成果.</p>

<h2 id="tscookie概述">TSCookie概述</h2>

<p>下图描述了TSCookie的执行流程:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-1.png" alt="1.png" /></p>

<p>TSCookie本身只是用作一个下载器, 通过从C&amp;C服务器下载模块来扩展功能. 我们所检查的样本下载了一个具有传出信息和其他功能的DLL文件(以下简称”TSCookieRAT”). 下载的模块仅在内存上运行</p>

<p>TSCookie和TSCookieRAT的行为将在下面的章节中详细解释.</p>

<h2 id="tscookie行为">TSCookie行为</h2>

<p>TSCookie使用HTTP协议与C&amp;C服务器进行通信, 并下载用于加载模块的”模块”和”加载程序”. 恶意软件的资源中有一个加密的DLL文件. 当恶意软件被执行时, DLL文件被加载进内存并执行. DLL文件会执行一些主要功能, 例如与C&amp;C服务器进行通信. (在某些情况下, 主要功能部分并未经过加密并且存储在恶意软件中, 还有一些样本会启动另一个进程并注入解密后的DLL文件.) 恶意软件的配置信息包括有C&amp;C服务器信息且同时使用RC4进行加密. 有关配置的详细信息, 请参阅附录A.</p>

<p>以下是TSCookie在开始时发送的HTTP GET请求的示例. 出站消息被编码包含在Cookie头信息中.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /Default.aspx HTTP/1.1
Cache-Control: no-cache
Connection: Keep-Alive
Date: Thu, 18 Jan 2018 10:20:55 GMT
Pragma: no-cache
Accept: */*
Cookie: 1405D7CD01C6978E54E86DA9525E1395C4DD2F276DD28EABCC3F6201ADAA66F55C15352D29D0FFE51BC9D431EB23E8E58959653D9366E372B5CFCC49BB
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Win32)
Host:[host name]:443
</code></pre></div></div>

<p>包含在Cookie头中的数据经RC4加密(密钥是Date标头值). 数据格式请参考附录B表B-1.</p>

<p>通过这个HTTP GET请求获得的数据使用一个8字节值进行RC4加密, 这个8字节值由配置中的一个固定值(附录A, 表A-1)和发送数据中的一个值(在附录B表B-1中, “根据系统信息生成的4字节值”)组成. 这些数据还包括有模块的加载程序.</p>

<p>TSCookie随后下载一个模块. 以下是下载模块的HTTP POST请求示例.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /Default.aspx HTTP/1.1
Connection: Keep-Alive
Date: Thu, 18 Jan 2018 10:30:55 GMT
Content-Type: application/x-www-form-urlencoded
Accept: */*
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Win32)
Content-Length: 34
Host: [host name]:443

[data]
</code></pre></div></div>

<p>发送的数据也同样是由RC4加密的(密钥是Date标头值). 数据格式请参考附录B表B-2. 通过该HTTP POST请求获得的数据也经过RC4加密, 使用的密钥与HTTP GET请求中密钥相同. 下载下来的模块可以先载入到内存中, 然后调用由HTTP GET请求获得的加载程序来得到执行.</p>

<h2 id="tscookierat行为">TSCookieRAT行为</h2>

<p>TSCookie在加载TSCookieRAT时提供一些参数比如C&amp;C服务器信息. 程序一旦执行后, 感染主机的信息将通过HTTP POST请求发送到外部服务器.(HTTP头信息格式与TSCookie相同.)</p>

<p>数据从开头到0x14(密钥为Date标头值)都有经RC4加密, 紧跟着的是感染主机的信息(主机名, 用户名, 操作系统版本等等). 数据格式请参考附录C表C-1.</p>

<p>下图是发送感染主机信息(已解码)的示例.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-2.png" alt="2.png" /></p>

<p>之后, TSCookieRAT发送一个HTTP GET请求.(HTTP头信息依旧与TSCookie相同.) 通过该请求, C&amp;C服务器发出命令, 而TSCookieRAT执行下列功能. (关于接收到的数据, 请参阅附录C, 表C-2, 关于命令列表, 请参阅附录D, 表D-1.)</p>

<ul>
  <li>执行任意shell命令</li>
  <li>发送驱动器信息</li>
  <li>发送系统信息</li>
  <li>进行文件操作</li>
  <li>从Internet Explorer，Edge，Firefox，Chrome，Outlook处收集密码</li>
</ul>

<p>命令执行的结果以第一个HTTP POST请求同样的格式发送出去(发送感染主机信息). 从C&amp;C服务器发出的命令并未经过编码. 以下是执行列举进程和模块信息的命令时, 发送数据(已解码)的示例。</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-3.png" alt="3.png" /></p>

<h2 id="tscookie解码工具">TSCookie解码工具</h2>

<p>JPCERT/CC制作了一个工具, 用于解码和提取TSCookie的配置信息. 你可以访问Github使用该工具:</p>

<p>JPCERTCC/aa-tools · GitHub
<a href="https://github.com/JPCERTCC/aa-tools/blob/master/tscookie_decode.py">https://github.com/JPCERTCC/aa-tools/blob/master/tscookie_decode.py</a></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/tscookie-4.png" alt="4.png" /></p>

<h2 id="结语">结语</h2>

<p>使用TSCookie的敌对团伙一直在利用各种类型的恶意软件对日本组织进行攻击. 由于这次攻击行动很可能持续下去. JPCERT/CC将继续谨慎地观察这一趋势.</p>

<p>附录E列出了为本文所检查的样本的散列值. 附录F中还列出了与TSCookie相关的一些目标主机. 请确保您的设备没有与这些主机通信.</p>

<p>如有任何疑问，请联系global-cc [at] jpcert.or.jp</p>

<p>Shusei Tomonaga</p>

<h2 id="参考文章">参考文章</h2>

<p>[1] piyolog: Summary on Ministry of Education, Culture, Sports, Science and Technology Scam in January 2018 (Japanese)</p>

<p><a href="http://d.hatena.ne.jp/Kango/20180119/1516391079">http://d.hatena.ne.jp/Kango/20180119/1516391079</a></p>

<p>[2] Trend Micro: Following the Trail of BlackTech’s Cyber Espionage Campaigns</p>

<p><a href="https://documents.trendmicro.com/assets/appendix-following-the-trail-of-blacktechs-cyber-espionage-campaigns.pdf">https://documents.trendmicro.com/assets/appendix-following-the-trail-of-blacktechs-cyber-espionage-campaigns.pdf</a></p>

<p>[3] Trend Micro: Following the Trail of BlackTech’s Cyber Espionage Campaigns</p>

<p><a href="https://blog.trendmicro.com/trendlabs-security-intelligence/following-trail-blacktech-cyber-espionage-campaigns/">https://blog.trendmicro.com/trendlabs-security-intelligence/following-trail-blacktech-cyber-espionage-campaigns/</a></p>

<h2 id="附录-a-tscookie-配置信息">附录 A: TSCookie 配置信息</h2>

<p>表A: 配置信息清单</p>

<table>
  <thead>
    <tr>
      <th>偏移值</th>
      <th>描述</th>
      <th>备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x000</td>
      <td>主机1标志</td>
      <td>如果为0x01则进行通讯</td>
    </tr>
    <tr>
      <td>0x004</td>
      <td>主机1的端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x008</td>
      <td>主机1的端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x010</td>
      <td>主机1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x100</td>
      <td>主机2标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x104</td>
      <td>主机2的端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x108</td>
      <td>主机2的端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x110</td>
      <td>主机2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x200</td>
      <td>主机3标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x204</td>
      <td>主机3的端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x208</td>
      <td>主机3的端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x210</td>
      <td>主机3</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x300</td>
      <td>主机4标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x304</td>
      <td>主机4端口号1</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x308</td>
      <td>主机4端口号2</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x310</td>
      <td>主机4</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x400</td>
      <td>代理服务器</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x480</td>
      <td>代理端口号</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x484</td>
      <td>代理配置标志</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x500</td>
      <td>ID号</td>
      <td> </td>
    </tr>
    <tr>
      <td>0x604</td>
      <td>固定值</td>
      <td>4字节的RC4密钥 (0x925A765D)</td>
    </tr>
    <tr>
      <td>0x89C</td>
      <td>暂停时间</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="附录-b-tscookie-发出接收的数据">附录 B: TSCookie 发出/接收的数据</h2>

<p>表 B-1: Cookie头中包含的数据的格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>根据系统信息生成的4字节 (*)</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>0x10050014</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>4</td>
      <td>0x10001</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>4</td>
      <td>0xAB1</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>4</td>
      <td>0x04</td>
    </tr>
    <tr>
      <td>0x14</td>
      <td>4</td>
      <td>根据系统信息生成的4字节</td>
    </tr>
    <tr>
      <td>0x18</td>
      <td>-</td>
      <td>随机数据</td>
    </tr>
  </tbody>
</table>

<p>(*) 表示是用固定值（0x925A765D）加密的RC4值</p>

<p>表 B-2: HTTP POST的数据格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>根据系统信息生成的4字节</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>0x10050014</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>4</td>
      <td>0x10001</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>4</td>
      <td>0xAAD</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>4</td>
      <td>位于0x14后的数据长度</td>
    </tr>
    <tr>
      <td>0x14</td>
      <td>-</td>
      <td>随机数据</td>
    </tr>
  </tbody>
</table>

<h2 id="附录-c-tscookierat-发出接收的数据">附录 C: TSCookieRAT 发出/接收的数据</h2>

<p>表 C-1: HTTP POST的数据格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>根据系统信息生成的4字节</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>0x10050014</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>4</td>
      <td>0x10001</td>
    </tr>
    <tr>
      <td>0x0C</td>
      <td>4</td>
      <td>0xAAD</td>
    </tr>
    <tr>
      <td>0x10</td>
      <td>4</td>
      <td>位于0x14后的数据长度</td>
    </tr>
    <tr>
      <td>0x14</td>
      <td>-</td>
      <td>感染主机信息(使用”根据系统信息生成的4字节值”作为密钥进行RC4加密</td>
    </tr>
  </tbody>
</table>

<p>表 C-2: 接收到的数据格式</p>

<table>
  <thead>
    <tr>
      <th>偏移</th>
      <th>长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x00</td>
      <td>4</td>
      <td>命令</td>
    </tr>
    <tr>
      <td>0x04</td>
      <td>4</td>
      <td>位于0x8后的数据长度</td>
    </tr>
    <tr>
      <td>0x08</td>
      <td>-</td>
      <td>参数</td>
    </tr>
  </tbody>
</table>

<h2 id="附录dtscookierat使用的命令">附录D：TSCookieRAT使用的命令</h2>

<p>表 D-1: 命令清单</p>

<table>
  <thead>
    <tr>
      <th>值</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x912</td>
      <td>配置暂停时间</td>
    </tr>
    <tr>
      <td>0x930</td>
      <td>列举进程和模块</td>
    </tr>
    <tr>
      <td>0x932</td>
      <td>终止</td>
    </tr>
    <tr>
      <td>0x934</td>
      <td>启动远程shell</td>
    </tr>
    <tr>
      <td>0x935</td>
      <td>执行远程shell指令</td>
    </tr>
    <tr>
      <td>0x936</td>
      <td>关闭远程shell</td>
    </tr>
    <tr>
      <td>0x946</td>
      <td>获取IP地址</td>
    </tr>
    <tr>
      <td>0x950</td>
      <td>执行文件 (windows会有显示)</td>
    </tr>
    <tr>
      <td>0x951</td>
      <td>执行文件 (windows不会显示)</td>
    </tr>
    <tr>
      <td>0x952</td>
      <td>发送消息</td>
    </tr>
    <tr>
      <td>0x953</td>
      <td>发送驱动消息</td>
    </tr>
    <tr>
      <td>0x954</td>
      <td>发送文件清单</td>
    </tr>
    <tr>
      <td>0x955</td>
      <td>发送文件大小</td>
    </tr>
    <tr>
      <td>0x956</td>
      <td>发送文件</td>
    </tr>
    <tr>
      <td>0x957</td>
      <td>关闭对象句柄</td>
    </tr>
    <tr>
      <td>0x958</td>
      <td>选择文件发送 (发送文件同时执行0x955, 0x956命令)</td>
    </tr>
    <tr>
      <td>0x959</td>
      <td>下载文件</td>
    </tr>
    <tr>
      <td>0x95A</td>
      <td>删除文件</td>
    </tr>
    <tr>
      <td>0x95C</td>
      <td>移动文件</td>
    </tr>
    <tr>
      <td>0x95E</td>
      <td>-</td>
    </tr>
    <tr>
      <td>0x960</td>
      <td>-</td>
    </tr>
    <tr>
      <td>0x96B</td>
      <td>获取windows窗体名</td>
    </tr>
    <tr>
      <td>0x96E</td>
      <td>从Internet Explorer, Edge, Firefox, Chrome, Outlook收集密码</td>
    </tr>
  </tbody>
</table>

<h2 id="附录-e-样本的sha-256值">附录 E: 样本的SHA-256值</h2>

<p>TSCookie</p>

<ul>
  <li>6d2f5675630d0dae65a796ac624fb90f42f35fbe5dec2ec8f4adce5ebfaabf75</li>
  <li>cdf0e4c415eb55bccb43a650e330348b63bc3cbb53f71a215c44ede939b4b830</li>
  <li>17f1996ad7e602bd2a7e9524d7d70ee8588dac51469b08017df9aaaca09d8dd9</li>
  <li>1fa7cbe57eedea0ebc8eb37b91e7536c07be7da7775a6c01e5b14489387b9ca8</li>
  <li>e451a1e05c0cc363a185a98819cd2af421ac87154702bf72007ecc0134c7f417</li>
  <li>1da9b4a84041b8c72dad9626db822486ce47b9a3ab6b36c41b0637cd1f6444d6</li>
  <li>35f966187098ac42684361b2a93b0cee5e2762a0d1e13b8d366a18bccf4f5a91</li>
  <li>0683437aebd980c395a83e837a6056df1a21e137e875f234d1ed9f9a91dfdc7f</li>
  <li>0debbcc297cb8f9b81c8c217e748122243562357297b63749c3847af3b7fd646</li>
  <li>96306202b0c4495cf93e805e9185ea6f2626650d6132a98a8f097f8c6a424a33</li>
  <li>6b66c6d8859dfe06c0415be4df2bd836561d5a6eabce98ddd2ee54e89e37fd44</li>
  <li>06a9c71342eeb14b7e8871f77524e8acc7b86670411b854fa7f6f57c918ffd2b</li>
  <li>20f7f367f9cb8beca7ce1ba980fafa870863245f27fea48b971859a8cb47eb09</li>
  <li>f16befd79b7f8ffdaf934ef337a91a5f1dc6da54c4b2bee5fe7a0eb38e8af39e</li>
  <li>12b0f1337bda78f8a7963d2744668854d81e1f1b64790b74d486281bc54e6647</li>
  <li>201bf3cd2a723d6c728d18a9e41ff038549eac8406f453c5197a1a7b45998673</li>
  <li>5443ee54a532846da3182630e2bb031f54825025700bcd5f0e34802e7345c7b2</li>
  <li>39d7d764405b9c613dff6da4909d9bc46620beee7a7913c4666acf9e76a171e4</li>
  <li>afe780ba2af6c86babf2d0270156da61f556c493259d4ca54c67665c17b02023</li>
  <li>4a8237f9ecdad3b51ffd00d769e23f61f1e791f998d1959ad9b61d53ea306c09</li>
  <li>203c924cd274d052e8e95246d31bd168f3d8a0700a774c98eff882c8b8399a2f</li>
</ul>

<p>TSCookieRAT</p>

<ul>
  <li>2bd13d63797864a70b775bd1994016f5052dc8fd1fd83ce1c13234b5d304330d</li>
</ul>

<h2 id="附录-f-与tscookie相关的目标主机">附录 F: 与TSCookie相关的目标主机</h2>

<ul>
  <li>220.130.216.76</li>
  <li>60.244.52.29</li>
  <li>45.76.102.145</li>
  <li>jpcerts.jpcertinfo.com</li>
  <li>jpcert.ignorelist.com</li>
  <li>twnicsi.ignorelist.com</li>
  <li>twcertcc.jumpingcrab.com</li>
  <li>okinawas.ssl443.org</li>
  <li>apk36501.flnet.org</li>
  <li>appinfo.fairuse.org</li>
  <li>carcolors.effers.com</li>
  <li>edu.microsoftmse.com</li>
  <li>eoffice.etowns.org</li>
  <li>epayplus.flnet.org</li>
  <li>fatgirls.fatdiary.org</li>
  <li>gethappy.effers.com</li>
  <li>iawntsilk.dnset.com</li>
  <li>inewdays.csproject.org</li>
  <li>ktyguxs.dnset.com</li>
  <li>lang.suroot.com</li>
  <li>langlang.dnset.com</li>
  <li>longdays.csproject.org</li>
  <li>lookatinfo.dnset.com</li>
  <li>newtowns.flnet.org</li>
  <li>ntp.ukrootns1.com</li>
  <li>office.dns04.com</li>
  <li>savecars.dnset.com</li>
  <li>splashed.effers.com</li>
  <li>sslmaker.ssl443.org</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>the White Rabbit CrackMe 解答</title>
      <link href="http://www.vancir.com/2018/02/06/solve-white-habbit-crackme/"/>
      <pubDate>2018-02-06T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/02/06/solve-white-habbit-crackme</guid>
      <content:encoded><![CDATA[<p>Crackme文件可以从此处下载: <a href="https://hshrzd.wordpress.com/2018/02/03/white-rabbit-crackme/">White Rabbit crackme!</a></p>

<p>因为crackme里稍微使用了混淆和一些像恶意程序的把戏, 所以可能会被一些杀毒软件标记为恶意程序, 所以也建议在虚拟机下运行.</p>

<p>这个crackme运行的截图如下:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/1.png" alt="1.png" /></p>

<p>OK, 首先要做的第一件事就是将其载入到IDA中(我这里使用的是刚刚发布的<a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">IDA 7的免费版本</a>). 通过搜索字符串<code class="highlighter-rouge">Password#1</code>来看它的交叉引用以及前后都发生了些什么.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/2.png" alt="2.png" /></p>

<p>就这了! 我们可以看到它被<code class="highlighter-rouge">sub_4034D0</code>所引用. 现在我们将跟随到引用处, 来看看接下来发生什么</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/3.png" alt="3.png" /></p>

<p>在<code class="highlighter-rouge">sub_403D90</code>中有一些初始化操作, 随后在<code class="highlighter-rouge">sub_404150</code>的结果与可疑值<code class="highlighter-rouge">0x57585384</code>的比较后又一个分支跳转. 子分支中的<code class="highlighter-rouge">sub_403990</code>输出了一些提示语以及后续一些有关接受用户输入的内容.</p>

<p>我们首先来看初始化部分(<code class="highlighter-rouge">sub_403D90</code>):</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/4.png" alt="4.png" /></p>

<p>函数取了两个参数, 内容看上去也非常清楚: 通过给出的标识符查找资源文件, 加载资源文件, 确定它的文件大小, 然后申请内存空间并将资源文件的数据复制进去. 该函数返回那个新申请的内存空间的指针, 并将资源文件的大小存储在第一个参数中.</p>

<p>现在我们唯一需要注意的就是图中的<code class="highlighter-rouge">sub_406A70</code>, 它取了3个参数(target pointer, source pointer 以及 data size)并且看起来非常像是<code class="highlighter-rouge">memcpy</code>(或<code class="highlighter-rouge">memmove</code>, 是哪个不重要, 因为内存区域没有重叠). 但是函数内的代码却包含有大量的分支, 难以分析. 所以我们不能确定它有没有在复制的过程中以某种方式修改了数据(比如, 解密数据). 最简便的检查方式就是在调试器里动态分析, 比较函数返回时, <code class="highlighter-rouge">soure</code>和<code class="highlighter-rouge">target</code>内存是否有区别.</p>

<p>我使用<code class="highlighter-rouge">[x64Dbg](https://x64dbg.com/)</code>来分析. 在启动调试器后我们打开crackme, 调试器会自动运行程序并暂停在入口点位置.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/5.png" alt="5.png" /></p>

<p>现在我们需要在我们感兴趣的函数返回处设下一个断点. 指令地址是<code class="highlighter-rouge">0x00403DF9</code>(给定<code class="highlighter-rouge">.text</code>段的基址是<code class="highlighter-rouge">0x00401000</code>). 你可以根据内存布局来了解真正<code class="highlighter-rouge">.text</code>段载入的基址(我这里是<code class="highlighter-rouge">0x00281000</code>). 因此我的实际断点地址应该是<code class="highlighter-rouge">0x00283DF9</code>.</p>

<p>现在我们用<code class="highlighter-rouge">bp 0x00283DF9</code>命令设下断点, 继续执行触发断点. 然后我们右键点击右侧面板<code class="highlighter-rouge">ebx</code>和<code class="highlighter-rouge">edi</code>寄存器的值, 选择在数据窗口跟随. 现在我们就可以确认<code class="highlighter-rouge">sub_406A70</code>仅仅复制了内存<code class="highlighter-rouge">as is</code>, 我们可以放心地将该函数重命名为更易理解的<code class="highlighter-rouge">memcpy</code>. 同样我们也把<code class="highlighter-rouge">sub_403D90</code>重命名为<code class="highlighter-rouge">loadResource</code></p>

<p>现在我们来分析<code class="highlighter-rouge">sub_404150</code></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/6.png" alt="6.png" /></p>

<p>映入眼帘的是一个常量<code class="highlighter-rouge">0x82F63B78</code>. 通过google搜索知道说这是一个用于CRC32计算的多项式值. 代码里看也有从输入缓冲区里对每个字节的值异或累加, 随后再移位/异或8次. 因此它确实是一个<code class="highlighter-rouge">crc32c</code>计算函数.</p>

<p>在重命名和初期的分析后, 我们再来看看改动后的代码</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/7.png" alt="7.png" /></p>

<p>注意: 也许你会对lea/cmovnb指令有些许困惑. 不过很好解释: <code class="highlighter-rouge">lpPasswordText</code>的值实际上是如下的结构体:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="k">static</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">dynamic</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这可能就是栈上<code class="highlighter-rouge">std::string</code>的形式. 当字符串仅有<code class="highlighter-rouge">static</code>数组那么长时, 不会申请额外的内存空间(并且<code class="highlighter-rouge">static</code>缓冲区的地址用<code class="highlighter-rouge">lea</code>加载). 相反如果超出了缓冲区, <code class="highlighter-rouge">cmovnb</code>会获取<code class="highlighter-rouge">dynamic</code>域所分配的内存的指针. 最后, <code class="highlighter-rouge">eax</code>会获得指向真正字符串数据的指针, 不论其位置具体在哪.</p>

<p>因此, <code class="highlighter-rouge">sub_401000</code>读取键盘输入到<code class="highlighter-rouge">std::string</code>, <code class="highlighter-rouge">std::string</code>随后传递给<code class="highlighter-rouge">crc32c</code>函数. 现在我们知道说我们的password应该含有CRC32的<code class="highlighter-rouge">0x57585384</code>, 我们可以根据这个条件判断我们是否获取到了正确的password.</p>

<p>现在我们来假定password跟给出的CRC32值相匹配, 来继续往下分析:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/8.png" alt="8.png" /></p>

<p>有趣的第一点就是<code class="highlighter-rouge">sub_403C90</code>, 因为它同时取了<code class="highlighter-rouge">password</code>和<code class="highlighter-rouge">资源数据</code>作为参数.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/9.png" alt="9.png" /></p>

<p>很显然这里是一个异或加密的操作. 它首先确定<code class="highlighter-rouge">password</code>的长度, 随后用相应的<code class="highlighter-rouge">password</code>字符对输入缓冲区的每一个字节进行异或.</p>

<p>随后生成一个临时文件名, 将解密的资源数据内容写入到该文件(在函数<code class="highlighter-rouge">sub_403090</code>里). 待一切完成, 却也再没有给出任何关于<code class="highlighter-rouge">password</code>的线索了. 我们来看一下<code class="highlighter-rouge">sub_403D20</code>, 该函数接收新创建的文件名并执行了一些操作.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/10.png" alt="10.png" /></p>

<p>OK, 现在事情已经越发清晰. crackme尝试设置新生成的文件作为桌面壁纸, 因此很显然这个文件应该是一个图片.</p>

<p>现在我们要提取crackme里的资源文件, 看看我们能否有所收获. 你可以使用任意的资源编辑软件, 例如: <a href="https://medium.com/@alexskalozub/solving-the-white-rabbit-crackme-d6b627c02ad4">Resource Hacker</a></p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/11.png" alt="11.png" /></p>

<p>我们可以看到它的大小是<code class="highlighter-rouge">6,220,854</code>字节, 对于一个图像来说已经很大了, 据此我们猜测, 这是一个无压缩的BMP图像文件.</p>

<p>BMP格式已经是众所周知, 并且有文档说明. 文件起始于一个<code class="highlighter-rouge">"BM"</code>签名, 随后是<code class="highlighter-rouge">4字节</code>的文件大小(小端序), 接着是两个<code class="highlighter-rouge">4字节</code>的保留字(全0), 一个<code class="highlighter-rouge">4字节</code>存储着位图数据的起始位置, 再紧接着是<code class="highlighter-rouge">40字节</code>的位图信息头(起始的是该信息头所占用的字节数). 再下面就是各种关于BMP信息了, 我们现在也不知道.</p>

<p>由于我们得知了真正的文件大小值, 所以我们可以较准确地推测出文件的前18个字节.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>资源文件里的字节:
24 22 5A 80 31 77 5F 64 61 5F 44 61 62 62 41 74 7A 66
期待的结果:
42 4D 36 EC 5E 00 00 00 00 00 36 00 00 00 28 00 00 00
</code></pre></div></div>

<p>现在我们逐个将实际资源文件里的字节和说期望的字节进行异或, 这样我们就可以恢复出部分key的内容. 如果幸运的话, 我们可以获得一个完整的key</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>66 6F 6C 6C 6F 77 5F 64 61 5F 72 61 62 62 69 74 7A 66
</code></pre></div></div>

<p>异或得到的结果是<code class="highlighter-rouge">"follow_da_rabbitzf"</code>. 最后的这一个<code class="highlighter-rouge">"f"</code>也许是重复的下一个key的起始字母, 也许就是这个key的一部分. 最简单的检查方法就是将其输入到crackme里看看结果如何.</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/12.png" alt="12.png" /></p>

<p>Yeah. 我们的结果是正确的. 我们再继续.</p>

<p>现在我们有一个超酷的桌面壁纸, 然后还有另外一个<code class="highlighter-rouge">password</code>需要破解出来. 我们再次搜索<code class="highlighter-rouge">"Password#2"</code>字符串并跟随到交叉引用处:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/13.png" alt="13.png" /></p>

<p>这看起来跟之前非常相似, 因此我们自己向下来到解密开始的部分:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/14.png" alt="14.png" /></p>

<p>有趣的部分在<code class="highlighter-rouge">sub_403E10</code>, 这里在写入数据到文件之前进行了解密:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/15.png" alt="15.png" /></p>

<p>这里根据<code class="highlighter-rouge">password</code>导出一个<code class="highlighter-rouge">AES128</code>的密钥(使用<code class="highlighter-rouge">SHA256</code>作为密钥导出算法)并用于解密资源数据.</p>

<p>没有必要去破解AES加密(恐怕就连NSA也无法破解), 我们只知道<code class="highlighter-rouge">password</code>的crc32值. 很显然不足以通过暴力破解的手段来获取它(我尝试过!). 但等等, 我们有一个壁纸啊! 或许在壁纸里会有某些隐藏的信息!</p>

<p>用图像编辑器打开并使用”颜色选择”工具:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/16.png" alt="16.png" /></p>

<p>这应该就是我们一直在寻找的key! 接下来继续:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/17.png" alt="17.png" /></p>

<p>但是事情还没结束. 现在我们在临时目录下有一个解密过的可执行文件, 但我们还是没有拿到flag. 我们还需要用IDA继续分析.</p>

<p>因为第二个可执行文件按并没有产生任何字符串信息, 也就难以下手. 我们就来看看导入表情况:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/18.png" alt="18.png" /></p>

<p>这里有一系列的按顺序导入的<code class="highlighter-rouge">ws2_32.dll</code>的函数, 这给我们两个线索:</p>

<ul>
  <li>程序有在进行网络socket操作</li>
  <li>程序有隐藏些什么!</li>
</ul>

<p>因此我们的第一步就是去到这些函数被调用的地方, 并将这些函数重命名为可读性更高更有意义的名称. 序号与之对应的函数名称可以很容易地通过google搜索找到.</p>

<p>现在我们知道了所有的网络操作都在<code class="highlighter-rouge">sub_404480</code>里, 因此接下来仔细看看这个函数. 该函数开始是一个标准流程(<code class="highlighter-rouge">WSAStartup/socket/bind/listen</code>), 所以没太多亮点, 有趣的部分在下图:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/19.png" alt="19.png" /></p>

<p>因此它等待接受一个连接, 从连接中读取4字节, 基于静态缓冲区<code class="highlighter-rouge">buf</code>和接收的数据在<code class="highlighter-rouge">sub_404640</code>中执行一些操作. 如果操作成功转型(函数返回非零值), 它就会将<code class="highlighter-rouge">buf</code>的内容发回给客户端随后关闭连接. 否则它会关闭连接监听新的连接. 所有的操作都是同步的, 所以在<code class="highlighter-rouge">sub_404640</code>成功执行前不会退出函数.</p>

<p>来看看<code class="highlighter-rouge">sub_404640</code>的内容:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/20.png" alt="20.png" /></p>

<p>看起来非常像是一个小的状态机, 成功转移到下一状态时返回1, 有如下几个转移:</p>

<ul>
  <li>从 初始状态(0) 到 ‘Y’ 状态 (如果接收到9)</li>
  <li>从 ‘Y’ 状态 到 ‘E’ 状态 (如果接收到3)</li>
  <li>从 ‘E’ 状态 到 ‘S’ 状态 (如果接收到5)</li>
  <li>接收到其他的任何值, 都会将状态机重置为 初始状态(0)</li>
</ul>

<p>因此, 我们可能需要按顺序发起3个连接, 连到<code class="highlighter-rouge">"server"</code>, 更新状态机到下一状态.</p>

<p>但是我们仍有两个问题需要解决:</p>

<ol>
  <li>我们不知道需要连接到哪一个端口(函数需要取端口号作参数)</li>
  <li>在每次成功转移状态后, 监听的套接字都会关闭</li>
</ol>

<p>因此我们需要找到所有的函数被调用的地方, 然后跟踪看它启动了哪一个端口.</p>

<p>如同我们所预料的那样, 函数被调用了3次(因为有3次合法的状态转移), 并且幸运的是, 它都是在同一个步骤里被调用的:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/21.png" alt="21.png" /></p>

<p>在这里</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/22.png" alt="22.png" /></p>

<p>所以, server一开始开启了端口<code class="highlighter-rouge">1337</code>, 随后是<code class="highlighter-rouge">1338</code>, 最后是<code class="highlighter-rouge">1339</code>. 因此我们首先需要连接到<code class="highlighter-rouge">1337</code>端口并发送<code class="highlighter-rouge">9</code>, 然后连接到<code class="highlighter-rouge">1338</code>端口, 发送<code class="highlighter-rouge">3</code>. 最后连接到<code class="highlighter-rouge">1339</code>端口, 发送<code class="highlighter-rouge">5</code>. 我们可以使用内置的<code class="highlighter-rouge">telnet</code>工具来完成这一操作.</p>

<p>完成上述操作后会打开一个简短视频的YouTube页面:</p>

<p><img src="http://od7mpc53s.bkt.clouddn.com/white-rabbit/23.png" alt="23.png" /></p>

<p>我们成功地拿到了flag. 收工回家!</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Unicorn Engine简介</title>
      <link href="http://www.vancir.com/2018/01/26/unicorn-intro/"/>
      <pubDate>2018-01-26T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/01/26/unicorn-intro</guid>
      <content:encoded><![CDATA[<h2 id="什么是unicorn引擎">什么是Unicorn引擎</h2>

<p>Unicorn是一个轻量级, 多平台, 多架构的CPU模拟器框架. 我们可以更好地关注CPU操作, 忽略机器设备的差异. 想象一下, 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的CPU去完成那些操作, 又或者想要更安全地分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义. 使用CPU模拟器可以很好地帮助我们提供便捷.</p>

<p>它的亮点(这也归功于Unicorn是基于<a href="http://www.qemu.org">qemu</a>而开发的)有:</p>

<ul>
  <li>支持多种架构: Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64).</li>
  <li>对Windows和*nix系统(已确认包含Mac OSX, Linux, *BSD &amp; Solaris)的原生支持</li>
  <li>具有平台独立且简洁易于使用的API</li>
  <li>使用JIT编译技术, 性能表现优异</li>
</ul>

<p>你可以在<a href="http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf">Black Hat USA 2015</a>获悉有关Unicorn引擎的更多技术细节. Github项目主页: <a href="https://github.com/unicorn-engine/unicorn">unicorn</a></p>

<p>尽管它不同寻常, 但它无法模拟整个程序或系统, 也不支持系统调用. 你需要手动映射内存并写入数据进去, 随后你才能从指定地址开始模拟.</p>

<h2 id="应用的情景">应用的情景</h2>

<p>什么时候能够用到Unicorn引擎呢?</p>

<ul>
  <li>你可以调用恶意软件中一些有趣的函数, 而不用创建一个有害的进程.</li>
  <li>用于CTF竞赛</li>
  <li>用于模糊测试</li>
  <li>用于gdb插件, 基于代码模拟执行的插件</li>
  <li>模拟执行一些混淆代码</li>
</ul>

<h2 id="如何安装">如何安装</h2>

<p>安装Unicorn最简单的方式就是使用pip安装, 只要在命令行中运行以下命令即可(这是适合于喜爱用python的用户的安装方法, 对于那些想要使用C的用户, 则需要去官网查看文档编译源码包):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install unicorn
</code></pre></div></div>

<p>但如果你想用源代码进行本地编译的话, 你需要在<a href="http://www.unicorn-engine.org/download/">下载</a>页面中下载源代码包, 然后可以按照以下命令执行:</p>

<ul>
  <li>*nix 平台用户</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>bindings/python
<span class="nv">$ </span><span class="nb">sudo </span>make install
</code></pre></div></div>

<ul>
  <li>Windows平台用户</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>bindings/python
python setup.py install
</code></pre></div></div>

<p>对于Windows, 在执行完上述命令后, 还需要将<a href="http://www.unicorn-engine.org/download/">下载</a>页面的<code class="highlighter-rouge">Windows core engine</code>的所有dll文件复制到<code class="highlighter-rouge">C:\locationtopython\Lib\site-packages\unicorn</code>位置处.</p>

<h2 id="使用unicorn的快速指南">使用unicorn的快速指南</h2>

<p>我们将会展示如何使用python调用unicorn的api以及它是如何轻易地模拟二进制代码. 当然这里用的api仅是一小部分, 但对于入门已经足够了.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">1</span> <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
 <span class="mi">2</span> <span class="kn">from</span> <span class="nn">unicorn</span> <span class="kn">import</span> <span class="o">*</span>
 <span class="mi">3</span> <span class="kn">from</span> <span class="nn">unicorn.x86_const</span> <span class="kn">import</span> <span class="o">*</span>
 <span class="mi">4</span> 
 <span class="mi">5</span> <span class="c"># code to be emulated</span>
 <span class="mi">6</span> <span class="n">X86_CODE32</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x41\x4a</span><span class="s">"</span> <span class="c"># INC ecx; DEC edx</span>
 <span class="mi">7</span> 
 <span class="mi">8</span> <span class="c"># memory address where emulation starts</span>
 <span class="mi">9</span> <span class="n">ADDRESS</span> <span class="o">=</span> <span class="mh">0x1000000</span>
<span class="mi">10</span> 
<span class="mi">11</span> <span class="k">print</span><span class="p">(</span><span class="s">"Emulate i386 code"</span><span class="p">)</span>
<span class="mi">12</span> <span class="k">try</span><span class="p">:</span>
<span class="mi">13</span>     <span class="c"># Initialize emulator in X86-32bit mode</span>
<span class="mi">14</span>     <span class="n">mu</span> <span class="o">=</span> <span class="n">Uc</span><span class="p">(</span><span class="n">UC_ARCH_X86</span><span class="p">,</span> <span class="n">UC_MODE_32</span><span class="p">)</span>
<span class="mi">15</span> 
<span class="mi">16</span>     <span class="c"># map 2MB memory for this emulation</span>
<span class="mi">17</span>     <span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
<span class="mi">18</span> 
<span class="mi">19</span>     <span class="c"># write machine code to be emulated to memory</span>
<span class="mi">20</span>     <span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="n">X86_CODE32</span><span class="p">)</span>
<span class="mi">21</span> 
<span class="mi">22</span>     <span class="c"># initialize machine registers</span>
<span class="mi">23</span>     <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_ECX</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">)</span>
<span class="mi">24</span>     <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_EDX</span><span class="p">,</span> <span class="mh">0x7890</span><span class="p">)</span>
<span class="mi">25</span> 
<span class="mi">26</span>     <span class="c"># emulate code in infinite time &amp; unlimited instructions</span>
<span class="mi">27</span>     <span class="n">mu</span><span class="o">.</span><span class="n">emu_start</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="n">ADDRESS</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">X86_CODE32</span><span class="p">))</span>
<span class="mi">28</span> 
<span class="mi">29</span>     <span class="c"># now print out some registers</span>
<span class="mi">30</span>     <span class="k">print</span><span class="p">(</span><span class="s">"Emulation done. Below is the CPU context"</span><span class="p">)</span>
<span class="mi">31</span> 
<span class="mi">32</span>     <span class="n">r_ecx</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_ECX</span><span class="p">)</span>
<span class="mi">33</span>     <span class="n">r_edx</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_EDX</span><span class="p">)</span>
<span class="mi">34</span>     <span class="k">print</span><span class="p">(</span><span class="s">"&gt;&gt;&gt; ECX = 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span><span class="n">r_ecx</span><span class="p">)</span>
<span class="mi">35</span>     <span class="k">print</span><span class="p">(</span><span class="s">"&gt;&gt;&gt; EDX = 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span><span class="n">r_edx</span><span class="p">)</span>
<span class="mi">36</span> 
<span class="mi">37</span> <span class="k">except</span> <span class="n">UcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="mi">38</span>     <span class="k">print</span><span class="p">(</span><span class="s">"ERROR: </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果如下:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python test1.py 
Emulate i386 code
Emulation <span class="k">done</span><span class="nb">.</span> Below is the CPU context
<span class="o">&gt;&gt;&gt;</span> ECX <span class="o">=</span> 0x1235
<span class="o">&gt;&gt;&gt;</span> EDX <span class="o">=</span> 0x788f
</code></pre></div></div>

<p>样例里的注释已经非常直观, 但我们还是对每一行代码做出解释:</p>
<ul>
  <li>行号2~3: 在使用Unicorn前导入<code class="highlighter-rouge">unicorn</code>模块. 样例中使用了一些x86寄存器常量, 所以也需要导入<code class="highlighter-rouge">unicorn.x86_const</code>模块</li>
  <li>行号6: 这是我们需要模拟的二进制机器码, 使用十六进制表示, 代表的汇编指令是: “INC ecx” 和 “DEC edx”.</li>
  <li>行号9: 我们将模拟执行上述指令的所在虚拟地址</li>
  <li>行号14: 使用<code class="highlighter-rouge">Uc</code>类初始化Unicorn, 该类接受2个参数: 硬件架构和硬件位数(模式). 在样例中我们需要模拟执行x86架构的32位代码, 我们使用变量<code class="highlighter-rouge">mu</code>来接受返回值.</li>
  <li>行号17: 使用<code class="highlighter-rouge">mem_map </code>方法根据在行号9处声明的地址, 映射2MB用于模拟执行的内存空间. 所有进程中的CPU操作都应该只访问该内存区域. 映射的内存具有默认的读,写和执行权限.</li>
  <li>行号20: 将需要模拟执行的代码写入我们刚刚映射的内存中. <code class="highlighter-rouge">mem_write</code>方法接受2个参数: 要写入的内存地址和需要写入内存的代码.</li>
  <li>行号23~24: 使用<code class="highlighter-rouge">reg_write</code>方法设置<code class="highlighter-rouge">ECX</code>和<code class="highlighter-rouge">EDX</code>寄存器的值</li>
  <li>行号27: 使用<code class="highlighter-rouge">emu_start</code>方法开始模拟执行, 该API接受4个参数: 要模拟执行的代码地址, 模拟执行停止的内存地址(这里是<code class="highlighter-rouge">X86_CODE32</code>的最后1字节处), 模拟执行的时间和需要执行的指令数目. 如果我们像样例一样忽略后两个参数, Unicorn将会默认以无穷时间和无穷指令数目的条件来模拟执行代码.</li>
  <li>行号32~35: 打印输出<code class="highlighter-rouge">ECX</code>和<code class="highlighter-rouge">EDX</code>寄存器的值. 我们使用函数<code class="highlighter-rouge">reg_read</code>来读取寄存器的值.</li>
</ul>

<p>要想查看更多的python示例, 可以查看文件夹<a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings/python">bindings/python</a>下的代码. 而C的示例则可以查看<a href="https://github.com/unicorn-engine/unicorn/tree/master/samples">sample</a>文件夹下的代码.</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="http://www.unicorn-engine.org/">Unicorn Official Site</a></li>
  <li><a href="http://www.unicorn-engine.org/docs/">Quick tutorial on programming with Unicorn - with C &amp; Python.</a></li>
  <li><a href="http://eternal.red/2018/unicorn-engine-tutorial/">Unicorn Engine tutorial</a></li>
  <li><a href="https://platform.avatao.com/paths/8e720072-9169-4d4c-9569-c330ce7fd947/challenges/28f5ae81-6a01-11e6-bdf4-0800200c9a66">Avatao tool tutorials: Unicorn</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>pyc文件结构</title>
      <link href="http://www.vancir.com/2018/01/21/pyc-structure/"/>
      <pubDate>2018-01-21T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2018/01/21/pyc-structure</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>原文链接: <a href="https://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">The structure of .pyc files</a></p>
</blockquote>

<p>简单来说, 一个pyc文件包含以下三块</p>
<ul>
  <li>一个4字节的魔数(magic number)</li>
  <li>一个4直接的修改时间戳(modification timestamp)</li>
  <li>一个编排过的代码对象</li>
</ul>

<p>对于各个版本的python解释器, magic number都各不相同, 对于python 2.5则是<code class="highlighter-rouge">b3f20d0a</code></p>

<p>修改时间戳则是源文件生成.pyc文件的Unix修改时间戳, 当源文件改变的时候, 该值也会变化</p>

<p>整个文件剩下的部分则是在编译源文件产生的代码对象编排后的输出. marshal跟python的pickle类似, 它对python对象进行序列化操作. 不过marshal和pickle的目标不同. pickle目的在于产生一个持久的独立于版本的序列化, 而marshal则是为了短暂地序列化对象, 因此它的表示会随着python版本二改变.</p>

<p>而且, pickle被设计用于适用用户定义的类型, 而marshal这时用于处理python内部类型的复杂结构</p>

<p>marshal的特性给出了pyc文件的重要特征: 它对平台独立, 但依赖于python版本. 一个2.4版本的pyc文件不能在2.5版本下执行, 但是它可以很好地移植到不同操作系统里.</p>

<p>接下来的部分也简单: 对于两个长整数和一个marshalled的代码对象, 复杂点在于代码对象的结构. 它们包含有编译器禅师的各种信息, 其中内容最丰富的这是字节码本身.</p>

<p>所幸有了marshal和dis模块, 编写程序导出这些信息并不会很难.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span><span class="p">,</span> <span class="n">marshal</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">types</span>

<span class="k">def</span> <span class="nf">show_file</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span>
    <span class="n">magic</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">moddate</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">modtime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">'L'</span><span class="p">,</span> <span class="n">moddate</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">print</span> <span class="s">"magic </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">magic</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">))</span>
    <span class="k">print</span> <span class="s">"moddate </span><span class="si">%</span><span class="s">s (</span><span class="si">%</span><span class="s">s)"</span> <span class="o">%</span> <span class="p">(</span><span class="n">moddate</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">),</span> <span class="n">modtime</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">marshal</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">show_code</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
     
<span class="k">def</span> <span class="nf">show_code</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s">''</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">scode"</span> <span class="o">%</span> <span class="n">indent</span>
    <span class="n">indent</span> <span class="o">+=</span> <span class="s">'   '</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sargcount </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_argcount</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">snlocals </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_nlocals</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sstacksize </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_stacksize</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sflags </span><span class="si">%04</span><span class="s">x"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_flags</span><span class="p">)</span>
    <span class="n">show_hex</span><span class="p">(</span><span class="s">"code"</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_code</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">)</span>
    <span class="n">dis</span><span class="o">.</span><span class="n">disassemble</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sconsts"</span> <span class="o">%</span> <span class="n">indent</span>
    <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">code</span><span class="o">.</span><span class="n">co_consts</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">const</span><span class="p">)</span> <span class="o">==</span> <span class="n">types</span><span class="o">.</span><span class="n">CodeType</span><span class="p">:</span>
            <span class="n">show_code</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">indent</span><span class="o">+</span><span class="s">'   '</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"   </span><span class="si">%</span><span class="s">s</span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">snames </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_names</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">svarnames </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sfreevars </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_freevars</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">scellvars </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_cellvars</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sfilename </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sname </span><span class="si">%</span><span class="s">r"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_name</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">sfirstlineno </span><span class="si">%</span><span class="s">d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">)</span>
    <span class="n">show_hex</span><span class="p">(</span><span class="s">"lnotab"</span><span class="p">,</span> <span class="n">code</span><span class="o">.</span><span class="n">co_lnotab</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">)</span>
     
<span class="k">def</span> <span class="nf">show_hex</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">s</span><span class="si">%</span><span class="s">s </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">s</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">60</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">"</span><span class="si">%</span><span class="s">s   </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">60</span><span class="p">])</span>

<span class="n">show_file</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<p>我们使用这段代码, 来处理一个极简单的python文件生成的pyc文件:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">if</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="n">a</span>
</code></pre></div></div>

<p>产生的结果如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>magic b3f20d0a
moddate 8a9efc47 (Wed Apr 09 06:46:34 2008)
code
   argcount 0
   nlocals 0
   stacksize 2
   flags 0040
   code
      6404005c02005a00005a0100650000700700016501006f0d000164020047
      65000047486e01000164030053
  1           0 LOAD_CONST               4 ((1, 0))
              3 UNPACK_SEQUENCE          2
              6 STORE_NAME               0 (a)
              9 STORE_NAME               1 (b)

  2          12 LOAD_NAME                0 (a)
             15 JUMP_IF_TRUE             7 (to 25)
             18 POP_TOP
             19 LOAD_NAME                1 (b)
             22 JUMP_IF_FALSE           13 (to 38)
        &gt;&gt;   25 POP_TOP

  3          26 LOAD_CONST               2 ('Hello')
             29 PRINT_ITEM
             30 LOAD_NAME                0 (a)
             33 PRINT_ITEM
             34 PRINT_NEWLINE
             35 JUMP_FORWARD             1 (to 39)
        &gt;&gt;   38 POP_TOP
        &gt;&gt;   39 LOAD_CONST               3 (None)
             42 RETURN_VALUE
   consts
      1
      0
      'Hello'
      None
      (1, 0)
   names ('a', 'b')
   varnames ()
   freevars ()
   cellvars ()
   filename 'C:\\ned\\sample.py'
   name '&lt;module&gt;'
   firstlineno 1
   lnotab 0c010e01
</code></pre></div></div>

<p>有很多内容我们都不明白, 但是字节码却很好地被反汇编并呈现了出来. python虚拟机是一个面向栈的解释器, 因此有许多操作都是load和pop, 并且当然也有很多jump和条件判断. 字节码的解释器则是在<a href="https://github.com/python/cpython/blob/master/Python/ceval.c"><code class="highlighter-rouge">ceval.c</code></a>中实现, 对于字节码的具体改变则会依赖于python的主版本. 比如<code class="highlighter-rouge">PRINT_ITEM </code>和<code class="highlighter-rouge">PRINT_NEWLINE</code>在python 3中则被去掉了.</p>

<p>在反汇编的输出中, 最左的数字(1,2,3)是源文件中的行号, 而接下来的数字(0,3,6,9)这是指令中的字节偏移. 指令的操作数这是直接用数字呈现, 而在括号内的这是符号性的解释. <code class="highlighter-rouge">&gt;&gt;</code>所表示的行实际上是代码中某处跳转指令的目标地址.</p>

<p>我们这个样例非常简单, 它只是一个模块中单一的代码对象中的指令流程. 在现实中有着类和函数定义的模块会十分复杂. 那些类和函数本身就是const列表中的代码对象, 在模块中进行了足够深的嵌套.</p>

<p>一旦你开始在这个级别挖掘, 会发现有各种各样适用于代码对象的工具. 在标准库中有内置的<a href="http://docs.python.org/lib/built-in-funcs.html#l2h-18">compile</a>函数, 以及<a href="http://docs.python.org/lib/module-compiler.html">compiler</a>, <a href="http://docs.python.org/lib/module-codeop.html">codeop</a>和<a href="http://docs.python.org/lib/bytecodes.html">opcode</a>模块. 在真实场景中会有很多第三方包比如<a href="http://www.aminus.org/rbre/python/index.html">codewalk</a>, <a href="http://wiki.python.org/moin/ByteplayDoc">byteplay</a>和<a href="http://bytecodehacks.sourceforge.net/bch-docs/bch/index.html">bytecodehacks</a>等. <a href="https://www.python.org/dev/peps/pep-0339/">PEP 339</a>给出了有关编译和操作码的更多详细信息. 最后</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用WinAppDbg解决Flareon第3题</title>
      <link href="http://www.vancir.com/2017/12/24/flareon4-3-winappdbg/"/>
      <pubDate>2017-12-24T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2017/12/24/flareon4-3-winappdbg</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223525.htm">https://bbs.pediy.com/thread-223525.htm</a></p>
</blockquote>

<p>文章作者: Parsia’s Den</p>

<p>博客地址: <a href="https://parsiya.net/">https://parsiya.net/</a></p>

<p>原文链接: <a href="https://parsiya.net/blog/2017-11-15-winappdbg---part-4---bruteforcing-flareon-2017---challenge-3/#bruteforcing-in-action">WinAppDbg - Part 4 - Bruteforcing FlareOn 2017 - Challenge 3</a></p>

<p>翻译前言: 这是解决Flareon4第3题的第4种方法, 也是这个系列翻译的完结篇. 作者用的WinAppDbg跟ODScript有类似的感觉, 虽然不及之前2篇让人耳目一新, 但这是作者对于WinAppDbg写的简易教程的第4篇, 如果感兴趣可以点击原文链接从其它3篇WinAppDbg的教程开始阅读.</p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<p>如果朋友想看我之前翻译的用其他3种全新的方法解决该题的文章, 可以点击以下链接:</p>

<ol>
  <li><a href="http://vancir.com/2017/12/21/flareon4-3/">Flareon challenge 4 第3题</a></li>
  <li><a href="http://vancir.com/2017/12/22/flareon4-3-libpeconv/">使用libPeConv来解决Flareon4题目3</a></li>
  <li><a href="http://vancir.com/2017/12/23/flareon4-3-angr/">使用Angr解决Flareon4题目3</a></li>
</ol>

<h2 id="侦查">侦查</h2>

<p>首先我们要运行<code class="highlighter-rouge">strings</code>程序分析文件. 在Windows我喜欢从以下两种方式获取<code class="highlighter-rouge">strings</code></p>

<ul>
  <li>从Cygwin的binutils包获取strings</li>
  <li>从微软Sysinternals套件获取strings
运行<code class="highlighter-rouge">strings</code>我们获得下图:</li>
  <li><code class="highlighter-rouge">-nobanner</code>: 不要显示启动时的标语和版权信息</li>
  <li><code class="highlighter-rouge">-o</code>: 打印字符串偏移(如果想要找寻字符串地址这会很有帮助)</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; .\SysinternalsSuite\strings.exe -o -nobanner .\3-GreektoMe\greek_to_me.exe
0077:!This program cannot be run in DOS mode.
0176:Rich
0432:.text
0472:.rdata
...
1584:Nope, that's not it.
1608:Congratulations! But wait, where's my flag?
1652:127.0.0.1
1752:WS2_32.dll
</code></pre></div></div>

<p><code class="highlighter-rouge">ws2_32.dll</code>是Windows套接字库, 故程序中有着网络活动.</p>

<p>说个有趣的题外话, 当我在搜索这个DLL时我发现以下这个链接:</p>

<ul>
  <li><a href="https://nakedsecurity.sophos.com/2009/10/12/windows-ws232dll-file-safe/">Is Your Windows “ws2_32.dll” File Safe?</a></li>
</ul>

<p>回归正题, <code class="highlighter-rouge">127.0.0.1</code>表明程序有网络活动, 表明它尝试连接或监听本地端口.</p>

<p>为了进一步探明, 我们运行<code class="highlighter-rouge">procmon</code>或<code class="highlighter-rouge">wireshark</code></p>

<ul>
  <li>Procmon过滤条件:
    <ul>
      <li>进程名是<code class="highlighter-rouge">greek_to_me.exe</code></li>
      <li>操作是<code class="highlighter-rouge">TCP/UDP</code>连接</li>
    </ul>
  </li>
  <li>Wireshark:
    <ul>
      <li>使用npcap抓取Windows回环流量</li>
      <li><a href="https://wiki.wireshark.org/CaptureSetup/Loopback">https://wiki.wireshark.org/CaptureSetup/Loopback</a></li>
    </ul>
  </li>
</ul>

<p>什么都没有显示. 故程序是在进行本地监听.</p>

<p>运行程序并以管理员身份运行命令行, 输入<code class="highlighter-rouge">netstat -anb</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> TCP    127.0.0.1:2222         0.0.0.0:0              LISTENING       5816
[greek_to_me.exe]
</code></pre></div></div>

<p>程序正在监听本地端口2222</p>

<h2 id="简短分析">简短分析</h2>

<p>程序监听端口2222, 当接收到数据, 它使用了我们输入的第1个字节(也就只用了第1个字节). 如下所示:</p>

<pre><code class="language-asm">.text:00401029 loc_401029:      ; CODE XREF: sub_401008+1A
.text:00401029          mov     ecx, offset loc_40107C
.text:0040102E          add     ecx, 79h
.text:00401031          mov     eax, offset loc_40107C
.text:00401036          mov     dl, [ebp+buf]   ; first byte of input moved to dl
</code></pre>

<p>现在dl指向着我们发送给socket的第1个字节</p>

<pre><code class="language-asm">.text:00401039 loc_401039:      ; CODE XREF: sub_401008+3D
.text:00401039          mov     bl, [eax]   ; bl = grab a byte from blob
.text:0040103B          xor     bl, dl      ; bl = blob_byte xor our_first_byte
.text:0040103D          add     bl, 22h     ; bl += 0x22
.text:00401040          mov     [eax], bl   ; *eax = bl
.text:00401042          inc     eax         ; eax++ (next char)
.text:00401043          cmp     eax, ecx    ; ecx is the address of the second section
.text:00401045          jl      short loc_401039 ; check if we have reached the next section
</code></pre>

<p>它抓取了一些数据(准确说是<code class="highlighter-rouge">0x79</code>或121字节), 使用我们的第1个字节跟其异或随后加上<code class="highlighter-rouge">0x22</code>. 取出的数据则是位于<code class="highlighter-rouge">loc40107C</code>偏移处的十六进制块.</p>

<pre><code class="language-asm">33 E1 C4 99 11 06 81 16 F0 32 9F C4 91 17 06 81
14 F0 06 81 15 F1 C4 91 1A 06 81 1B E2 06 81 18
F2 06 81 19 F1 06 81 1E F0 C4 99 1F C4 91 1C 06
81 1D E6 06 81 62 EF 06 81 63 F2 06 81 60 E3 C4
99 61 06 81 66 BC 06 81 67 E6 06 81 64 E8 06 81
65 9D 06 81 6A F2 C4 99 6B 06 81 68 A9 06 81 69
EF 06 81 6E EE 06 81 6F AE 06 81 6C E3 06 81 6D
EF 06 81 72 E9 06 81 73 7C
</code></pre>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/01-crypto.png" alt="xor_add.png" /></p>

<p>随后修改的数据块(在异或和加法操作后)传递给<code class="highlighter-rouge">sub_4011E6</code>并继续处理:</p>

<pre><code class="language-asm">.text:00401047          mov     eax, offset loc_40107C  ; eax = *modified_blob
.text:0040104C          mov     [ebp+var_C], eax        ; varC = eax
.text:0040104F          push    79h                     ; length of modified_blob
.text:00401051          push    [ebp+var_C]
.text:00401054          call    sub_4011E6              ; sub_4011E6(*modified_blob, 0x79)
.text:00401059          pop     ecx
.text:0040105A          pop     ecx
.text:0040105B          movzx   eax, ax
.text:0040105E          cmp     eax, 0FB5Eh ; compare return value with 0xFB5E

.text:00401063          jz      short loc_40107C
.text:00401065          push    0               ; flags
.text:00401067          push    14h             ; len
.text:00401069          push    offset buf      ; "Nope, that's not it."
.text:0040106E          push    [ebp+s]         ; s
.text:00401071          call    ds:send
.text:00401077          jmp     loc_401107
</code></pre>

<p><code class="highlighter-rouge">sub_4011E6</code>的返回值跟<code class="highlighter-rouge">0xFB5E</code>进行比较, 如果不匹配, <code class="highlighter-rouge">jz</code>跳转将不会实现并继续执行, 程序也会传回来<code class="highlighter-rouge">Nope, that's not it.</code>.</p>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/02-result-comparison.png" alt="nope.png" /></p>

<p>现在就变得越发有趣了. 如果结果匹配, 它就会跳转到我们刚刚修改过的数据块并试图将其作为代码执行. 如果程序没有崩溃且运行到结尾, 那么它就会发送回来<code class="highlighter-rouge">Congratulations!</code>.</p>

<p>换句话说, 我们输入的第1个字节就是用来将那数据块转换成正确的汇编操作码.</p>

<p>现在我们应该用另外一种方式来解决该题. 我想所有人都会用打开套接字, 发送256个可能字节并查看结果的方法来解决它. 这确实可以解决这个问题.</p>

<h2 id="使用winappdbg暴力穷举">使用WinAppDbg暴力穷举</h2>

<p>我使用另外一种方法解决. 复现这个方法我们需要了解一点点WinAppDbg的知识.</p>

<h2 id="winappdbg设置断点">WinAppDbg设置断点</h2>

<p>WinAppDng允许我们在任意地址设置断点:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">debug</span><span class="o">.</span><span class="n">break_at</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">action_callback</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">action_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="c"># do something</span>
</code></pre></div></div>

<p>当断点触发, <code class="highlighter-rouge">action_callback</code>函数就会被调用</p>

<p>更多信息请看:</p>

<ul>
  <li><a href="https://winappdbg.readthedocs.io/en/latest/Debugging.html?highlight=break_at#example-11-setting-a-breakpoint">Documentation - Example #11: setting a breakpoint</a></li>
  <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/breakpoint.py#L3905">breakpoint.py source code</a></li>
</ul>

<h2 id="获取和设置内存">获取和设置内存</h2>

<p>WinAppDbg运行我们存储/恢复内存和上下文</p>

<ul>
  <li>获取内存: <code class="highlighter-rouge">memory = process.take_memory_snapshot()</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3261">take_memory_snapshot 源码</a></li>
    </ul>
  </li>
  <li>设置内存: <code class="highlighter-rouge">process.restore_memory_snapshot(memory, bSkipMappedFiles=True)</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3301">restore_memory_snapshot 源码</a></li>
      <li>通常来说, 请总是保持<code class="highlighter-rouge">bSkipMappedFiles</code>为<code class="highlighter-rouge">True</code>, 否则你会得到一个内存地址错误
        <ul>
          <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/process.py#L3317">Explanation of bSkipMappedFiles in source</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="获取和设置上下文">获取和设置上下文</h2>

<p>上下文包含寄存器和各种标志值, 是逐线程(而非逐进程的)</p>

<ul>
  <li>获取上下文: <code class="highlighter-rouge">context = thread.get_context()</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/thread.py#L469">get_context 源码</a></li>
      <li>处理上下文中的寄存器:
        <ul>
          <li><code class="highlighter-rouge">context["Edx"] = 0x1234</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>设置上下文: <code class="highlighter-rouge">thread.set_context(context)</code>
    <ul>
      <li><a href="https://github.com/MarioVilas/winappdbg/blob/master/winappdbg/thread.py#L570">set_context 源码</a></li>
    </ul>
  </li>
</ul>

<p>注意: 在设置完上下文后, 我们需要手动修改指令指针指向一个开始执行的具体位置. 比如说如果我们获取了上下文, 改变<code class="highlighter-rouge">Eip</code>指向一个地址, 实际的指令指针并不会变化. 我们在设置完上下文后, 需要使用<code class="highlighter-rouge">thread.set_pc(address)</code>手动将指令指针改成你需要的地址.</p>

<p>在进行内存和上下文的操作时, 请确保事先暂停了程序/线程, 在操作完成后再恢复.</p>

<h2 id="作战计划">作战计划</h2>

<p>现在我们有了建筑模块, 我们需要制定一个作战计划. 非常简单明了.</p>

<ol>
  <li>运行程序</li>
  <li>在<code class="highlighter-rouge">0x401036</code>和<code class="highlighter-rouge">0x40105B</code>设置断点</li>
  <li>打开socket并发送任何可能的字节</li>
  <li>在<code class="highlighter-rouge">0x401036</code>的断点
    <ul>
      <li>如果是第1次触发断点:
        <ul>
          <li>保存内存,上下文和<code class="highlighter-rouge">0x40107C</code>的数据块</li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">context["Edx"] = key</code> - 交换key值</li>
      <li>key++</li>
      <li>绕过key的赋值指令并使用<code class="highlighter-rouge">thread.set_pc(0x401039)</code>手动跳转到<code class="highlighter-rouge">0x401039</code></li>
    </ul>
  </li>
  <li>在<code class="highlighter-rouge">0x40105B</code>的断点:
    <ul>
      <li>如果函数返回值是<code class="highlighter-rouge">0xFB5E</code>, 则打印key值</li>
      <li>否则:
        <ul>
          <li>复原内存, 上下文和<code class="highlighter-rouge">0x40107C</code>处的数据块(数据块已经被修改过了, 因此这里需要复原成原来的字节)</li>
          <li>使用<code class="highlighter-rouge">thread.set_pc(0x401036)</code>返回到<code class="highlighter-rouge">0x401036</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="https://parsiya.net/images/2017/winappdbg-4/03-bruteforcer-1.png" alt="plan.png" /></p>

<p>改变<code class="highlighter-rouge">buf</code>中第1个字节会比<code class="highlighter-rouge">edx</code>中更简单些, 而且能够避免途中标签2对应的跳转.</p>

<h2 id="开始暴力穷举">开始暴力穷举</h2>

<p>我们使用的脚本是<a href="https://github.com/parsiya/Parsia-Clone/blob/master/code/winappdbg/19-GreekToMe.py"><code class="highlighter-rouge">19-GreekToMe.py</code></a>, 你需要将<code class="highlighter-rouge">greek_to_me.exe</code>放在脚本的同一目录下, 该程序可以在附件里下载.</p>

<p>脚本运行非常快,因为我们的穷举空间仅仅只有1字节(0x00到0xFF)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python 19-GreekToMe.py
[21:23:48.0743] Starting simple_debugger
[21:23:48.0753] Started simple_debugger. Sleeping for 2 seconds.
[21:23:50.0756] Starting send_me.
[21:23:50.0875] Socket connected
[21:23:50.0875] Sent 0
[21:23:53.0490]
-------------------------------------------------------------------------------
Key: 0xa2
Eax: 0000FB5E
[21:23:54.0901] Reached 0x100
</code></pre></div></div>

<h2 id="flag">Flag</h2>

<p>重新在调试器中运行程序, 在”Congratulations!”处设下断点然后重新发送<code class="highlighter-rouge">0xA2</code>, 数据块正确解密, 我们也获得了flag</p>

<p><em>flag: et_tu_brute_force@flare-on.com</em></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用Angr解决Flareon4题目3</title>
      <link href="http://www.vancir.com/2017/12/23/flareon4-3-angr/"/>
      <pubDate>2017-12-23T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2017/12/23/flareon4-3-angr</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223512.htm">https://bbs.pediy.com/thread-223512.htm</a></p>
</blockquote>

<p>文章作者: XOR Hex</p>

<p>博客地址: <a href="https://blog.xorhex.com/">https://blog.xorhex.com/</a></p>

<p>原文链接: <a href="https://blog.xorhex.com/flare-on-2017-challenge-3/">Flare-On 2017: Challenge 3</a></p>

<p>翻译前言: 这是解决Flareon4第3题的第3种方法. 文章中使用angr编写python脚本来获得flag, 对比之前我翻译的使用Unicorn框架的文章里的代码, 对于刚接触Angr或Unicorn的朋友会有不少帮助.</p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<h2 id="准备">准备</h2>

<p>我们用IDA打开文件并调到入口点, 入口点简单地调用了函数<code class="highlighter-rouge">sub_401008</code></p>

<p><img src="https://blog.xorhex.com/content/images/2017/09/greek_to_me_entry_point.png" alt="entry_point.png" /></p>

<p>我们打开这个函数看看, 向下滚动我们可以看到看起来像成功提示的文本字符串, 接下来的标准流程就是找寻成功的分支.</p>

<p><img src="https://blog.xorhex.com/content/images/2017/09/greek_to_me_success_no_flag.png" alt="success_message.png" /></p>

<p>从字符串往回分析, 我们发现一个在<code class="highlighter-rouge">0x40105E</code>处的比较, <code class="highlighter-rouge">eax</code>跟值<code class="highlighter-rouge">0xFB5E</code>进行比较.</p>

<p><img src="https://blog.xorhex.com/content/images/2017/09/greek_to_me_comparison_check.png" alt="eax_comparison_check.png" /></p>

<p>如果<code class="highlighter-rouge">eax</code>匹配成功, 那么随后程序就会继续执行<em>成功</em>分支. 所以我们该如何满足这个匹配呢?</p>

<p>来看看<code class="highlighter-rouge">sub_4011E6</code>函数内部. 我们看到一堆的<code class="highlighter-rouge">mov</code>,<code class="highlighter-rouge">add</code>,<code class="highlighter-rouge">shl</code>和<code class="highlighter-rouge">shr</code>指令, 这可能是某种形式的混淆. 让我们看看传入进函数的参数:</p>

<pre><code class="language-asm">.text:00401047 mov     eax, offset loc_40107C
.text:0040104C mov     [ebp+var_C], eax
.text:0040104F push    79h
.text:00401051 push    [ebp+var_C]
.text:00401054 call    sub_4011E6
</code></pre>

<p>第1个参数存储在<code class="highlighter-rouge">eax</code>寄存器中而第2个参数这是值<code class="highlighter-rouge">0x79</code>. 注意, <code class="highlighter-rouge">eax</code>包含的是<code class="highlighter-rouge">0x40107C</code>的偏移量而第2个参数<code class="highlighter-rouge">0x79</code>看起来很可能是一个表示长度的参数. 我们细细检查函数<code class="highlighter-rouge">sub_4011E6</code>就能证实这点. 也就是说程序即将修改如下所示的汇编代码片段.</p>

<p><img src="https://blog.xorhex.com/content/images/2017/10/greek_to_me_asm_snippet.png" alt="obfuscated_assembly_code.png" /></p>

<p>并没有变量传入解混淆代码, 所以猜测应该是需要某种形式的用户输入, 所以我们继续看.
来到下一个代码块, 我们看到相同的汇编代码区段<code class="highlighter-rouge">0x40107C</code>在传入函数<code class="highlighter-rouge">sub_4011E6之前</code>由<code class="highlighter-rouge">xor</code>和<code class="highlighter-rouge">add</code>指令进行修改.</p>

<p><img src="https://blog.xorhex.com/content/images/2017/09/greek_to_me_deob_round_one.png" alt="first_deobfuscation_routine.png" /></p>

<p><code class="highlighter-rouge">xor</code>的值存储在<code class="highlighter-rouge">dl</code>, 而<code class="highlighter-rouge">dl</code>总是从<code class="highlighter-rouge">[ebp+buf]</code>赋值而来, 这看上去就可能是我们的用户输入了. 继续向上跟踪我们看到<code class="highlighter-rouge">[eax+buf]</code>则是作为参数传递给函数<code class="highlighter-rouge">sub_401121</code></p>

<p><img src="https://blog.xorhex.com/content/images/2017/09/greek_to_me_follow_buf.png" alt="sub_401121_call.png" /></p>

<p>快速浏览函数<code class="highlighter-rouge">sub_401121</code>, 我们看到<code class="highlighter-rouge">0x4011BC</code>处设置了<code class="highlighter-rouge">[ebp+buf]</code></p>

<p><img src="https://blog.xorhex.com/content/images/2017/09/greek_to_me_buf_recv.png" alt="call_to_recv.png" /></p>

<p>函数的剩余部分则仅仅只是服务器接受输入后的一些操作</p>

<p>总结一下收获:</p>

<ul>
  <li>找到了位于<code class="highlighter-rouge">0x4010FE</code>的成功提示字符串</li>
  <li>比较检查在<code class="highlighter-rouge">0x40105E</code>处
    <ul>
      <li>必须匹配<code class="highlighter-rouge">0xFB5E</code>才能进入成功验证分支</li>
    </ul>
  </li>
  <li>已混淆代码起始于<code class="highlighter-rouge">0x40107C</code></li>
  <li>已混淆代码的长度为<code class="highlighter-rouge">0x79</code></li>
  <li>第2阶段的解混淆函数在<code class="highlighter-rouge">0x401054</code>处被调用</li>
  <li>第1阶段的解混淆操作从<code class="highlighter-rouge">0x401029</code>开始到<code class="highlighter-rouge">0x401045</code></li>
  <li>用户输入发生在<code class="highlighter-rouge">0x401015</code>处的函数调用
    <ul>
      <li>用户输入来自网络</li>
      <li>输入缓冲区的长度是<code class="highlighter-rouge">0x4</code></li>
    </ul>
  </li>
</ul>

<h2 id="解答">解答</h2>

<p>在我们开始写脚本解答之前, 我们需要提取那些混淆过的字节出来.</p>

<p>这里我使用IDAPython脚本来提取字节</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'greek_to_me_buffer.asm'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">idaapi</span><span class="o">.</span><span class="n">get_many_bytes</span><span class="p">(</span><span class="mh">0x40107C</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">))</span>
</code></pre></div></div>

<p>现在我们可以进入下一步, 写脚本!</p>

<h3 id="用户输入">用户输入</h3>

<p>我们知道从网络接收的长度是4字节, 但是聪明的读者可能已经注意到代码中使用<code class="highlighter-rouge">dl</code>赋值给<code class="highlighter-rouge">buf</code>而非<code class="highlighter-rouge">edx</code>, 也就导致实际值的范围是从<code class="highlighter-rouge">0x0</code>到<code class="highlighter-rouge">0xff</code>(<code class="highlighter-rouge">dl</code>只有1字节大小). 我们脚本的开始部分类似如下:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">buf</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mh">0x100</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Using {0}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="暴力穷举">暴力穷举</h2>

<p>接下来我们需要修改提取出的比特使得通过比较检查. 我们需要通过解混淆的两部分.</p>

<h2 id="解混淆第1步">解混淆第1步</h2>

<p>对于第1次的解混淆(<code class="highlighter-rouge">0x401039</code>), 我们可以用python简单写一个”解码器”.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c"># Variable to store the bits written to disk using IDA</span>
    <span class="n">asm</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c"># Store the output from the first de-obfuscation routine</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Read in bytes written to file from IDA</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'greek_to_me_buffer.asm'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">asm</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c"># Re-implement loc_401039</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">buf</span>
    <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">bl</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span>
        <span class="n">bl</span> <span class="o">=</span> <span class="n">bl</span> <span class="o">^</span> <span class="n">dl</span>
        <span class="n">bl</span> <span class="o">=</span> <span class="n">bl</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="n">bl</span> <span class="o">=</span> <span class="n">bl</span> <span class="o">+</span> <span class="mh">0x22</span>
        <span class="n">bl</span> <span class="o">=</span> <span class="n">bl</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="n">b2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span>
</code></pre></div></div>

<p>要记住第1步解混淆操作应该放在for循环块中.</p>

<h2 id="解混淆第2步">解混淆第2步</h2>

<p>在<code class="highlighter-rouge">Angr</code>的帮助下, 我们可以继续按我们的方式进行第2阶段的解混淆, 虽然有点像作弊, 但谁又想用python或c重写一遍解混淆的代码呢?</p>

<p>在<code class="highlighter-rouge">for</code>循环之前一行声明一个<code class="highlighter-rouge">angr</code>工程实例, 这样它就不会在每次<code class="highlighter-rouge">for</code>循环执行时重新创建一遍.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="n">angr</span><span class="o">.</span><span class="n">Project</span><span class="p">(</span><span class="s">'greek_to_me.exe'</span><span class="p">,</span> <span class="n">load_options</span><span class="o">=</span><span class="p">{</span><span class="s">'auto_load_libs'</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
</code></pre></div></div>

<p>设置Angr模拟执行<code class="highlighter-rouge">sub_4011E6</code>, 不过我们这次需要放到<code class="highlighter-rouge">for</code>循环里去.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c"># Set up angr to "run" sub_4011E6 </span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">blank_state</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="mh">0x4011E6</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">esp</span><span class="o">+</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">dword</span> <span class="o">=</span> <span class="mi">1</span>    <span class="c"># Angr memory location to hold the xor'ed and add'ed bytes</span>
    <span class="n">s</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">esp</span><span class="o">+</span><span class="mi">8</span><span class="p">:]</span><span class="o">.</span><span class="n">dword</span> <span class="o">=</span> <span class="mh">0x79</span> <span class="c"># Length of ASM</span>

    <span class="c"># Copy bytes output from loc_401039 into address 0x1 so Angr can run it</span>
    <span class="n">asm</span> <span class="o">=</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">b2</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">se</span><span class="o">.</span><span class="n">BVV</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">asm</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'hex'</span><span class="p">),</span> <span class="mi">16</span><span class="p">),</span> <span class="mh">0x79</span> <span class="o">*</span> <span class="mi">8</span> <span class="p">))</span>

    <span class="c"># Create a simulation manager...</span>
    <span class="n">simgr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">simulation_manager</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="c"># Tell Angr where to go, though there is only one way through this function, </span>
    <span class="c"># we just need to stop after ax is set</span>
    <span class="n">simgr</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">find</span><span class="o">=</span><span class="mh">0x401268</span><span class="p">)</span>
</code></pre></div></div>

<p>虽然我意识到在这里使用Angr可能有点过犹不及, 但它是我手上最新的工具, 所以我所有的问题都以Angr的方式来解决.</p>

<h2 id="输入合法性检查">输入合法性检查</h2>

<p>接下来我们需要检查<code class="highlighter-rouge">ax</code>的输出是否匹配<code class="highlighter-rouge">0xFB5E</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c"># Once ax is set, check to see if the value in ax matches the comparison value</span>
    <span class="k">for</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">simgr</span><span class="o">.</span><span class="n">found</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">found</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">found</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">ax</span><span class="p">)))</span>
        <span class="c"># Comparison check</span>
        <span class="k">if</span> <span class="nb">hex</span><span class="p">(</span><span class="n">found</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">found</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">regs</span><span class="o">.</span><span class="n">ax</span><span class="p">))</span> <span class="o">==</span> <span class="s">'0xfb5eL'</span><span class="p">:</span>
            <span class="c"># Will cover what to do here in the next section</span>
            <span class="k">pass</span>
</code></pre></div></div>

<h2 id="解混淆代码">解混淆代码</h2>

<p>现在我们已经满足了校验值匹配, 我们将解混淆的代码输出到屏幕上</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>�e�]��E�t�_�U��E�t�E�u�U��E�b�E�r�E�u�E�t�]߈U��E�f�E�o�E�r�E�c�]��E�@�E�f�E�l�E�a�E�r�]��E�-�E�o�E�n�E�.�E�c�E�o�E�m�E�
</code></pre></div></div>

<p>我们猜测这应该是汇编代码. 我们使用<code class="highlighter-rouge">Capstone</code>反编译代码.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"0x</span><span class="si">%</span><span class="s">x</span><span class="se">\t</span><span class="si">%</span><span class="s">s</span><span class="se">\t</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="p">))</span>
</code></pre></div></div>

<p>再次运行脚本, 我们可以确定这是汇编代码并且填充入缓冲区的内容里出现了ASCII字符.</p>

<pre><code class="language-asm">0x1000	mov	bl, 0x65	None
0x1002	mov	byte ptr [ebp - 0x2b], bl
0x1005	mov	byte ptr [ebp - 0x2a], 0x74
0x1009	mov	dl, 0x5f	None
0x100b	mov	byte ptr [ebp - 0x29], dl
0x100e	mov	byte ptr [ebp - 0x28], 0x74
0x1012	mov	byte ptr [ebp - 0x27], 0x75
0x1016	mov	byte ptr [ebp - 0x26], dl
0x1019	mov	byte ptr [ebp - 0x25], 0x62
0x101d	mov	byte ptr [ebp - 0x24], 0x72
0x1021	mov	byte ptr [ebp - 0x23], 0x75
0x1025	mov	byte ptr [ebp - 0x22], 0x74
0x1029	mov	byte ptr [ebp - 0x21], bl
0x102c	mov	byte ptr [ebp - 0x20], dl
0x102f	mov	byte ptr [ebp - 0x1f], 0x66
0x1033	mov	byte ptr [ebp - 0x1e], 0x6f
0x1037	mov	byte ptr [ebp - 0x1d], 0x72
0x103b	mov	byte ptr [ebp - 0x1c], 0x63
0x103f	mov	byte ptr [ebp - 0x1b], bl
0x1042	mov	byte ptr [ebp - 0x1a], 0x40
0x1046	mov	byte ptr [ebp - 0x19], 0x66
0x104a	mov	byte ptr [ebp - 0x18], 0x6c
0x104e	mov	byte ptr [ebp - 0x17], 0x61
0x1052	mov	byte ptr [ebp - 0x16], 0x72
0x1056	mov	byte ptr [ebp - 0x15], bl
0x1059	mov	byte ptr [ebp - 0x14], 0x2d
0x105d	mov	byte ptr [ebp - 0x13], 0x6f
0x1061	mov	byte ptr [ebp - 0x12], 0x6e
0x1065	mov	byte ptr [ebp - 0x11], 0x2e
0x1069	mov	byte ptr [ebp - 0x10], 0x63
0x106d	mov	byte ptr [ebp - 0xf], 0x6f
0x1071	mov	byte ptr [ebp - 0xe], 0x6d
0x1075	mov	byte ptr [ebp - 0xd], 0	
</code></pre>
<h2 id="嵌入的ascii字符">嵌入的ASCII字符</h2>

<p>既然我们能够手动将上面汇编中可显字符的十六进制转换成字符, 我们为什么不用脚本来完成这一工作呢. 修改<code class="highlighter-rouge">for</code>循环:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bl</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">dl</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">flag</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c"># Using capstone, interpret the ASM</span>
<span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">):</span>
    <span class="n">flag_char</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c"># The if statements do the work of interpreting the ASCII codes to their value counterpart</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">"byte ptr"</span><span class="p">):</span>
        <span class="n">flag_char</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'bl'</span><span class="p">):</span>
        <span class="n">bl</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'dl'</span><span class="p">):</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s">'dl'</span><span class="p">:</span>
        <span class="n">flag_char</span> <span class="o">=</span> <span class="n">dl</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s">'bl'</span><span class="p">:</span>
        <span class="n">flag_char</span> <span class="o">=</span> <span class="n">bl</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flag_char</span><span class="p">):</span>
        <span class="n">flag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flag_char</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"0x</span><span class="si">%</span><span class="s">x</span><span class="se">\t</span><span class="si">%</span><span class="s">s</span><span class="se">\t</span><span class="si">%</span><span class="s">s</span><span class="se">\t</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">op_str</span><span class="p">,</span> <span class="n">flag_char</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span>
</code></pre></div></div>

<p>最后运行脚本得到flag</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>et_tu_brute_force@flare-on.com
</code></pre></div></div>

<h2 id="结论">结论</h2>

<p>总体上我们解决题目用的静态方法十分有趣, 同时也让我有机会首次在CTF竞赛中使用<code class="highlighter-rouge">Angr</code>和<code class="highlighter-rouge">Capstone</code>. 一开始我使用的是<code class="highlighter-rouge">Angr 6</code>来解决该问题, 但后来因为在CTF的中途<code class="highlighter-rouge">Angr</code>更新新版本, 所以写脚本的时候用的是<code class="highlighter-rouge">Angr 7</code>. 如果我随后使用了<code class="highlighter-rouge">Unicorn</code>引擎和<code class="highlighter-rouge">Angr</code>再次解决的话我会回来更新这篇文章.</p>

<p>完整的脚本代码你可以在这里找到: <a href="https://bitbucket.org/snippets/XOR_Hex/kByG75">greek_to_me_angr7.py</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用libPeConv来解决Flareon4题目3</title>
      <link href="http://www.vancir.com/2017/12/22/flareon4-3-libpeconv/"/>
      <pubDate>2017-12-22T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2017/12/22/flareon4-3-libpeconv</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223494.htm">https://bbs.pediy.com/thread-223494.htm</a></p>
</blockquote>

<p>文章作者: hasherezade(@hasherezade)</p>

<p>原文链接: <a href="https://hshrzd.wordpress.com/2017/11/24/import-all-the-things-solving-flareon-challenge-3-with-libpeconv/">Import all the things! Solving FlareOn4 Challenge 3 with libPeConv</a></p>

<p>翻译前言: 虽然依旧是Flareon4第3题的分析,但是一道题的解决方法多种多样,这次给大家分享如何使用libPeConv来解决问题,又可以get到新姿势啦</p>

<p>libPeConv: 是作者hasherezade开发的用于加载和转换PE文件的库,github仓库地址是:<a href="https://github.com/hasherezade/libpeconv">libpeconv</a></p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<h2 id="总览">总览</h2>
<p>题目greek_to_me.exe是一个32位PE文件, 程序已经剔除了重定位信息. 我们以下就简称该程序为crackme
<img src="https://hshrzd.files.wordpress.com/2017/11/exe_info.png?w=640" alt="fig1" /></p>

<p>我们运行crackme, 只有一个空白的控制台程序, 并且没有从标准输入中读取任何数据, 所以我们可以推断程序是使用了一些其他方式来读取用户的password</p>

<p>我们使用IDA静态分析, crackme结构非常简洁并没有混淆过. 我们可以在代码开头看见程序创建了一个socket并等待着输入
socket监听着本地2222端口</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/make_socket.png" alt="fig2" /></p>

<p>在建立连接后, crackme从用户输入中取前4字节读入到缓冲区中:</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/recv_4.png" alt="fig3" /></p>

<p>读入4字节后, crackme开始处理输入并用来解码已加密的缓冲区数据</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/read_buf.png" alt="fig4" /></p>

<p>如果校验值是合法的, 也就是说加密数据被正确解密了, 那么crackme就会进一步执行下去.</p>

<p>我们可以看到, 输入中的数据只有1字节用于解码缓冲区数据, 所以我们可以轻易地穷举获得结果. 解码部分的代码也相当简单:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">size_t</span> <span class="n">encrypted_len</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">encrypted_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BYTE</span> <span class="n">val</span> <span class="o">=</span> <span class="n">encrypted_code</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">encrypted_code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">unknown_byte</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>程序唯一的难点在于校验值 - 这个函数并没有那么好复现. 然而如果我们想要暴力穷举, 我们却又需要在穷举后计算校验值.</p>

<p>在我之前的解答中, 我复现了校验函数并表现良好, 但这并没有那么好玩. 我看过了一些其他的解决方式如<a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/Flare-On%202017/Challenge%20%233%20solution.pdf">使用Unicorn引擎模拟执行校验函数</a>
, 或<a href="https://blog.xorhex.com/flare-on-2017-challenge-3/">使用angr框架</a>, 或<a href="http://blog.attify.com/2017/10/10/flare-4-writeup-p1/">通过socket使用暴力穷举程序来获得原始程序</a>等等. 但是我们可以解决得更快速吗?我们来接着看…</p>
<h2 id="使用libpeconv">使用LibPeConv</h2>
<p>使用PeConv我们可以将原始格式的任何PE文件转换成虚拟内存格式并返回. 它也提供有一个可定制的PE加载器 - 用于加载任意PE文件到当前进程(就算它不是dll文件也没有重定位表, 这我会在之后的部分进行解释). 载入的PE文件随后可以在当前进程内运行. 我们也可以选择文件中的任意函数来使用 - 而我们只需要知道函数的RVA和API.</p>

<p>在这次, 我将会使用libpeconv来加载crackme并导入校验值的计算函数. 不用复制加密缓冲区数据到我们的代码中, 我们可以直接从载入的PE文件中读取它.</p>

<h2 id="收集需要的信息">收集需要的信息</h2>
<p>让我们再一次在IDA中查看crackme. 我们需要找到恰当的偏移量并明白我们需要导入的API函数.</p>

<p>首先我们计算校验值的函数起始于RVA 0x11E6处:</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/checksum_func.png" alt="fig5" /></p>

<p>函数读取2个参数: 指向缓冲区的指针和缓冲区大小
函数返回一个WORD类型数据.</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/return_word.png" alt="fig6" /></p>

<p>总结一下, 我们可以定义一个如下的函数原型:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WORD</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">decoded_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
</code></pre></div></div>
<p>还有一点需要注意, 就是这个函数是可独用的并且没有调用任何的导入库函数 - 这让我们导入这个校验值函数更加轻松(我们不必加载任何导入库模块或进行重定位).</p>

<p>另一个我们需要的信息就是加密的缓冲区. 缓冲区起始于RVA 0x107C并且长度为0x79(121)字节</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/enc_code.png" alt="fig7" /></p>

<p>信息搜集完毕!我们开始写代码.</p>
<h2 id="使用libpeconv解决crackme">使用libPeConv解决crackme</h2>
<p>当前版本的<code class="highlighter-rouge">libpeconv</code>允许两种方式来载入PE文件. 使用到的函数有<code class="highlighter-rouge">load_pe_module</code>和<code class="highlighter-rouge">load_pe_executable</code>. 第2个函数<code class="highlighter-rouge">load_pe_executable</code>是一个完整的加载器, 它加载指定PE文件到当前进程的可读可写可执行(RWX)内存中, 并自动应用重定位信息和载入其他依赖. 第1个函数<code class="highlighter-rouge">load_pe_module</code>则不能载入依赖并且我们需要提供更多的控制: 我们可能会加载PE文件到一个不可执行的内存中而是否进行重定位也是可选的. 更多详细信息(或者该API的重要更新)请看: <a href="https://github.com/hasherezade/libpeconv/blob/master/libpeconv/include/peconv/pe_loader.h">https://github.com/hasherezade/libpeconv/blob/master/libpeconv/include/peconv/pe_loader.h</a></p>

<p>正如我们所见, 我们想要导入的函数是独用的, 因此如果我们载入crackme的PE文件时没有加载导入表和重定位信息也不会造成什么危害(我们将在文章的下一部分看如何载入一个完整的PE文件). 我将使用到<code class="highlighter-rouge">load_pe_module</code>函数</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span><span class="n">load_pe_module</span><span class="p">(</span>
    <span class="n">path</span><span class="p">,</span>
    <span class="n">v_size</span><span class="p">,</span> <span class="c1">// OUT: size of the loaded module
</span>    <span class="nb">true</span><span class="p">,</span>   <span class="c1">// executable
</span>    <span class="nb">false</span>   <span class="c1">// without relocations
</span><span class="p">);</span>
</code></pre></div></div>
<p>现在, 我们来导入函数, 首先我们来定义一个指针</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_checksum</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>
<p>计算在载入模块中该函数的绝对偏移</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">DWORD</span><span class="p">(</span><span class="mh">0x11e6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
</code></pre></div></div>
<p>然后填充指针</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">calc_checksum</span> <span class="o">=</span> <span class="p">(</span> <span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">)</span> <span class="p">)</span> <span class="n">offset</span><span class="p">;</span>
</code></pre></div></div>
<p>现在我们就可以在我们的应用程序里该函数
但在那之前, 我们可以开始暴力穷举, 我们也同样也需要填充缓冲区指针.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g_Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mh">0x107C</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">);</span>
</code></pre></div></div>
<p>以下链接是我准备的完整穷举程序: <a href="https://gist.github.com/hasherezade/44b440675ccc065f111dd6a90ed34399#file-brutforcer_1-cpp">https://gist.github.com/hasherezade/44b440675ccc065f111dd6a90ed34399#file-brutforcer_1-cpp</a>
并且结果表现良好. 我们得到的结果跟crackme需要的一样.</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/brutforce_1.png" alt="fig8" /></p>

<p>但目前为止, 我们找到的值也只是解答过程的一部分, 并不是我们需要找到的flag. 我们从先前静态分析时可以知道, 如果给出正确值, 那么代码块就能解密并执行. 如果我们能看到解密后代码块到底是怎样的, 那岂不是很酷?</p>

<p>而且这也非常容易实现. 我们的PE文件载入进了当前进程可读可写可执行内存中 - 因此我们可以轻易地将解密后的数据替换回加密块代码, 我们只需要一个简单的<code class="highlighter-rouge">memcpy</code>就能完成这个工作</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">memcpy</span><span class="p">(</span><span class="n">g_Buffer</span><span class="p">,</span> <span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>
</code></pre></div></div>
<p>随后, <code class="highlighter-rouge">libPeConv</code>可以帮助我们将PE文件转换回原始格式以便用IDA打开. 我们可以用<code class="highlighter-rouge">libPeConv</code>的<code class="highlighter-rouge">pe_virtual_to_raw</code>来完成.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">out_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">BYTE</span><span class="o">*</span> <span class="n">unmapped_module</span> <span class="o">=</span> <span class="n">pe_virtual_to_raw</span><span class="p">(</span>
    <span class="n">loaded_pe</span><span class="p">,</span> <span class="c1">//pointer to the module
</span>    <span class="n">v_size</span><span class="p">,</span> <span class="c1">//virtual size
</span>    <span class="n">module_base</span><span class="p">,</span> <span class="c1">//in this case we need here
</span>                 <span class="c1">//the original module base, because
</span>                 <span class="c1">//the loaded PE was not relocated
</span>    <span class="n">out_size</span> <span class="c1">//OUT: raw size of the unmapped PE
</span><span class="p">);</span>
</code></pre></div></div>
<p>并且以下是完整的解答: <a href="https://gist.github.com/hasherezade/36a4a531840cfe1fd5997bc7c5f6be4d#file-brutforcer_2-cpp">brutforcer_2.cpp</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="cp">#include "peconv.h"
</span>
<span class="n">BYTE</span> <span class="o">*</span><span class="n">g_Buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">g_BufferLen</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span>

<span class="n">BYTE</span> <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">g_BufferLen</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_checksum</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">decoded_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">test_val</span><span class="p">(</span><span class="n">BYTE</span> <span class="n">xor_val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_BufferLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BYTE</span> <span class="n">val</span> <span class="o">=</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xor_val</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WORD</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mh">0xfb5e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BYTE</span> <span class="nf">brutforce</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BYTE</span> <span class="n">xor_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">xor_val</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_val</span><span class="p">(</span><span class="n">xor_val</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">xor_val</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//---
</span>
<span class="n">bool</span> <span class="nf">dump_to_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">out_path</span><span class="p">,</span> <span class="n">BYTE</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f1</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fwrite</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">,</span> <span class="n">f1</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="cp">#ifdef _WIN64
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Compile the loader as 32bit!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="kt">char</span> <span class="n">default_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"greek_to_me.exe"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">default_path</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">v_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">load_pe_module</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> 
                                     <span class="n">v_size</span><span class="p">,</span> 
                                     <span class="nb">true</span><span class="p">,</span> <span class="c1">// load as executable?
</span>                                     <span class="nb">false</span> <span class="c1">// apply relocations ?
</span>                                    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loaded_pe</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Loading module failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mh">0x107C</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">);</span>

    <span class="n">ULONGLONG</span> <span class="n">func_offset</span> <span class="o">=</span> <span class="mh">0x11e6</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
    <span class="n">calc_checksum</span> <span class="o">=</span>  <span class="p">(</span> <span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">)</span> <span class="p">)</span> <span class="n">func_offset</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="n">found</span> <span class="o">=</span> <span class="n">brutforce</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Found: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">g_Buffer</span><span class="p">,</span> <span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>

    <span class="kt">size_t</span> <span class="n">out_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="cm">/*in this case we need to use the original module base, because 
    * the loaded PE was not relocated */</span>
    <span class="n">ULONGLONG</span> <span class="n">module_base</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">get_image_base</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">);</span> 
    
    <span class="n">BYTE</span><span class="o">*</span> <span class="n">unmapped_module</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">pe_virtual_to_raw</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">,</span> 
                                              <span class="n">v_size</span><span class="p">,</span> 
                                              <span class="n">module_base</span><span class="p">,</span> <span class="c1">//the original module base
</span>                                              <span class="n">out_size</span> <span class="c1">// OUT: size of the unmapped (raw) PE
</span>                                             <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unmapped_module</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">out_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"modified_pe.exe"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dump_to_file</span><span class="p">(</span><span class="n">out_path</span><span class="p">,</span> <span class="n">unmapped_module</span><span class="p">,</span> <span class="n">out_size</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Module dumped to: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">out_path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">peconv</span><span class="o">::</span><span class="n">free_pe_buffer</span><span class="p">(</span><span class="n">unmapped_module</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">peconv</span><span class="o">::</span><span class="n">free_pe_buffer</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
    
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>与初始的文件相比, 我们可以看到dump出来的可执行文件的缓冲区已经覆写过了.</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/filled_buf.png?w=640" alt="fig9" /></p>

<p>所以我们在IDA里看下修改的可执行文件</p>

<p><img src="https://hshrzd.files.wordpress.com/2017/11/flag_revealed.png" alt="fig10" /></p>

<p>搞定!在<code class="highlighter-rouge">0x000F107C</code>处显示出我们的flag: <code class="highlighter-rouge">et_tu_brute_force@flare-on.com</code></p>

<h2 id="福利---载入和运行剔除了重定位信息的pe文件">福利 - 载入和运行剔除了重定位信息的PE文件</h2>
<p>OK, 你可能会说, 这很简单呀, 导入的函数是独立的, 所以我们可以从原来文件中抽出来, 并不需要使用任何加载器. 但是如果函数调用了一些其他的模块内的其他函数或是导入函数呢? 我们之前的方法还能生效吗? 不止如此, 剔除掉重定位信息的PE文件又能行吗?</p>

<p>为了回答这些问题, 我准备了其他的测试用例. 与之前载一个函数相反, 我将会在穷举程序中载入并执行完整的crackme文件.</p>

<p>首先我们将会修改一些东西. 这次不使用<code class="highlighter-rouge">load_pe_module</code>, 我使用<code class="highlighter-rouge">load_pe_executable</code>来加载完整的可执行文件和依赖.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span><span class="n">load_pe_executable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
</code></pre></div></div>

<p>这个函数将自动地识别出这个PE文件没有重定位信息, 并且载入到初始模块基址. 注意, 分配的指定基址处的内存可能不总会生效, 因此有时需要运行多次使得程序正确地执行. 你也必须确定加载器的模块基址跟payload需要的模块基址不相冲突(如果加载器的基址是随机的话就很好).</p>

<p>一旦PE文件加载完毕, 我们就需要获取它的入口地址, 并且随后我们就可以像其他函数一样调用它:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Deploy the payload:
// read the Entry Point from the headers:
</span><span class="n">ULONGLONG</span> <span class="n">ep_va</span> <span class="o">=</span> <span class="n">get_entry_point_rva</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">)</span>
    <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
 
<span class="c1">//make pointer to the entry function:
</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">loaded_pe_entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="n">ep_va</span><span class="p">;</span>
 
<span class="c1">//call the loaded PE's ep:
</span><span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">loaded_pe_entry</span><span class="p">();</span>
</code></pre></div></div>

<p>但还要注意这与payload的具体实现细节有关, 一旦你转向执行入口点代码, 它可能在完成工作后直接退出而不会返回到你的代码中.</p>

<p>我打算修改穷举程序的代码, 使得在找到正确值之后crackme会继续运行. 以下是代码的完整版本: <a href="https://gist.github.com/hasherezade/9d5186b27c730d01849ac1787b3d699b#file-brutforcer_3-cpp">brutforcer_3.cpp</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="cp">#include "peconv.h"
</span>
<span class="n">BYTE</span> <span class="o">*</span><span class="n">g_Buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">g_BufferLen</span> <span class="o">=</span> <span class="mh">0x79</span><span class="p">;</span>

<span class="n">BYTE</span> <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">g_BufferLen</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="n">calc_checksum</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="n">decoded_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_size</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">test_val</span><span class="p">(</span><span class="n">BYTE</span> <span class="n">xor_val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_BufferLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BYTE</span> <span class="n">val</span> <span class="o">=</span> <span class="n">g_Buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">g_Buffer2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xor_val</span> <span class="o">^</span> <span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WORD</span> <span class="n">checksum</span> <span class="o">=</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">g_Buffer2</span><span class="p">,</span> <span class="n">g_BufferLen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">checksum</span> <span class="o">==</span> <span class="mh">0xfb5e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BYTE</span> <span class="nf">brutforce</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BYTE</span> <span class="n">xor_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">xor_val</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">test_val</span><span class="p">(</span><span class="n">xor_val</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">xor_val</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//---
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="cp">#ifdef _WIN64
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Compile the loader as 32bit!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="kt">char</span> <span class="n">default_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"greek_to_me.exe"</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">default_path</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">v_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">BYTE</span><span class="o">*</span> <span class="n">loaded_pe</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">load_pe_executable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">v_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loaded_pe</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Loading module failed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">g_Buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="mh">0x107C</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">);</span>

    <span class="n">ULONGLONG</span> <span class="n">func_offset</span> <span class="o">=</span> <span class="mh">0x11e6</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>
    <span class="n">calc_checksum</span> <span class="o">=</span>  <span class="p">(</span> <span class="n">WORD</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">)</span> <span class="p">)</span> <span class="n">func_offset</span><span class="p">;</span>

    <span class="n">BYTE</span> <span class="n">found</span> <span class="o">=</span> <span class="n">brutforce</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Found: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>

    <span class="c1">// Deploy the payload!
</span>    <span class="c1">// read the Entry Point from the headers:
</span>    <span class="n">ULONGLONG</span> <span class="n">ep_va</span> <span class="o">=</span> <span class="n">peconv</span><span class="o">::</span><span class="n">get_entry_point_rva</span><span class="p">(</span><span class="n">loaded_pe</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span> <span class="n">loaded_pe</span><span class="p">;</span>

    <span class="c1">//make pointer to the entry function:
</span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">loaded_pe_entry</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="n">ep_va</span><span class="p">;</span>

    <span class="c1">//call the loaded PE's ep:
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Calling the Entry Point of the loaded module:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">loaded_pe_entry</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Finished: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>为了确保一切运行正常(尽管运行payload确实建立了socket并给出跟之前载入独立函数时相同的回应), 我写了一个简短的python脚本来交流和显示回应结果: <a href="https://gist.github.com/hasherezade/328210a57464360e23e125929b62b301#file-test-py">test.py</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">argparse</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"Send to the Crackme"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--key'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">"key"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">"0xa2"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"The value to be sent"</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">my_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">%</span> <span class="mi">255</span>
    <span class="k">print</span> <span class="s">'[+] Checking the key: '</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">my_key</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span>  <span class="nb">chr</span><span class="p">(</span><span class="n">my_key</span><span class="p">)</span> <span class="o">+</span> <span class="s">'012'</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">'127.0.0.1'</span><span class="p">,</span> <span class="mi">2222</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"[+] Response: "</span> <span class="o">+</span> <span class="n">result</span>
        <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">"Could not connect to the socket. Is the crackme running?"</span>
    
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="nb">exit</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div></div>

<p>现在, 你可以在YouTube观看整个过程的操作: <a href="https://www.youtube.com/watch?v=x3T3qFEDkF0">https://www.youtube.com/watch?v=x3T3qFEDkF0</a></p>

<p>以上就是我今天所准备的内容, 我希望大家都能有所收获! 该库现在正处于快速开发阶段, 所以许多东西会进行重构并优化, 敬请期待.</p>

<h2 id="附录">附录</h2>
<p>其他解决该问题的方法如下:</p>
<ul>
  <li><a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/Flare-On%202017/Challenge%20%233%20solution.pdf">emulating the checksum function by the Unicorn engine</a></li>
  <li><a href="https://blog.xorhex.com/flare-on-2017-challenge-3/">using angr framework</a></li>
  <li><a href="https://parsiya.net/blog/2017-11-15-winappdbg---part-4---bruteforcing-flareon-2017---challenge-3/">using WinAppDbg</a></li>
  <li><a href="http://blog.attify.com/2017/10/10/flare-4-writeup-p1/">a brutforcer that talks to the original program via socket</a></li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>Flareon challenge 4 第3题</title>
      <link href="http://www.vancir.com/2017/12/21/flareon4-3/"/>
      <pubDate>2017-12-21T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2017/12/21/flareon4-3</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223473.htm">https://bbs.pediy.com/thread-223473.htm</a></p>
</blockquote>

<p>题目作者: Matt Williams	(@0xmwilliams)</p>

<p>翻译前言: 文章对代码自修改的分析很细致, 使用Unicorn框架来模拟执行代码和Capstone进行反汇编.</p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/greek_to_me.zip">greek_to_me.zip</a>, 解压密码: www.pediy.com</p>

<p><code class="highlighter-rouge">greek_to_me.exe</code>是一个Windows x86可执行文件, 如下图所示, 程序中的字符串表露了<code class="highlighter-rouge">00401101</code>处要达成的情况, 如下所示.</p>
<pre><code class="language-asm">004010F5 push 0 ; flags
004010F7 push 2Bh ; len
004010F9 push offset aCongratulation ; "Congratulations! But wait, where's...”
004010FE push [ebp+s] ; s
00401101 call ds:send
</code></pre>
<p>然而, 在地址<code class="highlighter-rouge">00401101</code>前面的汇编代码却包含如下所示的奇怪汇编指令</p>
<pre><code class="language-asm">004010A0 icebp
004010A1 push es
004010A2 sbb dword ptr [esi], 1F99C4F0h
004010A8 les edx, [ecx+1D81061Ch]
004010AE out 6, al ; DMA controller, 8237A-5.
004010AE ; channel 3 base address
004010AE ; (also sets current ad
</code></pre>
<p>不过也许你在此时能准确地猜测到, 程序为了能达到地址<code class="highlighter-rouge">0x401101</code>, 会修改这些奇怪的指令, 因为这些奇怪的指令运行下去, 我们的程序会极有可能崩溃. 另一种迹象能暗合我们认为这是代码自修改的推测, 那就是在查看程序的文件头时, 我们发现程序入口点所在的<code class="highlighter-rouge">.text</code>区段是可写的. 到这里, 我们正常的套路就可以往上查看分析, 看是什么能让程序选择<code class="highlighter-rouge">0x401063</code>的正确分支.</p>

<p>当然还有另外一种方法就是确定程序的套接字是在哪里生成的, 话不多说, 我们这就来尝试.</p>

<p><code class="highlighter-rouge">greek_to_me.exe</code>包含有<code class="highlighter-rouge">0x401151</code>处的一个简单socket函数调用, 如下图所示</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_qyt8aml071kho03.png" alt="fig3.png" /></p>

<p>在<code class="highlighter-rouge">sub_401121</code>里我们可以观察到, 程序用了一系列Windows API函数: <code class="highlighter-rouge">socket,bind,listen和accept</code>创建了一个监听本地TCP端口2222(0x8AE)的套接字</p>

<p>程序一直等待着监听端口的连接, 直到从建立连接的客户端那接收到最多4个字节. 接收到的字节会存储在缓冲区中并以参数的形式传递给<code class="highlighter-rouge">sub_401121</code>. 一旦有接收到字节, 该函数就能在 不停止现有连接的情况下返回一个socket句柄. 要记住, 当执行到<code class="highlighter-rouge">0x401071</code>或<code class="highlighter-rouge">0x401101</code>时, 程序就会使用到它.</p>

<p>如果<code class="highlighter-rouge">sub_401121</code>返回了一个合法的socket句柄, 程序会继续执行, 否则程序退出. 如下代码块为寄存器赋初值, 这几个寄存器将在解码循环中发挥用处</p>

<pre><code class="language-asm">00401029 mov ecx, offset loc_40107C
0040102E add ecx, 79h
00401031 mov eax, offset loc_40107C
00401036 mov dl, [ebp+buf]
</code></pre>

<p>我们看这段代码, 首先, 一个位于<code class="highlighter-rouge">.text</code>区段的可执行的代码地址赋值给<code class="highlighter-rouge">ECX</code>寄存器, 并且加上了常量值<code class="highlighter-rouge">79h</code>, 这也表明了随后将介绍的解码循环里的终止地址. 地址<code class="highlighter-rouge">0x40107C</code>赋给EAX寄存器, 代表解码循环的起始地址. 在<code class="highlighter-rouge">0x401036</code>, <code class="highlighter-rouge">recv</code>缓冲区的第1个字节被赋给了<code class="highlighter-rouge">EDX</code>寄存器的低8位</p>

<p>继续向下看代码块, 其中包含一个进行如下操作的循环</p>
<ol>
  <li>取出存储在<code class="highlighter-rouge">EAX</code>中的地址(<code class="highlighter-rouge">0x40107C</code>)所指向内容的1个字节</li>
  <li>将取出的字节跟监听端口收到的第1个字节进行异或</li>
  <li>异或操作得到的结果再加上<code class="highlighter-rouge">0x22</code></li>
  <li>将结果覆写回第1步取出的字节处</li>
</ol>

<pre><code class="language-asm">00401039 loc_401039:
00401039 mov bl, [eax]
0040103B xor bl, dl
0040103D add bl, 22h
00401040 mov [eax], bl
00401042 inc eax
00401043 cmp eax, ecx
00401045 jl short loc_401039
</code></pre>

<p>在<code class="highlighter-rouge">EAX</code>中存储的地址则自增1并且跟<code class="highlighter-rouge">ECX</code>中存储的最大地址进行比较, 只有当<code class="highlighter-rouge">EAX</code>的内容跟最大地址<code class="highlighter-rouge">0x4010F5</code>相等时循环才会结束.</p>

<p>继续向下看, 程序随后便将刚刚修改了的代码块首地址(<code class="highlighter-rouge">0040107C</code>)和块大小<code class="highlighter-rouge">0x79</code>作参数传递给<code class="highlighter-rouge">sub_4011E6</code>.</p>

<pre><code class="language-asm">00401047 mov eax, offset loc_40107C
0040104C mov [ebp+var_C], eax
0040104F push 79h
00401051 push [ebp+var_C]
00401054 call sub_4011E6
00401059 pop ecx
0040105A pop ecx
0040105B movzx eax, ax
0040105E cmp eax, 0FB5Eh
00401063 jz short loc_40107C
</code></pre>

<p>我们可以看到程序返回值的低16位(<code class="highlighter-rouge">AX</code>)赋给了<code class="highlighter-rouge">EAX</code>寄存器再将<code class="highlighter-rouge">EAX</code>跟硬编码值<code class="highlighter-rouge">0xFB5E</code>进行比较, 而比较的结果则决定了程序是跳向<code class="highlighter-rouge">0x40107C</code>还是执行到显示失败信息的分支</p>

<pre><code class="language-asm">00401065 push 0 ; flags
00401067 push 14h ; len
00401069 push offset buf ; "Nope, that's not it."
0040106E push [ebp+s] ; s
00401071 call ds:send
</code></pre>

<p>获得这些信息, 我们可以做出正确假设: <code class="highlighter-rouge">sub_4011E6</code>是用来计算验证值或者说是之前解码循环所修改的字节的校验值. 并且可以确定从socket接受到的字节值是用作异或修改<code class="highlighter-rouge">0x40107C</code>和<code class="highlighter-rouge">0x4010F4</code>之间代码块的key值. 而程序自修改的代码则通过一个硬编码的校验值进行验证. 因为使用的key只有单字节, 因此我们可以进行简单的暴力穷举来获得期望的key.</p>

<p>如果修改后的代码正常执行并且通过socket返回了<code class="highlighter-rouge">Congratulations</code>字符串, 那么就可以确定暴力穷举成功了. 基于这个假设, 我们可以编写一个如下的脚本代码帮助输出正确值:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="n">TCP_IP</span> <span class="o">=</span> <span class="s">'127.0.0.1'</span>
<span class="n">TCP_PORT</span> <span class="o">=</span> <span class="mi">2222</span>
<span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">256</span><span class="p">):</span>
	<span class="n">os</span><span class="o">.</span><span class="n">startfile</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
	<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="n">TCP_IP</span><span class="p">,</span> <span class="n">TCP_PORT</span><span class="p">))</span>
	<span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)</span>
	<span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
	<span class="k">if</span> <span class="s">'Congratulations'</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
		<span class="k">print</span> <span class="s">"Key found: </span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span> <span class="n">i</span>
		<span class="k">break</span>
</code></pre></div></div>

<p>但如果我们并不想基于解码的字节都正确执行这样一个假设来操作, 而是自己验证解码后的校验值是否匹配, 要怎么办呢? 相比花大量时间逆向校验算法, 这次我们来尝试体验一个有趣的恶意代码分析技术: 代码模拟执行</p>

<p>首先, 我们提取校验函数<code class="highlighter-rouge">sub_4011E6</code>的操作码, 我们只关心在<code class="highlighter-rouge">0x401265</code>执行完后存储在<code class="highlighter-rouge">AX</code>中的返回值, 如下图所示. 并且不需要提取函数的平衡栈的结尾部分. 
<img src="https://bbs.pediy.com/upload/attach/201712/722644_qoxg2d29vlb8b0r.png" alt="fig9.png" /></p>

<p>我们同样也需要从<code class="highlighter-rouge">0x40107C</code>处提取<code class="highlighter-rouge">0x79</code>长度的待解码字节.  我们提取的字节集合都在如下的用于模拟执行的python简易脚本中可见</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">binascii</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">from</span> <span class="nn">unicorn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">unicorn.x86_const</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">CHECKSUM_CODE</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span>
<span class="s">'55 8B EC 51 8B 55 0C B9 FF 00 00 00 89 4D FC 85 D2 74 51 53 8B 5D 08 56 57 '</span>
<span class="s">'6A 14 58 66 8B 7D FC 3B D0 8B F2 0F 47 F0 2B D6 0F B6 03 66 03 F8 66 89 7D '</span>
<span class="s">'FC 03 4D FC 43 83 EE 01 75 ED 0F B6 45 FC 66 C1 EF 08 66 03 C7 0F B7 C0 89 '</span>
<span class="s">'45 FC 0F B6 C1 66 C1 E9 08 66 03 C1 0F B7 C8 6A 14 58 85 D2 75 BB 5F 5E 5B '</span>
<span class="s">'0F B6 55 FC 8B C1 C1 E1 08 25 00 FF 00 00 03 C1 66 8B 4D FC 66 C1 E9 08 66 '</span>
<span class="s">'03 D1 66 0B C2'</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
<span class="n">ENCODED_BYTES</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span>
<span class="s">'33 E1 C4 99 11 06 81 16 F0 32 9F C4 91 17 06 81 14 F0 06 81 15 F1 C4 91 1A '</span>
<span class="s">'06 81 1B E2 06 81 18 F2 06 81 19 F1 06 81 1E F0 C4 99 1F C4 91 1C 06 81 1D '</span>
<span class="s">'E6 06 81 62 EF 06 81 63 F2 06 81 60 E3 C4 99 61 06 81 66 BC 06 81 67 E6 06 '</span>
<span class="s">'81 64 E8 06 81 65 9D 06 81 6A F2 C4 99 6B 06 81 68 A9 06 81 69 EF 06 81 6E '</span>
<span class="s">'EE 06 81 6F AE 06 81 6C E3 06 81 6D EF 06 81 72 E9 06 81 73 7C'</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span>
<span class="s">''</span><span class="p">))</span>
</code></pre></div></div>

<p>如下的代码定义了一个函数, 给定函数一个<code class="highlighter-rouge">0x00</code>到<code class="highlighter-rouge">0xFF</code>之间的值, 就能执行原来程序的解码操作.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decode_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
	<span class="n">decoded_bytes</span> <span class="o">=</span> <span class="s">""</span>
	<span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">ENCODED_BYTES</span><span class="p">:</span>
		<span class="n">decoded_bytes</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(((</span><span class="nb">ord</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span> <span class="o">^</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">decoded_bytes</span>
</code></pre></div></div>

<p>接下来, 我们定义一个函数, 函数在给定待解码字节后会利用<code class="highlighter-rouge">Unicorn</code>框架来模拟执行校验值函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">emulate_checksum</span><span class="p">(</span><span class="n">decoded_bytes</span><span class="p">):</span>
	<span class="c"># establish memory addresses for checksum code, stack, and decoded bytes</span>
	<span class="n">address</span> <span class="o">=</span> <span class="mh">0x400000</span>
	<span class="n">stack_addr</span> <span class="o">=</span> <span class="mh">0x410000</span>
	<span class="n">dec_bytes_addr</span> <span class="o">=</span> <span class="mh">0x420000</span>
	<span class="c"># write checksum code and decoded bytes into memory</span>
	<span class="n">mu</span> <span class="o">=</span> <span class="n">Uc</span><span class="p">(</span><span class="n">UC_ARCH_X86</span><span class="p">,</span> <span class="n">UC_MODE_32</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">CHECKSUM_CODE</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">dec_bytes_addr</span><span class="p">,</span> <span class="n">decoded_bytes</span><span class="p">)</span>
</code></pre></div></div>
<p>如上的代码中初始化了一个32位的x86模拟器, 随后创建了一个用于存储校验函数代码, 函数内部栈以及待解码字节的2MB内存. 校验代码和待解码字节可以写入内存范围的任意地址里.</p>

<p>校验值函数从栈上取两个参数: 待解码字节的起始地址(<code class="highlighter-rouge">0x40107C</code>)以及长度(<code class="highlighter-rouge">0x79</code>), 下图显示了校验值函数调用后的状态.</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_owsp2vdhbm1qfdh.png" alt="fig13.png" /></p>

<p>为了能让校验值函数能在模拟时正确执行, 我们还需要对栈进行设置来匹配上图的栈空间布局, 并适当填充ESP寄存器. 如下所示, 在模拟执行结束后, 我们可以从<code class="highlighter-rouge">emulate_checksum</code>返回计算后的校验值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="c"># place the address of decoded bytes and size on the stack</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_ESP</span><span class="p">,</span> <span class="n">stack_addr</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">stack_addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;I'</span><span class="p">,</span> <span class="n">dec_bytes_addr</span><span class="p">))</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">stack_addr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;I'</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">))</span>
	<span class="c"># emulate and read result in AX</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">emu_start</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">CHECKSUM_CODE</span><span class="p">))</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_AX</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">checksum</span>
</code></pre></div></div>

<p>现在到轻松的部分了. 我们暴力穷举异或的key, 解码字节并模拟校验操作, 然后确定哪一个key能获得正确的校验值. 如下所示</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">):</span>
	<span class="n">decoded_bytes</span> <span class="o">=</span> <span class="n">decode_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">emulate_checksum</span><span class="p">(</span><span class="n">decoded_bytes</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">checksum</span> <span class="o">==</span> <span class="mh">0xFB5E</span><span class="p">:</span>
		<span class="k">print</span> <span class="s">'Checksum matched with byte </span><span class="si">%</span><span class="s">X'</span> <span class="o">%</span> <span class="n">i</span>
</code></pre></div></div>

<p>运行脚本最后打印出正确的单字节值: <code class="highlighter-rouge">0xA2</code>. 然而我们仍然不明白解码后<code class="highlighter-rouge">0x40107C</code>处的指令干了什么. 我们来尝试使用<code class="highlighter-rouge">Capstone</code>反汇编器来反汇编这些指令, 如下所示</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">print</span> <span class="s">'Decoded bytes disassembly:'</span>
	<span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">decoded_bytes</span><span class="p">,</span> <span class="mh">0x40107C</span><span class="p">):</span>
		<span class="k">print</span> <span class="s">"0x</span><span class="si">%</span><span class="s">x:</span><span class="se">\t</span><span class="si">%</span><span class="s">s</span><span class="se">\t</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">op_str</span><span class="p">)</span>
	<span class="k">break</span>
</code></pre></div></div>
<p>运行我们的脚本并提供指令, 结果如下所示</p>

<pre><code class="language-asm">Success with byte A2
Decoded bytes disassembly:
0x40107c: mov bl, 0x65
0x40107e: mov byte ptr [ebp - 0x2b], bl
0x401081: mov byte ptr [ebp - 0x2a], 0x74
0x401085: mov dl, 0x5f
0x401087: mov byte ptr [ebp - 0x29], dl
0x40108a: mov byte ptr [ebp - 0x28], 0x74
0x40108e: mov byte ptr [ebp - 0x27], 0x75
0x401092: mov byte ptr [ebp - 0x26], dl
0x401095: mov byte ptr [ebp - 0x25], 0x62
0x401099: mov byte ptr [ebp - 0x24], 0x72
0x40109d: mov byte ptr [ebp - 0x23], 0x75
0x4010a1: mov byte ptr [ebp - 0x22], 0x74
0x4010a5: mov byte ptr [ebp - 0x21], bl
0x4010a8: mov byte ptr [ebp - 0x20], dl
0x4010ab: mov byte ptr [ebp - 0x1f], 0x66
0x4010af: mov byte ptr [ebp - 0x1e], 0x6f
0x4010b3: mov byte ptr [ebp - 0x1d], 0x72
0x4010b7: mov byte ptr [ebp - 0x1c], 0x63
0x4010bb: mov byte ptr [ebp - 0x1b], bl
0x4010be: mov byte ptr [ebp - 0x1a], 0x40
0x4010c2: mov byte ptr [ebp - 0x19], 0x66
0x4010c6: mov byte ptr [ebp - 0x18], 0x6c
0x4010ca: mov byte ptr [ebp - 0x17], 0x61
0x4010ce: mov byte ptr [ebp - 0x16], 0x72
0x4010d2: mov byte ptr [ebp - 0x15], bl
0x4010d5: mov byte ptr [ebp - 0x14], 0x2d
0x4010d9: mov byte ptr [ebp - 0x13], 0x6f
0x4010dd: mov byte ptr [ebp - 0x12], 0x6e
0x4010e1: mov byte ptr [ebp - 0x11], 0x2e
0x4010e5: mov byte ptr [ebp - 0x10], 0x63
0x4010e9: mov byte ptr [ebp - 0xf], 0x6f
0x4010ed: mov byte ptr [ebp - 0xe], 0x6d
0x4010f1: mov byte ptr [ebp - 0xd], 0
</code></pre>

<p>我们可以看出两点, 首先栈上正在填充成一个字符串, 其次, 填充到栈上的常量十六进制值在可显字符范围内(<code class="highlighter-rouge">0x20~0x7E</code>). 依据它们在栈上的顺序依次提取出这些可显字符, 或者你可以用调试器观察栈上的内容, 得到题目解答: <code class="highlighter-rouge">et_tu_brute_force@flare-on.com</code>.</p>

<p>以下附上python脚本</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">binascii</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">from</span> <span class="nn">unicorn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">unicorn.x86_const</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">CHECKSUM_CODE</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span>
	<span class="s">'55 8B EC 51 8B 55 0C B9 FF 00 00 00 89 4D FC 85 D2 74 51 53 8B 5D 08 56 57 '</span>
	<span class="s">'6A 14 58 66 8B 7D FC 3B D0 8B F2 0F 47 F0 2B D6 0F B6 03 66 03 F8 66 89 7D '</span>
	<span class="s">'FC 03 4D FC 43 83 EE 01 75 ED 0F B6 45 FC 66 C1 EF 08 66 03 C7 0F B7 C0 89 '</span>
	<span class="s">'45 FC 0F B6 C1 66 C1 E9 08 66 03 C1 0F B7 C8 6A 14 58 85 D2 75 BB 5F 5E 5B '</span>
	<span class="s">'0F B6 55 FC 8B C1 C1 E1 08 25 00 FF 00 00 03 C1 66 8B 4D FC 66 C1 E9 08 66 '</span>
	<span class="s">'03 D1 66 0B C2'</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
<span class="n">ENCODED_BYTES</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span>
	<span class="s">'33 E1 C4 99 11 06 81 16 F0 32 9F C4 91 17 06 81 14 F0 06 81 15 F1 C4 91 1A '</span>
	<span class="s">'06 81 1B E2 06 81 18 F2 06 81 19 F1 06 81 1E F0 C4 99 1F C4 91 1C 06 81 1D '</span>
	<span class="s">'E6 06 81 62 EF 06 81 63 F2 06 81 60 E3 C4 99 61 06 81 66 BC 06 81 67 E6 06 '</span>
	<span class="s">'81 64 E8 06 81 65 9D 06 81 6A F2 C4 99 6B 06 81 68 A9 06 81 69 EF 06 81 6E '</span>
	<span class="s">'EE 06 81 6F AE 06 81 6C E3 06 81 6D EF 06 81 72 E9 06 81 73 7C'</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span>
	<span class="s">''</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">decode_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
	<span class="n">decoded_bytes</span> <span class="o">=</span> <span class="s">""</span>
	<span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">ENCODED_BYTES</span><span class="p">:</span>
		<span class="n">decoded_bytes</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(((</span><span class="nb">ord</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span> <span class="o">^</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x22</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">decoded_bytes</span>
	
<span class="k">def</span> <span class="nf">emulate_checksum</span><span class="p">(</span><span class="n">decoded_bytes</span><span class="p">):</span>
	<span class="c"># establish memory addresses for checksum code, stack, and decoded bytes</span>
	<span class="n">address</span> <span class="o">=</span> <span class="mh">0x400000</span>
	<span class="n">stack_addr</span> <span class="o">=</span> <span class="mh">0x410000</span>
	<span class="n">dec_bytes_addr</span> <span class="o">=</span> <span class="mh">0x420000</span>
	<span class="c"># write checksum code and decoded bytes into memory</span>
	<span class="n">mu</span> <span class="o">=</span> <span class="n">Uc</span><span class="p">(</span><span class="n">UC_ARCH_X86</span><span class="p">,</span> <span class="n">UC_MODE_32</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">CHECKSUM_CODE</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">dec_bytes_addr</span><span class="p">,</span> <span class="n">decoded_bytes</span><span class="p">)</span>
	<span class="c"># place the address of decoded bytes and size on the stack</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_ESP</span><span class="p">,</span> <span class="n">stack_addr</span><span class="p">)</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">stack_addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;I'</span><span class="p">,</span> <span class="n">dec_bytes_addr</span><span class="p">))</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">stack_addr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">'&lt;I'</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">))</span>
	<span class="c"># emulate and read result in AX</span>
	<span class="n">mu</span><span class="o">.</span><span class="n">emu_start</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">CHECKSUM_CODE</span><span class="p">))</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_AX</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">checksum</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">):</span>
	<span class="n">decoded_bytes</span> <span class="o">=</span> <span class="n">decode_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">emulate_checksum</span><span class="p">(</span><span class="n">decoded_bytes</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">checksum</span> <span class="o">==</span> <span class="mh">0xFB5E</span><span class="p">:</span>
		<span class="k">print</span> <span class="s">'Checksum matched with byte </span><span class="si">%</span><span class="s">X'</span> <span class="o">%</span> <span class="n">i</span>
		<span class="k">print</span> <span class="s">'Decoded bytes disassembly:'</span>
		<span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">decoded_bytes</span><span class="p">,</span> <span class="mh">0x40107C</span><span class="p">):</span>
			<span class="k">print</span> <span class="s">"0x</span><span class="si">%</span><span class="s">x:</span><span class="se">\t</span><span class="si">%</span><span class="s">s</span><span class="se">\t</span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">op_str</span><span class="p">)</span>
		<span class="k">break</span>
</code></pre></div></div>
]]></content:encoded>
    </item>
    
    <item>
      <title>zbot变种木马wsnpoem脱壳笔记 part 2</title>
      <link href="http://www.vancir.com/2017/12/20/wsnopem-unpack-two/"/>
      <pubDate>2017-12-20T00:00:00+08:00</pubDate>
      <author>Vancir</author>
      <guid>http://www.vancir.com/2017/12/20/wsnopem-unpack-two</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>本文已发表在看雪论坛, 详情可见: <a href="https://bbs.pediy.com/thread-223401.htm">https://bbs.pediy.com/thread-223401.htm</a></p>
</blockquote>

<p>承接之前写的<a href="http://vancir.com/2017/12/19/wsnpoem-unack-one">zbot变种木马wsnpoem脱壳笔记 part 1</a>，我们这次用另外一种方式来脱壳。并且本文还将分析另外两个恶意样本。</p>

<p>文中分析的程序你可以点击此处下载: <a href="http://od7mpc53s.bkt.clouddn.com/wsnpoem%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%ACpart2.zip">wsnpoem恶意样本par2.zip</a>, 解压密码: www.pediy.com</p>

<p>OD重载<code class="highlighter-rouge">wsnpoem-with-rootkit.exe</code>，依然是之前的顺序，在<code class="highlighter-rouge">leave</code>处设下硬件断点后运行，让第1阶段的解密完成。然后删除设下的硬件断点，向下翻看。</p>

<p>不过这次我们就不会在<code class="highlighter-rouge">00409EDA</code>处的<code class="highlighter-rouge">jmp eax</code>下断了，我们再向下翻到<code class="highlighter-rouge">00409F26</code>处的<code class="highlighter-rouge">mov eax, 004051B7</code>，这句汇编代码下面是<code class="highlighter-rouge">call eax</code>，也就是说程序将要执行OEP处的代码。</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_293sajegk0nty8q.jpg" alt="1.png" /></p>

<p>我们在<code class="highlighter-rouge">004051B7</code>设下硬件执行断点，然后执行断下，程序停在了OEP处，我们删除硬件断点</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_5yn8m5tplxxrslg.jpg" alt="2.png" /></p>

<p>那么我们接下来的步骤就跟之前一样，运行步过<code class="highlighter-rouge">004051D2</code>处的<code class="highlighter-rouge">call 0040aad4</code>导入函数表，然后将EIP重设为<code class="highlighter-rouge">004051B7</code>。</p>

<p>之前用Ollydump+ImportREC我们手动cut chunks来修复导入表，这样不仅枯燥费力，而且还有可能误删正确的chunks导致修复失败，这次我们使用额外一个工具 - <code class="highlighter-rouge">Universial Import Fixer 1.0[Final]</code>，也就是<code class="highlighter-rouge">UIF</code>。这个工具可以为我们自动修复导入表，我们只需要将wsnpoem的进程id输入进去就可以。</p>

<p>在重设完EIP后，我们打开UIF，然后再通过在cmd里用<code class="highlighter-rouge">tasklist</code>命令查询到wsnpoem的pid，我的是<code class="highlighter-rouge">1816</code>，将其转为16进制，也就是<code class="highlighter-rouge">0x718</code>，填入到UIF的<code class="highlighter-rouge">Process ID</code>中，取消掉默认勾选的<code class="highlighter-rouge">Fix NtDll to Kernel32</code>，然后点击<code class="highlighter-rouge">Start UIF</code>就会帮你自动修复导入表并显示修复后的信息。这些信息我们等下用ImportREC是需要使用的，也就是下图的<code class="highlighter-rouge">IAT RVA</code>和<code class="highlighter-rouge">IAT Size</code></p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_btjtwvp8rp1y074.jpg" alt="3.png" /></p>

<p>既然修复好了导入表，那么我们就可以用Ollydump将程序转储出来，记得在dump时要取消勾选<code class="highlighter-rouge">rebuild imports</code>，转储文件保存为dump.exe</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_ondh0kf79s01zyz.jpg" alt="4.png" /></p>

<p>打开ImortREC，然后选择wsnpoem进程，输入OEP，并按照UIF修复给出的<code class="highlighter-rouge">IAT RVA</code>和<code class="highlighter-rouge">IAT Size</code>填入到ImportREC中</p>

<p>你可以看到导入表直接就是可用的，我们不需要手动修复导入表。我们就可以直接转储到文件就行了。IDA打开当然也是脱壳完成并且各导入函数清晰的。</p>

<p>当然，还是很麻烦，那有什么更好的方法吗.当然有，这里提供了一份ollydby的脚本，我们载入程序后运行脚本，就可以帮我们自动完成脱壳和修复导入表的步骤。</p>

<p>我们重新载入程序，然后点击插件中的ODbgScript-&gt;Run Script … 然后选择<code class="highlighter-rouge">WSNPOEM-generic-unpacker.osc</code></p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_576893isl4bzdqu.jpg" alt="5.png" /></p>

<p>一路向下点击过去，你也可以按下<code class="highlighter-rouge">Alt+L</code>来查看脚本脱壳过程的log</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_b4iib9nf9huxiks.jpg" alt="7.png" /></p>

<p>脚本运行完成，显示ImportREC需要的信息</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_ncagp9fmcryzpkj.jpg" alt="8.png" /></p>

<p>我们照之前的步骤将其填入到ImportREC, 转储到文件即可。</p>

<p><img src="https://bbs.pediy.com/upload/attach/201712/722644_enq628tp3i6twmz.jpg" alt="9.png" /></p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
