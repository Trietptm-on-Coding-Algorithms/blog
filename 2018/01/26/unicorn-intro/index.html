<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>Unicorn Engine简介</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>Unicorn Engine简介</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2018-01-26">2018-01-26</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#crack" title="crack">crack</a>&nbsp;
  
  <a href="/categories/#translations" title="translations">translations</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#RE" title="RE">RE</a>&nbsp;
  
  <a href="/tags/#tool" title="tool">tool</a>&nbsp;
  
</span>

</section>
<section class="post">
<h2 id="什么是unicorn引擎">什么是Unicorn引擎</h2>

<p>Unicorn是一个轻量级, 多平台, 多架构的CPU模拟器框架. 我们可以更好地关注CPU操作, 忽略机器设备的差异. 想象一下, 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的CPU去完成那些操作, 又或者想要更安全地分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义. 使用CPU模拟器可以很好地帮助我们提供便捷.</p>

<p>它的亮点(这也归功于Unicorn是基于<a href="http://www.qemu.org">qemu</a>而开发的)有:</p>

<ul>
  <li>支持多种架构: Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64).</li>
  <li>对Windows和*nix系统(已确认包含Mac OSX, Linux, *BSD &amp; Solaris)的原生支持</li>
  <li>具有平台独立且简洁易于使用的API</li>
  <li>使用JIT编译技术, 性能表现优异</li>
</ul>

<p>你可以在<a href="http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf">Black Hat USA 2015</a>获悉有关Unicorn引擎的更多技术细节. Github项目主页: <a href="https://github.com/unicorn-engine/unicorn">unicorn</a></p>

<p>尽管它不同寻常, 但它无法模拟整个程序或系统, 也不支持系统调用. 你需要手动映射内存并写入数据进去, 随后你才能从指定地址开始模拟.</p>

<h2 id="应用的情景">应用的情景</h2>

<p>什么时候能够用到Unicorn引擎呢?</p>

<ul>
  <li>你可以调用恶意软件中一些有趣的函数, 而不用创建一个有害的进程.</li>
  <li>用于CTF竞赛</li>
  <li>用于模糊测试</li>
  <li>用于gdb插件, 基于代码模拟执行的插件</li>
  <li>模拟执行一些混淆代码</li>
</ul>

<h2 id="如何安装">如何安装</h2>

<p>安装Unicorn最简单的方式就是使用pip安装, 只要在命令行中运行以下命令即可(这是适合于喜爱用python的用户的安装方法, 对于那些想要使用C的用户, 则需要去官网查看文档编译源码包):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install unicorn
</code></pre></div></div>

<p>但如果你想用源代码进行本地编译的话, 你需要在<a href="http://www.unicorn-engine.org/download/">下载</a>页面中下载源代码包, 然后可以按照以下命令执行:</p>

<ul>
  <li>*nix 平台用户</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>bindings/python
<span class="nv">$ </span><span class="nb">sudo </span>make install
</code></pre></div></div>

<ul>
  <li>Windows平台用户</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>bindings/python
python setup.py install
</code></pre></div></div>

<p>对于Windows, 在执行完上述命令后, 还需要将<a href="http://www.unicorn-engine.org/download/">下载</a>页面的<code class="highlighter-rouge">Windows core engine</code>的所有dll文件复制到<code class="highlighter-rouge">C:\locationtopython\Lib\site-packages\unicorn</code>位置处.</p>

<h2 id="使用unicorn的快速指南">使用unicorn的快速指南</h2>

<p>我们将会展示如何使用python调用unicorn的api以及它是如何轻易地模拟二进制代码. 当然这里用的api仅是一小部分, 但对于入门已经足够了.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">1</span> <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
 <span class="mi">2</span> <span class="kn">from</span> <span class="nn">unicorn</span> <span class="kn">import</span> <span class="o">*</span>
 <span class="mi">3</span> <span class="kn">from</span> <span class="nn">unicorn.x86_const</span> <span class="kn">import</span> <span class="o">*</span>
 <span class="mi">4</span> 
 <span class="mi">5</span> <span class="c"># code to be emulated</span>
 <span class="mi">6</span> <span class="n">X86_CODE32</span> <span class="o">=</span> <span class="n">b</span><span class="s">"</span><span class="se">\x41\x4a</span><span class="s">"</span> <span class="c"># INC ecx; DEC edx</span>
 <span class="mi">7</span> 
 <span class="mi">8</span> <span class="c"># memory address where emulation starts</span>
 <span class="mi">9</span> <span class="n">ADDRESS</span> <span class="o">=</span> <span class="mh">0x1000000</span>
<span class="mi">10</span> 
<span class="mi">11</span> <span class="k">print</span><span class="p">(</span><span class="s">"Emulate i386 code"</span><span class="p">)</span>
<span class="mi">12</span> <span class="k">try</span><span class="p">:</span>
<span class="mi">13</span>     <span class="c"># Initialize emulator in X86-32bit mode</span>
<span class="mi">14</span>     <span class="n">mu</span> <span class="o">=</span> <span class="n">Uc</span><span class="p">(</span><span class="n">UC_ARCH_X86</span><span class="p">,</span> <span class="n">UC_MODE_32</span><span class="p">)</span>
<span class="mi">15</span> 
<span class="mi">16</span>     <span class="c"># map 2MB memory for this emulation</span>
<span class="mi">17</span>     <span class="n">mu</span><span class="o">.</span><span class="n">mem_map</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
<span class="mi">18</span> 
<span class="mi">19</span>     <span class="c"># write machine code to be emulated to memory</span>
<span class="mi">20</span>     <span class="n">mu</span><span class="o">.</span><span class="n">mem_write</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="n">X86_CODE32</span><span class="p">)</span>
<span class="mi">21</span> 
<span class="mi">22</span>     <span class="c"># initialize machine registers</span>
<span class="mi">23</span>     <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_ECX</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">)</span>
<span class="mi">24</span>     <span class="n">mu</span><span class="o">.</span><span class="n">reg_write</span><span class="p">(</span><span class="n">UC_X86_REG_EDX</span><span class="p">,</span> <span class="mh">0x7890</span><span class="p">)</span>
<span class="mi">25</span> 
<span class="mi">26</span>     <span class="c"># emulate code in infinite time &amp; unlimited instructions</span>
<span class="mi">27</span>     <span class="n">mu</span><span class="o">.</span><span class="n">emu_start</span><span class="p">(</span><span class="n">ADDRESS</span><span class="p">,</span> <span class="n">ADDRESS</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">X86_CODE32</span><span class="p">))</span>
<span class="mi">28</span> 
<span class="mi">29</span>     <span class="c"># now print out some registers</span>
<span class="mi">30</span>     <span class="k">print</span><span class="p">(</span><span class="s">"Emulation done. Below is the CPU context"</span><span class="p">)</span>
<span class="mi">31</span> 
<span class="mi">32</span>     <span class="n">r_ecx</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_ECX</span><span class="p">)</span>
<span class="mi">33</span>     <span class="n">r_edx</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">reg_read</span><span class="p">(</span><span class="n">UC_X86_REG_EDX</span><span class="p">)</span>
<span class="mi">34</span>     <span class="k">print</span><span class="p">(</span><span class="s">"&gt;&gt;&gt; ECX = 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span><span class="n">r_ecx</span><span class="p">)</span>
<span class="mi">35</span>     <span class="k">print</span><span class="p">(</span><span class="s">"&gt;&gt;&gt; EDX = 0x</span><span class="si">%</span><span class="s">x"</span> <span class="o">%</span><span class="n">r_edx</span><span class="p">)</span>
<span class="mi">36</span> 
<span class="mi">37</span> <span class="k">except</span> <span class="n">UcError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="mi">38</span>     <span class="k">print</span><span class="p">(</span><span class="s">"ERROR: </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果如下:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python test1.py 
Emulate i386 code
Emulation <span class="k">done</span><span class="nb">.</span> Below is the CPU context
<span class="o">&gt;&gt;&gt;</span> ECX <span class="o">=</span> 0x1235
<span class="o">&gt;&gt;&gt;</span> EDX <span class="o">=</span> 0x788f
</code></pre></div></div>

<p>样例里的注释已经非常直观, 但我们还是对每一行代码做出解释:</p>
<ul>
  <li>行号2~3: 在使用Unicorn前导入<code class="highlighter-rouge">unicorn</code>模块. 样例中使用了一些x86寄存器常量, 所以也需要导入<code class="highlighter-rouge">unicorn.x86_const</code>模块</li>
  <li>行号6: 这是我们需要模拟的二进制机器码, 使用十六进制表示, 代表的汇编指令是: “INC ecx” 和 “DEC edx”.</li>
  <li>行号9: 我们将模拟执行上述指令的所在虚拟地址</li>
  <li>行号14: 使用<code class="highlighter-rouge">Uc</code>类初始化Unicorn, 该类接受2个参数: 硬件架构和硬件位数(模式). 在样例中我们需要模拟执行x86架构的32位代码, 我们使用变量<code class="highlighter-rouge">mu</code>来接受返回值.</li>
  <li>行号17: 使用<code class="highlighter-rouge">mem_map </code>方法根据在行号9处声明的地址, 映射2MB用于模拟执行的内存空间. 所有进程中的CPU操作都应该只访问该内存区域. 映射的内存具有默认的读,写和执行权限.</li>
  <li>行号20: 将需要模拟执行的代码写入我们刚刚映射的内存中. <code class="highlighter-rouge">mem_write</code>方法接受2个参数: 要写入的内存地址和需要写入内存的代码.</li>
  <li>行号23~24: 使用<code class="highlighter-rouge">reg_write</code>方法设置<code class="highlighter-rouge">ECX</code>和<code class="highlighter-rouge">EDX</code>寄存器的值</li>
  <li>行号27: 使用<code class="highlighter-rouge">emu_start</code>方法开始模拟执行, 该API接受4个参数: 要模拟执行的代码地址, 模拟执行停止的内存地址(这里是<code class="highlighter-rouge">X86_CODE32</code>的最后1字节处), 模拟执行的时间和需要执行的指令数目. 如果我们像样例一样忽略后两个参数, Unicorn将会默认以无穷时间和无穷指令数目的条件来模拟执行代码.</li>
  <li>行号32~35: 打印输出<code class="highlighter-rouge">ECX</code>和<code class="highlighter-rouge">EDX</code>寄存器的值. 我们使用函数<code class="highlighter-rouge">reg_read</code>来读取寄存器的值.</li>
</ul>

<p>要想查看更多的python示例, 可以查看文件夹<a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings/python">bindings/python</a>下的代码. 而C的示例则可以查看<a href="https://github.com/unicorn-engine/unicorn/tree/master/samples">sample</a>文件夹下的代码.</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="http://www.unicorn-engine.org/">Unicorn Official Site</a></li>
  <li><a href="http://www.unicorn-engine.org/docs/">Quick tutorial on programming with Unicorn - with C &amp; Python.</a></li>
  <li><a href="http://eternal.red/2018/unicorn-engine-tutorial/">Unicorn Engine tutorial</a></li>
  <li><a href="https://platform.avatao.com/paths/8e720072-9169-4d4c-9569-c330ce7fd947/challenges/28f5ae81-6a01-11e6-bdf4-0800200c9a66">Avatao tool tutorials: Unicorn</a></li>
</ul>

</section>
<section align="right">
<br/>
<span>
	<a  href="/2018/01/21/pyc-structure/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2018/02/06/solve-white-habbit-crackme/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://localhost:4000/2018/01/21/pyc-structure/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://localhost:4000/2018/02/06/solve-white-habbit-crackme/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>